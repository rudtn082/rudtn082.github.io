<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>AURORA - The River [정보/가사/해석]</title>
    <link href="/music6/"/>
    <url>/music6/</url>
    
    <content type="html"><![CDATA[<h1 id="AURORA-The-River-곡-정보"><a href="#AURORA-The-River-곡-정보" class="headerlink" title="AURORA - The River 곡 정보"></a>AURORA - The River 곡 정보</h1><p>[부산촌놈 in 시드니] 등에서도 나왔던 노래다.<br>노래추천 #힐링 #감성 #팝송 #몽환 #오로라  </p><p><img src="/images/post/music6_1.jpg" alt="music6_1">  </p><p>앨범 : The River<br>발매일 : 2019.05.10<br>장르 : POP  </p><iframe src="https://www.youtube.com/embed/P7lE-G1oC34" width="600" height="340" style="margin: 15px auto; display: block;"></iframe>  <h1 id="가사-x2F-해석"><a href="#가사-x2F-해석" class="headerlink" title="[가사&#x2F;해석]"></a>[가사&#x2F;해석]</h1><p>Hold your hands up to your chest<br>손을 모아 가슴에 대봐</p><p>And tell me what you find<br>그리고 뭐가 느껴지는지 말해줘</p><p>Out of you, a sparrow comes<br>너로부터 참새가 날아올라</p><p>And sees without its eyes<br>그건 눈도 없이 앞을 봐</p><p>Don’t forget who you are even though you are hurt<br>지금 상처받았더라도 네가 누구인지 잊지 마</p><p>You are caught in a wire and soon it will burst<br>너를 묶은 줄은 얼마 안 가 터질 거야</p><p>You can cry<br>울어도 괜찮아</p><p>Drinking your eyes<br>너 자신의 눈을 마시며</p><p>Do you miss the sadness when it’s gone? (Gone)<br>슬픔이 사라지면 그걸 그리워하니?</p><p>And you let the river run wild (Gone)<br>눈물의 강이 멋대로 흐르게 둬</p><p>And you let the river run wild<br>눈물의 강이 멋대로 흐르게 둬</p><p>I’m a shadow, I am cold<br>나는 그림자야, 나는 차가워</p><p>And now I seek for warmth<br>이제 나는 온기가 필요해</p><p>Stitch your skin onto my skin<br>네 살갗을 내 살 위에 꿰매면</p><p>And we won’t be alone<br>우리는 혼자가 아닐 거야</p><p>Don’t forget who you are even though you’re in need<br>어려움에 처했을 때도 네가 누군지 잊지 마</p><p>Like a bird in the night, your emotions deserves to be freed<br>밤에 날아오르는 새처럼 너의 감정도 자유로워져야 하니까</p><p>You can cry<br>울어도 괜찮아</p><p>Drinking your eyes<br>너 자신의 눈을 마시며</p><p>Do you miss the sadness when it’s gone? (Gone)<br>슬픔이 사라지면 그걸 그리워하니?</p><p>And you let the river run wild (Gone)<br>눈물의 강이 멋대로 흐르게 둬</p><p>And you let the river run wild<br>눈물의 강이 멋대로 흐르게 둬</p><p>You can cry (You can cry)<br>울어도 괜찮아</p><p>Drinking your eyes<br>너 자신의 눈을 마시며</p><p>I don’t miss the sadness when it’s gone (Gone)<br>난 슬픔이 사라져도 그리워하지 않아</p><p>And the feeling of it makes me smile (Gone)<br>그런 감정이 나를 웃게 하니까</p><p>As I let the river run wild<br>내가 강이 멋대로 흐르게 할 때</p><p>You can cry, you can cry, you can cry<br>울어도 돼, 울어도 돼, 울어도 돼</p><p>To where the ocean is bigger<br>더 넓은 바다가 있는 곳까지</p><p>Become a part of the river<br>강의 일부가 되어서</p><p>You can cry, you can cry, you can cry<br>울어도 돼, 울어도 돼, 울어도 돼</p><p>Can you let the river run wild?<br>눈물의 강을 풀어둘 수 있겠어?</p><p>You can cry<br>울어도 괜찮아</p><p>(You can cry, you can cry, you can cry)<br>(울어도 돼, 울어도 돼, 울어도 돼)</p><p>Drinking your eyes<br>너 자신의 눈을 마시며</p><p>Do you miss the sadness when it’s gone? (Gone)<br>슬픔이 사라지면 그걸 그리워하니?</p><p>(You can cry, you can cry, you can cry)<br>(울어도 돼, 울어도 돼, 울어도 돼)</p><p>And you let the river run wild (Gone)<br>눈물의 강이 멋대로 흐르게 둬</p><p>And you let the river run wild<br>눈물의 강이 멋대로 흐르게 둬</p><p>You can cry (You can cry)<br>울어도 괜찮아</p><p>(You can cry, you can cry, you can cry)<br>(울어도 돼, 울어도 돼, 울어도 돼)</p><p>Drinking your eyes<br>너 자신의 눈을 마시며</p><p>(To where the ocean is bigger)<br>(더 넓은 바다가 있는 곳까지)</p><p>I don’t miss the sadness when it’s gone (Gone)<br>난 슬픔이 사라져도 그리워하지 않아</p><p>And the feeling of it makes me smile (Gone)<br>그런 감정이 나를 웃게 하니까</p><p>As I let the river run wild<br>내가 강이 멋대로 흐르게 할 때</p><p>You can cry<br>울어도 괜찮아</p><p>Drinking your eyes<br>너 자신의 눈을 마시며</p><p>Do you miss the sadness when it’s gone?<br>슬픔이 사라지면 그걸 그리워하니?</p><p>And you let the river run wild<br>눈물의 강이 멋대로 흐르게 둬</p><p>And you let the river run wild<br>눈물의 강이 멋대로 흐르게 둬</p>]]></content>
    
    
    <categories>
      
      <category>MUSIC</category>
      
    </categories>
    
    
    <tags>
      
      <tag>음악</tag>
      
      <tag>노래</tag>
      
      <tag>추천</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>The Cranberries - Ode To My Family [정보/가사/해석]</title>
    <link href="/music5/"/>
    <url>/music5/</url>
    
    <content type="html"><![CDATA[<h1 id="The-Cranberries-Ode-To-My-Family-곡-정보"><a href="#The-Cranberries-Ode-To-My-Family-곡-정보" class="headerlink" title="The Cranberries - Ode To My Family 곡 정보"></a>The Cranberries - Ode To My Family 곡 정보</h1><p>개그콘서트를 더불어 다수 프로그램에서 많이 쓰였고 뚜 뚜루뚜~ 부분을 사람들이 많이 기억하고 있다.<br>노래추천 #추억 #두근두근 #썸 #슬픔 #가족 #감성적  </p><p><img src="/images/post/music5_1.jpg" alt="music5_1">  </p><p>앨범 : No Need to Argue<br>발매일 : 1994.11.21<br>장르 : 록&#x2F;메탈  </p><iframe src="https://www.youtube.com/embed/kT9iPFnRR_o" width="600" height="340" style="margin: 15px auto; display: block;"></iframe>  <h1 id="가사-x2F-해석"><a href="#가사-x2F-해석" class="headerlink" title="[가사&#x2F;해석]"></a>[가사&#x2F;해석]</h1><p>Understand the things I say<br>이런 말 해도 이해해 주세요</p><p>Don’t turn away from me<br>내게서 떠나가지 말아요</p><p>‘Cause I’ve spent half my life out there<br>난 인생의 반절을 거기서 보냈잖아요</p><p>You wouldn’t disagree<br>부정하진 못할 거예요</p><p>Do you see me, do you see?<br>내가 보이나요, 보고 있나요?</p><p>Do you like me<br>날 좋아해 줄 건가요?</p><p>Do you like me standing there?<br>여기 있는 날 좋아해 줄 건가요?</p><p>Do you notice, do you know<br>느낄 수 있나요, 알고 있나요?</p><p>Do you see me, do you see me?<br>내가 보이나요, 보고 있는 건가요?</p><p>Does anyone care?<br>이젠 누가 신경이나 쓸까요?</p><p>Unhappiness<br>불행이란 건</p><p>Where’s when I was young<br>어린아이였던 시절엔</p><p>And we didn’t give a damn<br>신경조차 쓰지 않았죠</p><p>‘Cause we were raised<br>우린 그렇게 배웠으니까</p><p>To see life as fun and take it if we can<br>삶은 재미있는 거고, 가능하면 즐겨 보라고</p><p>My mother, my mother<br>엄마, 우리 엄마</p><p>She’d hold me<br>날 붙잡아 주셨죠</p><p>She’d hold me when I was out there<br>내가 거기 있을 때 날 붙잡아 주셨죠</p><p>My father, my father<br>아빠, 우리 아빠</p><p>He liked me, well he liked me<br>날 예뻐했죠, 날 예뻐해 주셨죠</p><p>Does anyone care?<br>이젠 누가 신경이나 쓸까요?</p><p>Understand what I’ve become<br>이렇게 된 나를 이해해 주세요</p><p>It wasn’t my design<br>내가 계획한 건 아니었으니까</p><p>And people everywhere think<br>어디서든 사람들은 내게서</p><p>Something better than I am<br>더 많은 것을 원하기만 하죠</p><p>But I miss you, I miss<br>당신이 그리워요</p><p>‘Cause I liked it<br>그때가 좋았으니까</p><p>‘Cause I liked it<br>그때가 좋았으니까</p><p>When I was out there<br>거기 있던 그 시절</p><p>Do you know this, do you know<br>알고 있나요, 알고 있나요?</p><p>You did not find me<br>날 찾지 않았죠</p><p>You did not find<br>찾아 주지 않았죠</p><p>Does anyone care?<br>이젠 누가 신경이나 쓸까요?</p><p>Unhappiness<br>불행이란 건</p><p>Where’s when I was young<br>어린아이였던 시절엔</p><p>And we didn’t give a damn<br>신경조차 쓰지 않았죠</p><p>‘Cause we were raised<br>우린 그렇게 배웠으니까</p><p>To see life as fun and take it if we can<br>삶은 재미있는 거고, 가능하면 즐겨 보라고</p><p>My mother, my mother<br>엄마, 우리 엄마</p><p>She’d hold me<br>날 붙잡아 주셨죠</p><p>She’d hold me when I was out there<br>내가 거기 있을 때 날 붙잡아 주셨죠</p><p>My father, my father<br>아빠, 우리 아빠</p><p>He liked me, well he liked me<br>날 예뻐했죠, 날 예뻐해 주셨죠</p><p>Does anyone care?<br>이젠 누가 신경이나 쓸까요?</p><p>Does anyone care?<br>이젠 누가 신경이나 쓸까요?</p><p>Does anyone care?<br>이젠 누가 신경이나 쓸까요?</p><p>Does anyone care?<br>이젠 누가 신경이나 쓸까요?</p><p>Does anyone care?<br>이젠 누가 신경이나 쓸까요?</p><p>Does anyone care?<br>이젠 누가 신경이나 쓸까요?</p><p>Does anyone care?<br>이젠 누가 신경이나 쓸까요?</p><p>Does anyone care?<br>이젠 누가 신경이나 쓸까요?</p><p>Does anyone care?<br>이젠 누가 신경이나 쓸까요?</p><p>Does anyone care?<br>이젠 누가 신경이나 쓸까요?</p>]]></content>
    
    
    <categories>
      
      <category>MUSIC</category>
      
    </categories>
    
    
    <tags>
      
      <tag>음악</tag>
      
      <tag>노래</tag>
      
      <tag>추천</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Lukas Graham - Don&#39;t You Worry &#39;Bout Me [정보/가사/해석]</title>
    <link href="/music4/"/>
    <url>/music4/</url>
    
    <content type="html"><![CDATA[<h1 id="Lukas-Graham-Don’t-You-Worry-‘Bout-Me-곡-정보"><a href="#Lukas-Graham-Don’t-You-Worry-‘Bout-Me-곡-정보" class="headerlink" title="Lukas Graham - Don’t You Worry ‘Bout Me 곡 정보"></a>Lukas Graham - Don’t You Worry ‘Bout Me 곡 정보</h1><p>[MBC 구해줘! 홈즈] 에서도 나왔던 노래다.<br>노래추천 #팝 #소울 #중독성  </p><p><img src="/images/post/music4_1.png" alt="music4_1">  </p><p>앨범 : Lukas Graham<br>발매일 : 2016.04.01<br>장르 : POP  </p><iframe src="https://www.youtube.com/embed/G_buYWqHfNo" width="600" height="340" style="margin: 15px auto; display: block;"></iframe>  <h1 id="가사-x2F-해석"><a href="#가사-x2F-해석" class="headerlink" title="[가사&#x2F;해석]"></a>[가사&#x2F;해석]</h1><p>Hey my friend, how you’ve been?<br>친구야, 그동안 어디 있었어?</p><p>What are you going through?<br>무슨 일을 겪은 거야?</p><p>What is this trouble, that’s troubling you?<br>이 문제는 뭐야, 그게 너를 괴롭히니?</p><p>He tried to turn the thing around<br>그는 그것들을 회복시키려 했어</p><p>And asked me how I’ve been<br>그리고 내게 어떻게 지냈었는지 물었어</p><p>I said, I really don’t know where to begin<br>난 말했어, 난 정말로 어디서부터 시작해야 될지 모르겠다고</p><p>I saw my life come crashing down<br>난 내 삶이 무너지는 걸 봤어</p><p>I crawled, I walked, I’m flying now<br>난 기어갔어, 난 걸어갔어, 지금 난 날아가</p><p>I found my strength on my knees<br>난 내 무릎에 있는 힘을 발견했어</p><p>Don’t you worry ‘bout me<br>나에 대해서는 걱정하지 마</p><p>Don’t you worry ‘bout me<br>나에 대해서는 걱정하지 마</p><p>Don’t you worry ‘bout me<br>나에 대해서는 걱정하지 마</p><p>Don’t you worry ‘bout me<br>나에 대해서는 걱정하지 마</p><p>A lot of people told me<br>많은 사람들은 내게 말하곤 했어</p><p>When daddy passed away<br>아버지가 돌아가셨을 때</p><p>Go take some time off<br>휴식을 취하라고</p><p>But I’ve got no time to waste<br>하지만 난 시간을 낭비하고 싶지 않았어</p><p>Don’t you have a dream too<br>너 또한 꿈이 없니?</p><p>Some goals you’ve got to make<br>니가 이룬 몇개의 목표들</p><p>You may feel small sometimes<br>넌 아마 작은 무언가를 느낄꺼야</p><p>It don’t mean you can’t be great<br>그건 니가 잘 할 수 없다는 뜻이 아냐</p><p>I saw my life come crashing down<br>난 내 삶이 무너지는 걸 봤어</p><p>I crawled, I walked, I’m flying now<br>난 기어갔어, 난 걸어갔어, 지금 난 날아가</p><p>I found my strength on my knees<br>난 내 무릎에 있는 힘을 발견했어</p><p>So, don’t you worry ‘bout me<br>그러니 나에 대해서는 걱정하지 마</p><p>Don’t you worry ‘bout me<br>나에 대해서는 걱정하지 마</p><p>Don’t you worry, worry, worry<br>걱정하지 마</p><p>Don’t you worry ‘bout me<br>나에 대해서는 걱정하지 마</p><p>Don’t you worry ‘bout me<br>나에 대해서는 걱정하지 마</p><p>Sometimes your life can bring you down<br>때때로 너의 삶이 너를 낙담시킨다 해도</p><p>Sometimes you run for miles and miles<br>가끔씩 니가 계속해서 달릴 때도</p><p>Sometimes you scream without hope<br>가끔씩 니가 희망 없이 소리친다 해도</p><p>Now once you feel you hit the ground<br>지금 한번 니가 바닥을 친 걸 느낀다면</p><p>Then victory comes back around<br>승리가 돌아 올꺼야</p><p>And you’ll be proud to let them know<br>그리고 넌 그들을 알게 한걸 자랑스러워 할꺼야</p><p>Don’t worry ‘bout me<br>나에 대해서는 걱정하지 마</p><p>Don’t you worry ‘bout me<br>나에 대해서는 걱정하지 마</p><p>Don’t you worry ‘bout me<br>나에 대해서는 걱정하지 마</p><p>Don’t you worry ‘bout me<br>나에 대해서는 걱정하지 마</p><p>Don’t you worry ‘bout me<br>나에 대해서는 걱정하지 마</p><p>Oh please<br>오 제발</p><p>Don’t you worry, worry, worry, worry<br>걱정하지 마</p><p>No, don’t you, don’t you, worry ‘bout me<br>아니, 나에 대해서는 걱정하지 마</p><p>Don’t you worry ‘bout me<br>나에 대해서는 걱정하지 마</p><p>Don’t you worry ‘bout me<br>나에 대해서는 걱정하지 마</p>]]></content>
    
    
    <categories>
      
      <category>MUSIC</category>
      
    </categories>
    
    
    <tags>
      
      <tag>음악</tag>
      
      <tag>노래</tag>
      
      <tag>추천</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>여름 일본 여행, 엔화 미리 환전할까?</title>
    <link href="/info13/"/>
    <url>/info13/</url>
    
    <content type="html"><![CDATA[<h1 id="엔화-가치-하락과-일본-여행"><a href="#엔화-가치-하락과-일본-여행" class="headerlink" title="엔화 가치 하락과 일본 여행"></a>엔화 가치 하락과 일본 여행</h1><p>최근 일본 엔화 가격이 100엔당 800원대까지 떨어지면서 올여름 휴가로 일본 여행을 계획하고 있는 사람들이 많다. 환차익을 염두에 두고 엔화를 매수하는 사례도 있다.  </p><p>또한, 항공통계에 따르면 6월 1~10일 국내 항공사의 인천↔나리타(도쿄) 노선을 이용한 여행객은 8만 9847명이었다. 이는 1월 같은 기간(6만 6741명)보다 34.6% 증가한 수치다. 일본 여행객은 다가오는 여름휴가철에 본격적으로 늘어날 것으로 전망이라고 한다.  </p><p>엔화 가치 하락이 이어지는 것은 미국과 유럽 등이 물가 상승을 막기 위해 금리를 올리거나 금리 인상을 계획하고 있지만 일본은 초저금리 정책을 고수하고 있기 때문이다. 일본은행은 금융정책결정회의에서 단기금리를 -0.1%로 동결하고 장기금리 지표인 10년물 국채금리를 0% 수준으로 유도하는 대규모 금융완화 정책을 유지하기로 했다.  </p><p>일본 정부가 최근 급격한 엔화 가치 하락을 막기 위해 외환시장에 개입할 수 있다고 시사하기도 하며, 올여름 일본 여행을 계획하고 있는 사람들 중 엔화를 미리 환전해야 할지 고민하는 경우도 있다.  </p><p><img src="/images/post/info13_1.png" alt="info13_1" title="info13_1"></p><h2 id="은행별-환전-수수료-우대율-비교"><a href="#은행별-환전-수수료-우대율-비교" class="headerlink" title="은행별 환전 수수료 우대율 비교"></a>은행별 환전 수수료 우대율 비교</h2><p>엔화는 은행별로 환전 수수료가 KDB산업은행 (1.50%)을 제외하고 비슷비슷하여 은행별 우대율을 통하여 비교하는 것이 바람직하다. 아래 표는 은행연합회 외환길잡이에서 제공하는 2023-06-27일 기준 수수료 및 우대율에 대한 내용이다.  </p><table style="background-color: #f6fff4; border-radius: 10px; border: 2px solid #3ca34c; margin: 10px auto; width: 900px; overflow: auto;" data-ke-align="alignLeft"><thead><tr><th scope="col">은행</th><th scope="col">환전수수료<br />(사실때)</th><th scope="col">기본우대율<br />(%)</th><th scope="col">최대우대율<br />(%)</th><th scope="col">우대사항&middot;환전이벤트</th><th scope="col">기준일</th></tr></thead><tbody><tr><th scope="row"><a class="fc2" href="https://banking.kdb.co.kr/bp/index.jsp" target="_blank" rel="noopener"><b>KDB산업은행</b></a></th><td class="ac" style="text-align: center;">1.50%</td><td class="ac" style="text-align: center;">30%</td><td class="ac" style="text-align: center;">70%</td><td>-</td><td class="ac" style="text-align: center;">2023.06.02</td></tr><tr><th scope="row"><a class="fc2" href="http://www.nonghyup.com/Main/main.aspx" target="_blank" rel="noopener"><b>NH농협은행</b></a></th><td class="ac" style="text-align: center;">1.75%</td><td class="ac" style="text-align: center;">50%</td><td class="ac" style="text-align: center;">80%<br />(올원뱅크 앱 90%)</td><td>1. 환전금액에 따른 우대환율적용<br />- USD 500 상당액이하 : 50%<br />- USD 3,000 상당액이하 : 60%<br />- USD 10,000 상당액이하 : 70%<br />2. 최근1년이내 인터넷환전 이용실적 있는 경우 10% 추가우대(외화 수령점 기준으로 농협은행, 지역농축협 각각 별도적용)<br />3. 올원뱅크 앱 이용시 90% 우대</td><td class="ac" style="text-align: center;">2023.06.05</td></tr><tr><th scope="row"><a class="fc2" href="http://www.shinhan.com/" target="_blank" rel="noopener"><b>신한은행</b></a></th><td class="ac" style="text-align: center;">1.75%</td><td class="ac" style="text-align: center;">50%</td><td class="ac" style="text-align: center;">90%</td><td>1. 환전금액에 따른 추가 우대<br />- 1회 환전금액이 USD 2,000 상당액 초과시 : 10%<br />- 1회 환전금액이 USD 5,000 상당액 초과시 : 20%<br />2. 최근 6개월 이내 인터넷 환전 실적 있을 경우 : 10%<br />* 개인 인터넷뱅킹 환전 실적만 인정하며 쏠(SOL)뱅크 환적실적은 불포함<br />3. SNS 추천메세지 보내기 : 10%<br />※ 부가서비스(항공사마일리지 또는 OK 캐쉬백 적립) 선택시 환율 우대 서비스를 받을 수 없습니다.<br />4. 쏠(SOL)뱅크 환전 시<br />- USD, JPY, EUR (70~90%)<br />- CAD, HKD, AUD, CNY, THB, GBP, CHF, SGD, NZD (30~50%)<br />- PHP, TWD, IDR, AED, VND, MYR (20~30%)<br />※ 쏠(SOL)뱅크 환전은 인터넷 환전 추가 우대 미적용 대상입니다.</td><td class="ac" style="text-align: center;">2023.06.01</td></tr><tr><th scope="row"><a class="fc2" href="https://www.wooribank.com/" target="_blank" rel="noopener"><b>우리은행</b></a></th><td class="ac" style="text-align: center;">1.75%</td><td class="ac" style="text-align: center;">50%</td><td class="ac" style="text-align: center;">75%<br />(우리WON뱅킹 환전 시 80%)</td><td>1.환전금액에 따른 추가우대<br />- USD 1,000 상당액 이상 : 10%<br />- USD 5,000 상당액 이상 : 20%<br />2. 닷컴통장을 환전대금 결제계좌로 사용 시 5% 추가 할인<br />3. 우리WON뱅킹에서 환전 시 환율우대 최대 80%</td><td class="ac" style="text-align: center;">2023.06.01</td></tr><tr><th scope="row"><a class="fc2" href="http://www.standardchartered.co.kr/np/kr/pl/et/ExchangeRateP1.jsp?ptfrm=HIN.KOR.INTRO.pin9" target="_blank" rel="noopener"><b>SC제일은행</b></a></th><td class="ac" style="text-align: center;">1.75%</td><td class="ac" style="text-align: center;">30%</td><td class="ac" style="text-align: center;">모바일 뱅킹: 최대 80%<br />인터넷 뱅킹: 최대 30%</td><td>[모바일 뱅킹]<br />(1) 현찰 환전<br />- 환전 금액 및 실적과 관계 없이 모든 SC제일은행 개인 고객 동일 적용<br />- 현찰 환전 한도: 1회 USD 기준 5천불까지 가능<br />- 현찰 환전 통화: USD,JPY, EUR (그 외 통화 거래 불가)<br /><br />(2) 전신환 환전<br />(현찰이 아닌 통장 내 외화 사고 팔기 거래) <br />- 환전 금액 및 실적과 관계 없이 모든 SC제일은행 개인 고객 동일 적용<br />- 환전 한도: 개인 인터넷, 모바일 뱅킹 1일/1회 이체 한도 내( USD 환산금액 ~300,000 가능)<br />- USD, JPY, EUR, CNY, GBP : 80% 환율 우대 적용<br />CAD, CHF, HKD, AUD, SGD : 50% 환율 우대 적용<br /><br />[인터넷 뱅킹]<br />- 현찰 및 전신환 환전 시 최대 30% 우대</td><td class="ac" style="text-align: center;">2022.06.03</td></tr><tr><th scope="row"><a class="fc2" href="https://www.hanabank.com/" target="_blank" rel="noopener"><b>하나은행</b></a></th><td class="ac" style="text-align: center;">1.75%</td><td class="ac" style="text-align: center;">50%</td><td class="ac" style="text-align: center;">80%<br />(비로그인70%)</td><td>&nbsp;</td><td class="ac" style="text-align: center;">2023.06.02</td></tr><tr><th scope="row"><a class="fc2" href="http://www.ibk.co.kr/main.html" target="_blank" rel="noopener"><b>IBK기업은행</b></a></th><td class="ac" style="text-align: center;">1.75%</td><td class="ac" style="text-align: center;">70%<br />(사이버환전)</td><td class="ac" style="text-align: center;">90%<br />(ONE할 때 환전/i-ONE모두다환전)</td><td>[사이버환전,ONE할때환전]<br />1.신라인터넷면세점 혜택 <br />(멤버십 업그레이드, S.reward 470,000P)<br />2. 포켓와이파이 15% 할인</td><td class="ac" style="text-align: center;">2023.06.01</td></tr><tr><th scope="row"><a class="fc2" href="https://www.kbstar.com/" target="_blank" rel="noopener"><b>KB국민은행</b></a></th><td class="ac" style="text-align: center;">1.75%</td><td class="ac" style="text-align: center;">80%</td><td class="ac" style="text-align: center;">80%</td><td>- 해외여행자보험 가입시 환율우대율 10% 축소<br />- 비로그인 환전시 환율우대율 10% 축소</td><td class="ac" style="text-align: center;">2022.12.09</td></tr><tr><th scope="row"><a class="fc2" href="https://www.citibank.co.kr" target="_blank" rel="noopener"><b>한국씨티은행</b></a></th><td class="ac" style="text-align: center;">1.75%</td><td class="ac" style="text-align: center;">60%</td><td class="ac" style="text-align: center;">80%</td><td>*환전금액에 따른 추가 우대 <br />- $1,000 이상 $5,000 미만 : 10%<br />- $5,000 이상 $10,000 미만 : 20%<br />*다른 환율우대조건이 중복되는 경우 고객에게 유리한 환율이 적용됩니다.</td><td class="ac" style="text-align: center;">2023.06.01</td></tr><tr><th scope="row"><a class="fc2" href="https://www.suhyup-bank.com/" target="_blank" rel="noopener"><b>Sh수협은행</b></a></th><td class="ac" style="text-align: center;">1.90%</td><td class="ac" style="text-align: center;">80%</td><td class="ac" style="text-align: center;">80%</td><td>&nbsp;</td><td class="ac" style="text-align: center;">2023.06.01</td></tr><tr><th scope="row"><a class="fc2" href="https://www.dgb.co.kr/dgb_ebz_main.jsp" target="_blank" rel="noopener"><b>DGB대구은행</b></a></th><td class="ac" style="text-align: center;">1.75%</td><td class="ac" style="text-align: center;">30%</td><td class="ac" style="text-align: center;">80%</td><td>1. 인터넷 뱅킹/ 스마트 뱅킹 환전 예약(로그인 고객) : 우대율 30%<br />- 영업시간 (9시~16시) : 미화 100불 상당액 이상 ~ 50,000불 상당액 이하<br />- 영업시간 외 (공휴일 포함, 전 시간) : 미화 100불 상당액 이상 ~ 5,000불 상당액 이하<br />- 건당 200불(미화 기준) 이상 환전시 티웨이 항공 e-할인쿠폰(1만원) 제공 (국제선 이용에 한함)<br /><br />2. 인터넷 뱅킹/ 스마트 뱅킹 환전 예약(비로그인 고객) : 우대율 30%<br />- 365일, 24시간 : 미화 100불 상당액 이상 ~ 원화 1백만원 이하 <br /><br />3. DGB외화기프티콘(365일, 24시간)<br />- 인터넷 뱅킹/ 스마트 뱅킹 / 아이M뱅크<br />- 미화 50불 상당액 이상 ~ 원화 1백만원 이하 (1일 제한 1백만원) : 우대율 80%</td><td class="ac" style="text-align: center;">2023.06.01</td></tr><tr><th scope="row"><a class="fc2" href="https://www.busanbank.co.kr/" target="_blank" rel="noopener"><b>BNK부산은행</b></a></th><td class="ac" style="text-align: center;">1.75%</td><td class="ac" style="text-align: center;">50%</td><td class="ac" style="text-align: center;">90%</td><td>- 로그인환전 우대율 : 90%<br />- 비로그인환전 우대율 : 80%</td><td class="ac" style="text-align: center;">2023.06.01</td></tr><tr><th scope="row"><a class="fc2" href="http://www.kjbank.com/banking/index.jsp" target="_blank" rel="noopener"><b>광주은행</b></a></th><td class="ac" style="text-align: center;">1.75%</td><td class="ac" style="text-align: center;">50%</td><td class="ac" style="text-align: center;">-</td><td>-</td><td class="ac" style="text-align: center;">2023.06.02</td></tr><tr><th scope="row"><a class="fc2" href="https://www.e-jejubank.com/JeJuBankInfo.do" target="_blank" rel="noopener"><b>제주은행</b></a></th><td class="ac" style="text-align: center;">1.75%</td><td class="ac" style="text-align: center;">70%</td><td class="ac" style="text-align: center;">90%</td><td>제주은행보유계좌고객</td><td class="ac" style="text-align: center;">2022.02.09</td></tr><tr><th scope="row"><a class="fc2" href="https://www.jbbank.co.kr/" target="_blank" rel="noopener"><b>전북은행</b></a></th><td class="ac" style="text-align: center;">1.75%</td><td class="ac" style="text-align: center;">30%</td><td class="ac" style="text-align: center;">80%</td><td>1. 기본우대율 : 30%<br />2. 고객등급별환율우대<br />- 슈퍼고객 : 50%<br />- 로얄고객 : 40%<br />- 골드고객 : 30%</td><td class="ac" style="text-align: center;">2021.07.01</td></tr><tr><th scope="row"><a class="fc2" href="https://www.knbank.co.kr/ib20/mnu/BHP000000000001" target="_blank" rel="noopener"><b>BNK경남은행</b></a></th><td class="ac" style="text-align: center;">1.75%</td><td class="ac" style="text-align: center;">50%</td><td class="ac" style="text-align: center;">90%</td><td>1. 인터넷환전(인터넷뱅킹)<br />- 통화 및 금액에 상관없이 50% 우대<br />- 외화실물 인수 영업점 : 경남은행 전영업점, 부산은행 김해공항지점<br /><br />2. BNK 더조은 환전(모바일뱅킹 內 환전서비스) 경남은행 전 영업점 수령시<br />1) 은행영업일 09시부터~18시 전 <br />- USD, JPY, EUR (90%)<br />- AUD, CNY, HKD, THB (50%) 우대 <br />2) 은행영업일 18시부터~익 영업일 09시 전(주말, 휴일 포함)<br />- USD, JPY, EUR 50% 우대<br />- AUD, CNY, HKD, THB 50% (비회원 30%) 우대 <br /><br />3. 부산은행 수령건 50% 우대</td><td class="ac" style="text-align: center;">2023.01.31</td></tr></tbody></table><p>다음은 수수료와 우대율별로 엔화를 원화로 환산한 금액이 얼마나 차이나는지 비교해 보았다.  </p><p>공통 조건  </p><p>구입통화 : 50,000엔<br>매매기준율 : 903.43원 (2023-06-27 기준)  </p><table style="background-color: #f6fff4; border-radius: 10px; border: 2px solid #3ca34c; margin: 10px auto; width: 900px; overflow: auto;" border="1" data-ke-align="alignLeft"><tbody><tr style="height: 20px;"><td style="width: 11.8993%; height: 20px; text-align: center;"><b>수수료</b></td><td style="width: 10.0775%; height: 20px; text-align: center;"><b>우대율</b></td><td style="width: 10.504%; height: 20px; text-align: center;"><b>환전수수료</b></td><td style="width: 17.5194%; height: 20px; text-align: center;"><b>결제금액</b></td></tr><tr style="height: 20px;"><td style="width: 11.8993%; height: 20px; text-align: center;">1.50%</td><td style="width: 10.0775%; height: 20px; text-align: center;">70%</td><td style="width: 10.504%; height: 20px; text-align: center;">6,775<span style="color: #333333; text-align: start;"><span>&nbsp;</span>원</span></td><td style="width: 17.5194%; height: 20px; text-align: center;">453,747 원</td></tr><tr style="height: 20px;"><td style="width: 11.8993%; height: 20px; text-align: center;">1.50%</td><td style="width: 10.0775%; height: 20px; text-align: center;">30%</td><td style="width: 10.504%; height: 20px; text-align: center;">6,775<span style="color: #333333; text-align: start;"><span>&nbsp;</span>원</span></td><td style="width: 17.5194%; height: 20px; text-align: center;">456,458 원</td></tr><tr style="height: 20px;"><td style="width: 11.8993%; height: 20px; text-align: center;">1.75%</td><td style="width: 10.0775%; height: 20px; text-align: center;">90%</td><td style="width: 10.504%; height: 20px; text-align: center;">7,905<span style="color: #333333; text-align: start;"><span>&nbsp;</span>원</span></td><td style="width: 17.5194%; height: 20px; text-align: center;"><b><span style="color: #1a5490;">452,505<span style="text-align: start;">&nbsp;원</span></span></b></td></tr><tr style="height: 20px;"><td style="width: 11.8993%; height: 20px; text-align: center;">1.75%</td><td style="width: 10.0775%; height: 20px; text-align: center;">80%</td><td style="width: 10.504%; height: 20px; text-align: center;">7,905<span style="color: #333333; text-align: start;"><span>&nbsp;</span>원</span></td><td style="width: 17.5194%; height: 20px; text-align: center;">453,296<span style="color: #333333; text-align: start;"><span>&nbsp;</span>원</span></td></tr><tr style="height: 20px;"><td style="width: 11.8993%; height: 20px; text-align: center;">1.75%</td><td style="width: 10.0775%; height: 20px; text-align: center;">70%</td><td style="width: 10.504%; height: 20px; text-align: center;">7,905<span style="color: #333333; text-align: start;"><span>&nbsp;</span>원</span></td><td style="width: 17.5194%; height: 20px; text-align: center;">454,086<span style="color: #333333; text-align: start;"><span>&nbsp;</span>원</span></td></tr><tr style="height: 20px;"><td style="width: 11.8993%; height: 20px; text-align: center;">1.75%</td><td style="width: 10.0775%; height: 20px; text-align: center;">50%</td><td style="width: 10.504%; height: 20px; text-align: center;">7,905<span style="color: #333333; text-align: start;"><span>&nbsp;</span>원</span></td><td style="width: 17.5194%; height: 20px; text-align: center;">455,667<span style="color: #333333; text-align: start;"><span>&nbsp;</span>원</span></td></tr><tr style="height: 20px;"><td style="width: 11.8993%; height: 20px; text-align: center;">1.75%</td><td style="width: 10.0775%; height: 20px; text-align: center;">30%</td><td style="width: 10.504%; height: 20px; text-align: center;">7,905<span style="color: #333333; text-align: start;"><span>&nbsp;</span>원</span></td><td style="width: 17.5194%; height: 20px; text-align: center;"><b><span style="color: #ee2323;">457,248<span style="text-align: start;">&nbsp;원</span></span></b></td></tr></tbody></table>  <p>결과에서 보듯이 1.75%의 수수료에 최대 우대율 90%까지 받는다면, 5만 엔을 약 45만 2천 원에 환전할 수 있다. 기본 우대율과 비교했을 때 4,700원 가까이 차이가 났다. 구입할 엔화가 많을수록 차이는 커질 것이다. 각자 주거래은행과 우대 이벤트에 참여할 수 있는 조건을 잘 확인해서 환전을 하는 것이 좋아 보인다.  </p><p>또한, 환전 수수료도 1.75% 일 경우 7,900원이나 내야 하는데 수수료를 아끼는 방법을 통해 조금이라도 절약할 수 있다. 대면으로 환전을 한다고 하면, 서울역 환전센터를 이용하여 환전을 하는 것이 수수료가 저렴하다. 비대면 환전을 한다고 하면 모바일 앱을 이용하는 것이 좋다. 주거래은행에서 모바일앱을 통해 비대면으로 환전할 경우 수수료가 최대 90%까지 면제될 수 있다. 모바일 앱을 통해 환전 신청을 해 둔 금액은 은행을 방문해서 받아도 되고, 출국 당일 공항이나 외화 ATM에서 찾으면 된다.  </p>]]></content>
    
    
    <categories>
      
      <category>INFO</category>
      
    </categories>
    
    
    <tags>
      
      <tag>정보</tag>
      
      <tag>일본</tag>
      
      <tag>여행</tag>
      
      <tag>엔화</tag>
      
      <tag>환전</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>COMPLETE MESS - 5 Seconds of Summer [정보/가사/해석]</title>
    <link href="/music3/"/>
    <url>/music3/</url>
    
    <content type="html"><![CDATA[<h1 id="COMPLETE-MESS-5-Seconds-of-Summer-곡-정보"><a href="#COMPLETE-MESS-5-Seconds-of-Summer-곡-정보" class="headerlink" title="COMPLETE MESS - 5 Seconds of Summer 곡 정보"></a>COMPLETE MESS - 5 Seconds of Summer 곡 정보</h1><p>[JTBC 톡파원 25시] 에서도 나왔던 노래다.<br>노래추천 #몽환적인 #우주적인 #차분 #밴드음악  </p><p><img src="/images/post/music3_1.png" alt="music3_1">  </p><p>앨범 : 5SOS5<br>발매일 : 2022.09.23<br>장르 : POP  </p><iframe src="https://www.youtube.com/embed/GoQ85cs5fk0" width="600" height="340" style="margin: 15px auto; display: block;"></iframe>  <h1 id="가사-x2F-해석"><a href="#가사-x2F-해석" class="headerlink" title="[가사&#x2F;해석]"></a>[가사&#x2F;해석]</h1><p>Caught up in Heaven, but your Heaven ain’t the same<br>천국에 사로잡힌지 오래지만, 너만의 천국은 또 다른 맛이 있어</p><p>And I’ve never been a saint, have I?<br>난 성자처럼 살아오진 않았어</p><p>This evanescence always fleeting like a flame<br>항상 꺼져가는 불씨같은 이 허전함</p><p>But I’m never one to change, am I?<br>나도 쉽게 변하는 사람은 아니야</p><p>Call it a lesson when I feel you slide away<br>네가 떠나가는 걸 또 하나의 교훈이라 부를래</p><p>And I’m missin’ out on half my life<br>인생의 절반도 제대로 못 채운채로</p><p>Oh, you make me complete<br>넌 날 완전히</p><p>You make me complete<br>넌 날 완전히</p><p>You make me a complete mess<br>넌 날 완전히 망가뜨려</p><p>Oh, you make me complete<br>넌 날 완전히</p><p>You make me complete<br>넌 날 완전히</p><p>You make me a complete mess<br>넌 날 완전히 망가뜨려</p><p>Hang on to moments like they’ll never drift away<br>절대 떠나가지 않도록 순간들을 움켜잡아</p><p>‘Cause you’ll never get to say goodbye<br>그러면 네가 날 떠날 기회조차 없을 테니까</p><p>I ask no questions as your colours take their hold<br>네가 색으로 날 채워가면서 난 의심조차 하지 않았어</p><p>As my darkness turns to gold inside<br>내 마음 속 어둠은 금빛으로 변했지 </p><p>I learned my lesson when I felt you slip away<br>네가 떠나간 건 또 하나의 교훈이 됐어</p><p>And I’m missing out on half my life<br>인생의 절반도 제대로 못 채운채로</p><p>Oh, you make me complete<br>넌 날 완전히</p><p>You make me complete<br>넌 날 완전히</p><p>You make me a complete mess<br>넌 날 완전히 망가뜨려</p><p>Oh, you make me complete<br>너 날 완전히</p><p>You make me complete<br>넌 날 완전히</p><p>You make me a complete mess<br>넌 날 완전히 망가뜨려</p><p>(You make me a complete mess)<br>(넌 날 완전히 망가뜨려)</p><p>(You make me a complete mess)<br>(넌 날 완전히 망가뜨려)</p><p>Caught up in Heaven, but your Heaven ain’t the same<br>천국에 사로잡힌지 오래지만, 너만의 천국은 그때완 달라</p><p>But I’ve never been a saint, have I?<br>나 또한 성자처럼 살아오진 않았지만</p><p>Oh, you make me complete<br>넌 날 완전히</p><p>You make me complete (You make me complete)<br>넌 날 완전히 (넌 날 완전히)</p><p>You make me a complete mess<br>넌 날 완전히 망가뜨려</p><p>Oh, you make me complete (You make me complete)<br>넌 날 완전히 (넌 날 완전히)</p><p>You make me complete (You make me complete)<br>넌 날 완전히 (넌 날 완전히)</p><p>You make me a complete mess<br>넌 날 완전히 망가뜨려</p>]]></content>
    
    
    <categories>
      
      <category>MUSIC</category>
      
    </categories>
    
    
    <tags>
      
      <tag>음악</tag>
      
      <tag>노래</tag>
      
      <tag>추천</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Sweet Baby (Feat. Cody Francis) - Bothnia [정보/가사/해석]</title>
    <link href="/music2/"/>
    <url>/music2/</url>
    
    <content type="html"><![CDATA[<h1 id="Sweet-Baby-Feat-Cody-Francis-Bothnia-곡-정보"><a href="#Sweet-Baby-Feat-Cody-Francis-Bothnia-곡-정보" class="headerlink" title="Sweet Baby (Feat. Cody Francis) - Bothnia 곡 정보"></a>Sweet Baby (Feat. Cody Francis) - Bothnia 곡 정보</h1><p>[SBS TV 생방송 투데이] 등에서도 나왔던 노래다.<br>노래 추천 #여름 노래 #아름다운 노래 #사랑에 빠지는 #편안한 노래 #귀여운 노래  </p><p><img src="/images/post/music2_1.jpg" alt="music2_1">  </p><p>앨범 : Sweet Baby<br>발매일 : 2019.05.10<br>장르 : 포크  </p><iframe src="https://www.youtube.com/embed/BohVky4O2Lo" width="600" height="340" style="margin: 15px auto; display: block;"></iframe>  <h1 id="가사-x2F-해석"><a href="#가사-x2F-해석" class="headerlink" title="[가사&#x2F;해석]"></a>[가사&#x2F;해석]</h1><p>I was never the one to write up a song for just anyone, I,<br>난 모두를 위한 노래를 만든 게 아니었어요. </p><p>I was always the one to find<br>한 사람을 찾기 위해서,  </p><p>myself lost in long conversations, though<br>하지만 긴 대화를 하며 길을 잃었죠. </p><p>‘Cause I’ve always been told that<br>왜냐면 난 항상 그런 말을 들었거든요 </p><p>things will unfold if you keep on waiting.<br>계속 기다리다 보면 뭔가는 이루어질 거라고. </p><p>But then you came along and proved me all wrong,<br>그런데 당신이 오면서 내가 틀린 걸 알았어요, </p><p>I was so mistaken.<br>내가 잘못 알고 있었던 거예요. </p><p>‘Cause you glue all the pieces back together<br>왜냐면 당신은 과거 조각들을 재결합하니까요. </p><p>Yeah you, you take all my wrongs and make ‘em better.<br>당신은 내 모든 잘못 들을 더 좋게 보이게 하네요. </p><p>Yeah you, you’re making me wanna try forever.<br>그래요, 당신은 내가 영원히 노력하도록 만들고 있어요. </p><p>I feel so free, Oh, my sweet baby.<br>난 자유로운 느낌이 들어요, 달콤한 당신이. </p><p>I was never the one to give up the ghost, no,<br>난 유령이라고 포기할 사람은 아니었죠. </p><p>I was so stuck I kept on playing my part<br>난 내 할 일을 계속해 왔어도 너무 답답했었죠. </p><p>wanting to give up ‘cause nothing was changing.<br>아무것도 변하지 않아서 포기하고 싶었어요. </p><p>But with you it’s so clear and now that you’re here,<br>하지만 여기 당신과 함께 있으니 분명해 보여요. </p><p>I see colors in every spectrum.<br>모든 게 보여요. </p><p>Guess I finally learned my lesson.<br>드디어 난 교훈을 얻은 것 같아요. </p><p>‘Cause you glue all the pieces back together<br>왜냐면 당신은 과거 조각들을 재결합하니까요. </p><p>Yeah you, you take all my wrongs and make ‘em better.<br>당신은 내 모든 잘못 들을 더 좋게 보이게 만들어요. </p><p>Yeah you, you’re making me wanna try forever.<br>그래요, 당신은 내가 영원히 노력하도록 만들고 있어요. </p><p>I feel so free, Oh, my sweet baby.<br>난 자유로운 느낌이 들어요, 달콤한 당신. </p><p>And I think to myself<br>내 자신을 생각하고 </p><p>And I’m thinking out loud<br>그리고 생각나는 대로 말을 해봐요. </p><p>We won’t need nothing else For the rest of our time<br>우리 함께할 시간 이외에 다른 건 필요 없어요. </p><p>And I know it so well<br>난 너무 잘 알고 있어요. </p><p>I will always be by your side.<br>항상 당신 곁에 있을 거예요. </p><p>‘Cause you glue all the pieces back together<br>왜냐면 당신은 과거 조각들을 재결합하니까요. </p><p>Yeah you, you take all my wrongs and make ‘em better.<br>당신은 내 모든 잘못 들을 더 좋게 보이게 하네요. </p><p>Yeah you, you’re making me wanna try forever.<br>그래요, 당신은 내가 영원히 노력하도록 만들고 있어요. </p><p>I feel so free, Oh, my sweet baby.<br>난 자유로운 느낌이 들어요, 달콤한 당신.</p><p>[x2]</p>]]></content>
    
    
    <categories>
      
      <category>MUSIC</category>
      
    </categories>
    
    
    <tags>
      
      <tag>음악</tag>
      
      <tag>노래</tag>
      
      <tag>추천</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>와그너의 수장, 예브게니 프리고진은 누구인가?</title>
    <link href="/info12/"/>
    <url>/info12/</url>
    
    <content type="html"><![CDATA[<h1 id="푸틴의-최대-위기-직면"><a href="#푸틴의-최대-위기-직면" class="headerlink" title="푸틴의 최대 위기 직면?"></a>푸틴의 최대 위기 직면?</h1><p>푸틴이 우크라이나 전면 침공을 지휘한 이래 그가 국내에서 직면한 최대 위기에 직면했다. 러시아 용병기업 와그너그룹의 수장 예브게니 프리고진이 무장 반란을 일으키면서 블라디미르 푸틴 러시아 대통령의 장악력이 위험이 빠졌다는 분석이 잇따르고 있다. 그렇다면 예브게니 프리고진은 누구일까?  </p><p><img src="/images/post/info12_1.png" alt="info12_1">  </p><h2 id="예브게니-프리고진"><a href="#예브게니-프리고진" class="headerlink" title="예브게니 프리고진"></a>예브게니 프리고진</h2><p>예브게니 프리고진은 러시아의 사설 군사 단체인 와그너의 창립자이자 리더다. 와그너는 현재 두 도시의 군사 시설을 통제하며, 모스크바를 향해 북진을 시작했다. 프리고진은 한때 푸틴의 가까운 측근이었으나, 푸틴은 TV 연설을 통해 “무장 반란”에 관여한 사람들에게 “처벌될 것”이라고 경고하고 있다.  </p><p>프리고진은 일반적으로 음지에서 활동하는 인물로 알려져 왔으며, 와그너는 작년 러시아의 우크라이나 전쟁 이후에 주목받게 되었다. 와그너 용병들은 여러 전투에서 중요한 역할을 수행했다. 푸틴과 프리고진은 1990년대부터 서로를 알고 있었다. 프리고진은 크렘린과 수익성이 높은 공급 계약을 체결하여 부유한 올리가르히로 성장하며 “푸틴의 요리사”라는 별명을 얻게 되었다. 프리고진은 2014년 동부 우크라이나 돈바스에서 러시아 지원 분리주의 운동 이후 우크라이나와 러시아 지원 사업을 수행하는 그림자 같은 용병 부대인 와그너를 창립했다.  </p><p>러시아가 2022년 우크라이나를 침공한 후에 와그너 그룹은 중앙 무대로 등장했다. 와그너 그룹은 우크라이나의 솔레다르와 바흐무트를 점령하는 데 큰 역할을 했다. 정규 러시아 군의 작전이 진행 장애와 무질서로 막혀가는 가운데 와그너 전투원들은 러시아 측에 현실적인 진전을 이뤄낼 수 있는 유일한 인물들로 보였다.  </p><p>프리고진은 최근 몇 달간 러시아의 군사 지도자들에 대한 공개 비판으로 푸틴에게 딜레마를 안겨주었다. 특히 5월 초 프리고진은 러시아 국방장관 세르게이 쇼이구와 러시아 군의장 벨레리 게라시모프를 특정 상대로 삼아 비판했다. 바흐무트 도시의 힘든 전투에서 크렘린으로부터 불충분한 지원을 받고 있다고 한 달 이상 불평한 후, 그는 5월에 자신의 부대가 철수할 것이라고 발표했다.  </p><p>이제 프리고진은 크렘린에 대한 전면 반란을 시작했다. 와그너의 반란은 프리고진이 지난 금요일 러시아 군에 대한 새로운 비난을 쏟아내고 그의 병력을 러시아 도시 로스토프온돈으로 행진시키면서 시작되었다. 몇 달간 잠재적인 내부 긴장의 갑작스러운 및 충격적인 고조에 직면한 푸틴은 와그너의 행동을 “배반”이라고 비난했다.  </p><p>서방 언론들에 의하면 프리고진의 무장반란이 그가 말하는 대로 군 지휘부를 처벌하는 등 성공할 가능성은 희박한 것으로 보고 있다. 하지만 우크라이나 전쟁이 장기화하면서 내부에서 불만과 균열이 생기고, 이는 푸틴 정권의 붕괴로 가는 길을 닦을 것이라고 서방에서는 전쟁 초부터 기대해왔다.  </p>]]></content>
    
    
    <categories>
      
      <category>INFO</category>
      
    </categories>
    
    
    <tags>
      
      <tag>프리고진</tag>
      
      <tag>와그너</tag>
      
      <tag>푸틴</tag>
      
      <tag>러시아</tag>
      
      <tag>전쟁</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>The Phoenix - Fall Out Boy [정보/가사/해석]</title>
    <link href="/music1/"/>
    <url>/music1/</url>
    
    <content type="html"><![CDATA[<h1 id="The-Phoenix-Fall-Out-Boy-곡-정보"><a href="#The-Phoenix-Fall-Out-Boy-곡-정보" class="headerlink" title="The Phoenix - Fall Out Boy 곡 정보"></a>The Phoenix - Fall Out Boy 곡 정보</h1><p>[SBS 골 때리는 그녀들]. [테라 광고], [MLB퍼펙트 이닝] 등에서도 나왔던 노래다.<br>노래 추천 #어떤 경기 전&#x2F;후로 나오는 노래 #운동할 때 #긴박한 상황 #전쟁 상황 #전투력 상승  </p><p><img src="/images/post/music1_1.jpg" alt="music1_1">  </p><p>앨범 : Save Rock And Roll<br>발매일 : 2013.04.12<br>장르 : 록&#x2F;메탈  </p><iframe src="https://www.youtube.com/embed/5JqY-6q-RNA" width="600" height="340" style="margin: 15px auto; display: block;"></iframe>  <h1 id="가사-x2F-해석"><a href="#가사-x2F-해석" class="headerlink" title="[가사&#x2F;해석]"></a>[가사&#x2F;해석]</h1><p>Put on your war paint<br>너의 위장크림을 칠해</p><p>You are a brick tied to me thats dragging me down<br>넌 나를 아래로 끌어내리는 벽돌같은 존재야</p><p>Strike a match and Ill burn you to the ground<br>성냥을 키고 난 널 불태워버릴 거야</p><p>We are the jack-o-lanterns in July<br>우리는 7월의 잭 오 랜턴이야</p><p>setting fire to the sky<br>하늘로 불타오르지</p><p>Here, here comes this rising tide<br>봐, 여기 밀물들이 몰려오고있어</p><p>So come on<br>그러니 덤벼</p><p>Put on your war paint<br>너의 위장크림을 칠해</p><p>Cross walks and crossed hearts and hope-to-dies<br>횡단보도를 건너고 성호를 그어 죽기를 바라며</p><p>Silver clouds with grey linings<br>은색의 구름과 그 사이의 햇빛</p><p>So we can take the world back from the heart-attacked<br>그러니 우리는 이 세계를 그 심장병 걸린 자들로부터 되찾아올 수 있어</p><p>One maniac at a time we will take it back<br>미친놈이라고 불렸었던 우리가 다시 되찾아가겠어</p><p>You know time crawls on when youre waiting for the song to start<br>넌 노래가 시작될때까지 시간이 느리게 흘러간다는 것을 알고 있잖아</p><p>So dance along to the beat of your heart<br>그러니 너의 심장의 비트를 따라 춤을 춰봐</p><p>Hey young blood<br>이봐 젊은 친구</p><p>Doesnt it feel like our time is running out<br>우리의 시간이 낭비되고있다는 생각이 들지는 않니</p><p>Im gonna change you like a remix<br>난 너를 리믹스처럼 바꿔버리고</p><p>Then Ill raise you like a phoenix<br>한 마리의 불사조처럼 솟구치게 할 거야</p><p>wearing our vintage misery<br>우리들의 빈티지한 불행을 입고있지만</p><p>No, I think it looked a little better on me<br>아냐, 내 생각에 그건 나한테 더 어울리는 것 같아</p><p>Im gonna change you like a remix<br>난 너를 리믹스처럼 바꿔주겠어</p><p>Then Ill raise you like a phoenix<br>그리고 한 마리의 불사조처럼 솟구치게 할 거야</p><p>Bring home the boys and scrap scrap metal the tanks<br>소년들을 집에 데려와서 탱크를 산산조각 내버리자</p><p>Get hitched make a career out of robbing banks<br>결혼하고 은행 터는것을 직업으로 삼아버려</p><p>Because the world is just a teller and<br>왜냐하면 세상은 그저 은행직원일 뿐이고</p><p>We are wearing black masks<br>우린 검은 마스크를 쓰고 있어</p><p>You broke our spirit says the note we pass<br>넌 우리의 영혼을 부셔놨어 우리가 남긴 글귀에 쓰여있는 말이지</p><p>So we can take the world back from the heart-attacked<br>그러니 우리는 이 세계를 그 심장병 걸린 자들로부터 되찾아올 수 있어</p><p>One maniac at a time we will take it back<br>미친놈이라고 불렸었던 우리가 다시 되찾아가겠어</p><p>You know time crawls on when youre waiting for the song to start<br>넌 노래가 시작될때까지 시간이 느리게 흘러간다는 것을 알고 있잖아</p><p>So dance along to the beat of your heart<br>그러니 너의 심장의 비트를 따라 춤을 춰봐</p><p>Hey young blood<br>이봐 젊은 친구</p><p>Doesnt it feel like our time is running out<br>우리의 시간이 낭비되고있다는 생각이 들지는 않니</p><p>Im gonna change you like a remix<br>난 너를 리믹스처럼 바꿔버리고</p><p>Then Ill raise you like a phoenix<br>한 마리의 불사조처럼 솟구치게 할 거야</p><p>wearing our vintage misery<br>우리들의 빈티지한 불행을 입고있지만</p><p>No, I think it looked a little better on me<br>아냐, 내 생각에 그건 나한테 더 어울리는 것 같아</p><p>Im gonna change you like a remix<br>난 너를 리믹스처럼 바꿔주겠어</p><p>Then Ill raise you like a phoenix<br>그리고 한 마리의 불사조처럼 솟구치게 할 거야</p><p>Put on your war paint<br>너의 위장크림을 칠해</p><p>The war is won<br>전쟁은 이겼어</p><p>Before its begun<br>시작도 하기 전에 말이지</p><p>Release the doves<br>비둘기를 풀어줘</p><p>Surrender love<br>항복하세요 사랑하는 당신이여</p><p>[x4]</p><p>Hey young blood<br>이봐 젊은 친구</p><p>Doesnt it feel like our time is running out<br>우리의 시간이 낭비되고있다는 생각이 들지는 않니</p><p>Im gonna change you like a remix<br>난 너를 리믹스처럼 바꿔버리고</p><p>Then Ill raise you like a phoenix<br>한 마리의 불사조처럼 솟구치게 할 거야</p><p>wearing our vintage misery<br>우리들의 빈티지한 불행을 입고있지만</p><p>No, I think it looked a little better on me<br>아냐, 내 생각에 그건 나한테 더 어울리는 것 같아</p><p>Im gonna change you like a remix<br>난 너를 리믹스처럼 바꿔주겠어</p><p>Then Ill raise you like a phoenix<br>그리고 한 마리의 불사조처럼 솟구치게 할 거야</p><p>Hey young blood<br>이봐 젊은 친구</p><p>Doesnt it feel like our time is running out<br>우리의 시간이 낭비되고있다는 생각이 들지는 않니</p><p>Im gonna change you like a remix<br>난 너를 리믹스처럼 바꿔버리고</p><p>Then Ill raise you like a phoenix<br>한 마리의 불사조처럼 솟구치게 할 거야</p><p>Put on your war paint<br>너의 위장크림을 칠해</p>]]></content>
    
    
    <categories>
      
      <category>MUSIC</category>
      
    </categories>
    
    
    <tags>
      
      <tag>음악</tag>
      
      <tag>노래</tag>
      
      <tag>추천</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>&#39;놀면 뭐하니?&#39;의 위기와 결방, 대체 프로그램 &#39;훅 까놓고 말해서&#39;</title>
    <link href="/info11/"/>
    <url>/info11/</url>
    
    <content type="html"><![CDATA[<h1 id="신봉선-정준하-박창훈-PD-하차"><a href="#신봉선-정준하-박창훈-PD-하차" class="headerlink" title="신봉선, 정준하, 박창훈 PD 하차"></a>신봉선, 정준하, 박창훈 PD 하차</h1><p>최근 ‘놀면 뭐하니?’가 위기에 처했다는 말이 많이 나오고 있었다. 가장 큰 문제는 뻔한 자기 복제와 시너지 부족이며, 김태호 PD가 떠나고부터 약점이 뚜렷해지고 시청률 하락세를 보이고 있다. 유재석의 역할과 선택에 따라 프로그램의 성패가 좌우될 것으로 예측되고 있다.  </p><p>그리고 최근 ‘놀면 뭐하니?’의 핵심 멤버로서 2년 동안 프로그램을 이끌어온 신봉선과 정준하는 하차하게되었다. 정준하와 신봉선은 오랜 기간 동안 프로그램에 출연하여 많은 인기를 얻었으나, 이제는 프로그램의 새로운 변화를 맞이하게 되었다.<br>메인 연출은 그동안 ‘놀면 뭐하니?’를 함께한 김진용, 장우성 PD가 맡는다.  </p><p><img src="/images/post/info11_1.png" alt="info11_1">  </p><h2 id="2주간-결방"><a href="#2주간-결방" class="headerlink" title="2주간 결방"></a>2주간 결방</h2><p>‘놀면 뭐하니?’는 새 단장을 예고하며 2주간의 재정비를 갖기로 결정했다. 유재석, 하하, 이미주, 박진주, 이이경이 남아있으며, 정준하와 신봉선은 하차하여 5인 체제로 이어갈 예정이다. 새로운 아이템과 프로젝트를 준비 중인 제작진은 기대를 모으고 있다.  </p><h2 id="훅-까놓고-말해서"><a href="#훅-까놓고-말해서" class="headerlink" title="훅 까놓고 말해서"></a>훅 까놓고 말해서</h2><p>이번 주 ‘놀면 뭐하니?’가 2주 동안 쉬어가는 동안 그 자리를 토크가 노래가 되는 음악 실험 프로젝트인 ‘훅 까놓고 말해서’라는 새 예능 파일럿 프로그램이 대체하게 되었다. 이 프로그램은 사람들의 평범한 이야기를 담은 훅(Hook) 한 마디를 찾아 노래로 만들어내는 윤종신, 이용진, 조현아의 음악실험 프로젝트다.  </p><p><img src="/images/post/info11_2.jpg" alt="info11_2">  </p><p>‘훅까말’과 함께할 지원자들이 등장하는데, 지원자 중 1호인 변호사 한문철은 리듬 있는 토크로 현장을 달아오르게 만들며 자신의 인생의 훅을 이야기한다. 2호 지원자인 배우 진선규는 예능 초짜이지만 살아 있는 인간 훅을 과시하여 시선을 강탈하며, 한문철과 진선규가 무심코 내뱉은 한 마디로 만든 음원 일부를 미리 공개하여 궁금증을 자아냈다. ‘훅 까놓고 말해서’는 음악 예능으로서의 차별점을 가지며, 귀에 훅 걸리는 한마디로 노래를 탄생시킨다. 최종 음원은 방송 다음 날에 공개되며, 첫 방송인 ‘훅 까놓고 말해서’ 1회에서는 음원으로 만들어진 무대가 최초로 공개된다.  </p>]]></content>
    
    
    <categories>
      
      <category>INFO</category>
      
    </categories>
    
    
    <tags>
      
      <tag>놀면 뭐하니</tag>
      
      <tag>훅 까놓고 말해서</tag>
      
      <tag>예능</tag>
      
      <tag>이슈</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>여름 장마철 품절대란! 레인부츠 정리</title>
    <link href="/info10/"/>
    <url>/info10/</url>
    
    <content type="html"><![CDATA[<h1 id="여름-장마철-기후-예보"><a href="#여름-장마철-기후-예보" class="headerlink" title="여름 장마철 기후 예보"></a>여름 장마철 기후 예보</h1><p>올여름 장마철은 엘니뇨 영향으로 인해 비가 많이 내릴 것으로 예상된다. 습도가 높아지며 열대야가 나타날 가능성이 있어 더위가 지속될 수 있다.  </p><p>마이크로소프트(MS)가 홈페이지를 통해 제공하는 월간 날씨 예보가 누리꾼들 사이에서 화제가 됐었다. 서울 기준으로 7월에는 28일, 8월에는 29일이나 ‘비’가 온다고 표시하면 서다. 두 달 내내 비만 내린다는 예보에 온라인상에서는 “이번 여름 역대 최악의 폭우가 내린다”며 장마 괴담이 퍼지기도 했다.  </p><p>기상청은 장마 기간 동안 비가 연이어 내릴 가능성은 낮지만 장기간 비가 온 경우도 종종 있었다고 밝혔다. 따라서 올여름 장마 기간 동안에는 특히 레인부츠가 필수적인 아이템이 될 것으로 예상된다.  </p><p><img src="/images/post/info10_1.png" alt="info10_1">  </p><h2 id="레인부츠의-패션-아이템으로의-부상"><a href="#레인부츠의-패션-아이템으로의-부상" class="headerlink" title="레인부츠의 패션 아이템으로의 부상"></a>레인부츠의 패션 아이템으로의 부상</h2><p>과거에는 레인부츠는 주로 기능성에 초점을 두고 디자인이 한정적이었다. 그러나 요즘에는 레인부츠가 패션 아이템으로 등극하여 다양한 스타일과 디자인으로 출시되고 있다. 이로 인해 많은 사람들이 레인부츠를 찾고 구매하고 있으며, 장마철이 다가오기 전에 미리 구매할 것을 권장한다.  </p><h2 id="레인부츠-구매처"><a href="#레인부츠-구매처" class="headerlink" title="레인부츠 구매처"></a>레인부츠 구매처</h2><p>레인부츠는 각 브랜드의 공식 홈페이지, 무신사, 크림, 29CM, 하이버 등에서 많이 구매할 수 있다. 또한 아소스(asos)와 같은 해외 직구 사이트도 많이 이용되고 있다. 만약 매장에 직접 방문하여 신어보거나 구매하고자 한다면 사이즈가 많이 없을 수 있으므로 전화로 사전 문의 후 방문하는 것을 추천한다.  </p><h2 id="레인부츠-종류-스타일-추천"><a href="#레인부츠-종류-스타일-추천" class="headerlink" title="레인부츠 종류(스타일) 추천"></a>레인부츠 종류(스타일) 추천</h2><p>남성 분들은 주로 미드 높이나 숏한 스타일의 레인부츠를 선호하고 구매하는 것으로 보인다. 한편, 여성 분들은 롱한 스타일의 레인부츠를 많이 선택하고 있다. 이는 개인의 스타일과 취향에 따라 다를 수 있으므로 참고하면 좋을 것이다.  </p><h2 id="브랜드별-특징과-사이즈"><a href="#브랜드별-특징과-사이즈" class="headerlink" title="브랜드별 특징과 사이즈"></a>브랜드별 특징과 사이즈</h2><h3 id="1-헌터-Hunter"><a href="#1-헌터-Hunter" class="headerlink" title="1.헌터 (Hunter)"></a>1.헌터 (Hunter)</h3><ul><li>클래식하고 깔끔한 디자인으로 유명한 브랜드다.  </li><li>약간 무겁다는 평이 있으나 많은 분들이 이미 구매하여 최근 길거리에도 많이 보인다.  </li><li>사이즈는 정사이즈부터 한 사이즈 업까지 선택하면 된다.</li></ul><p><img src="/images/post/info10_2.png" alt="info10_2">  </p><h3 id="2-문스타-Moonstar"><a href="#2-문스타-Moonstar" class="headerlink" title="2.문스타 (Moonstar)"></a>2.문스타 (Moonstar)</h3><ul><li>캐주얼, 스트릿 스타일을 선호하는 분들에게 적합한 브랜드다.  </li><li>헌터보다 조금 더 가볍고 착화감이 좋다는 평이 있다.  </li><li>숏 스타일의 제품이 예쁘다는 평이 많다.  </li><li>사이즈는 정사이즈를 선택하면 된다.</li></ul><p><img src="/images/post/info10_3.png" alt="info10_3">  </p><h3 id="3-바버-Barbour"><a href="#3-바버-Barbour" class="headerlink" title="3.바버 (Barbour)"></a>3.바버 (Barbour)</h3><ul><li>헌터와 마찬가지로 클래식하고 깔끔한 디자인이다.  </li><li>발볼 등에 따라 다를 수 있지만 보통 정사이즈를 선택하지만, 조금 크게 나왔다는 후기도 있다.  </li><li>헌터가 너무 흔해(또는 품절) 바버를 찾는 분들이 많다.</li></ul><p><img src="/images/post/info10_4.png" alt="info10_4">  </p><h3 id="4-락피쉬웨더웨어-Rockfish-Weatherwear"><a href="#4-락피쉬웨더웨어-Rockfish-Weatherwear" class="headerlink" title="4.락피쉬웨더웨어 (Rockfish Weatherwear)"></a>4.락피쉬웨더웨어 (Rockfish Weatherwear)</h3><ul><li>트렌디하고 패셔너블한 스타일의 레인부츠를 선호하는 분들에게 적합하다.  </li><li>사이즈는 정핏 아니면 조금 작게 선택하는 것이 좋다.  </li><li>Rockfish Weatherwear 한남점, 성수점에 방문하 구매하는 것도 좋다.</li></ul><p><img src="/images/post/info10_5.png" alt="info10_5">  </p><p>올여름 장마철에 비가 많이 온다는 예보로 인해 레인부츠가 품절대란에 빠진 상황이다. 레인부츠에 관심이 있다면, 장마철이 오기 전에 미리 구매하는 것을 권장한다. 다양한 브랜드와 디자인 중에서 자신에게 가장 어울리는 스타일을 선택하여 장마철을 대비하고 패션적으로도 즐기는 것을 추천한다.  </p>]]></content>
    
    
    <categories>
      
      <category>INFO</category>
      
    </categories>
    
    
    <tags>
      
      <tag>정보</tag>
      
      <tag>여름</tag>
      
      <tag>장마</tag>
      
      <tag>레인부츠</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>로즈힙 퓨레 효능과 해독 다이어트</title>
    <link href="/info9/"/>
    <url>/info9/</url>
    
    <content type="html"><![CDATA[<p>로즈힙 퓨레는 건강과 아름다움을 동시에 챙길 수 있는 효과적인 식물성 보조제다. 로즈힙 퓨레의 효능과 로즈힙 퓨레를 활용한 해독 다이어트 방법에 대해 알아본다.  </p><h1 id="로즈힙"><a href="#로즈힙" class="headerlink" title="로즈힙"></a>로즈힙</h1><p>로즈힙은 로즈힙 로즈의 열매에서 추출한 오일이나 퓨레로 사용되며, 피부 건강과 면역력 강화에 도움을 주는 다양한 영양소를 함유하고 있다. 이 열매는 비타민 C와 비타민 E와 같은 성분을 풍부하게 포함하고 있어 피부 미용에 도움을 주며, 체중 조절에도 도움을 줄 수 있는 폴리페놀 성분을 함유하고 있다. 또한, 로즈힙 추출물은 암 예방을 위해 폴리페놀과 카로티노이드 성분을 함유하고 있으며, 여성 건강 유지에 도움을 주는 비타민과 칼슘이 함유되어 있다.  </p><p>로즈힙은 여름철에 증가하는 만성 염증 질환을 줄이는 데도 도움이 될 수 있는 슈퍼푸드로 소개되고 있다. 여름은 체내 염증이 가장 취약한 시기로, 외부 환경에 노출되면 체내 염증이 증가하고 전신으로 퍼질 수 있다. 그러나 로즈힙을 활용한 해독 다이어트 방법을 통해 낮은 온도에서 운동하고 천연 식물성 재료를 사용한 항염식단을 적용하는 것은 염증을 완화시키고 독소를 줄이는 데 도움을 줄 수 있다.  </p><p><img src="/images/post/info9_1.png" alt="info9_1">  </p><h1 id="로즈힙-퓨레-해독-다이어트"><a href="#로즈힙-퓨레-해독-다이어트" class="headerlink" title="로즈힙 퓨레 해독 다이어트"></a>로즈힙 퓨레 해독 다이어트</h1><p>로즈힙 퓨레는 로즈힙의 열매를 가공하여 만든 제품으로 다양한 음식과 음료에 사용될 수 있다. 많은 사람들이 로즈힙 퓨레를 차에 넣어 향긋하고 상큼한 로즈 향을 즐기거나, 주스에 혼합하여 비타민 C를 보충하기도 한다. 면역력 강화, 소화 개선, 항산화 작용, 피부 개선 등의 이점을 제공할 수 있다. 그러나 개인의 건강 상태나 알레르기 반응에 따라 효과와 부작용이 다를 수 있으므로, 처음 사용하는 경우 적절한 양을 섭취하고 반응을 주시하는 것이 좋다.  </p><p>로즈힙 퓨레를 활용한 해독 다이어트는 체중 감량과 함께 만성통증과 염증성 질병을 극복하는 데 도움을 줄 수 있다. 이 다이어트를 통해 체중 감량과 함께 자신감과 건강이 회복될 수 있다. 로즈힙 퓨레는 다이어트에서 중요한 역할을 하며, 독소 배출, 체중 감량, 피부 탄력 향상에 도움이 된다.  </p><p>로즈힙 퓨레는 건강과 아름다움을 동시에 추구하는 사람들에게 이상적인 선택이다. 그러나 제품의 성분과 용도는 제조사나 제품에 따라 다를 수 있으므로, 로즈힙 퓨레를 구체적으로 어떻게 사용하고자 하는지에 따라 상세한 정보를 얻을 수 있을 것이다.  </p>]]></content>
    
    
    <categories>
      
      <category>INFO</category>
      
    </categories>
    
    
    <tags>
      
      <tag>정보</tag>
      
      <tag>로즈힙</tag>
      
      <tag>로즈힙 퓨레</tag>
      
      <tag>다이어트</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ChatGPT 효율 2배 필수 크롬 확장 프로그램</title>
    <link href="/info8/"/>
    <url>/info8/</url>
    
    <content type="html"><![CDATA[<h1 id="챗GPT-이용-시-도움이-되는-크롬-확장-프로그램-5가지"><a href="#챗GPT-이용-시-도움이-되는-크롬-확장-프로그램-5가지" class="headerlink" title="챗GPT 이용 시 도움이 되는 크롬 확장 프로그램 5가지"></a>챗GPT 이용 시 도움이 되는 크롬 확장 프로그램 5가지</h1><p>ChatGPT를 최대한 활용하고자 한다면, 필수적으로 설치해야 할 크롬 확장 프로그램들이 있다. ChatGPT와 함께 사용할 수 있는 다섯 가지 필수 크롬 확장 프로그램 5가지를 소개한다. 꼭 5가지 모두 사용해야 효율이 좋은 것이 아니라 본인에게 맞는 확장 프로그램만 설치하면 된다.  </p><p><img src="/images/post/info8_1.png" alt="info8_1">  </p><h3 id="1-AIPRM-for-ChatGPT"><a href="#1-AIPRM-for-ChatGPT" class="headerlink" title="1.AIPRM for ChatGPT"></a>1.AIPRM for ChatGPT</h3><p>AIPRM은 검색 엔진 최적화, 마케팅, 판매 및 고객 지원 등을 쉽고 빠르게 개선하고자 하는 분들에게 이상적인 확장 프로그램이다. 1,300,000명 이상의 사용자가 사용하고 있으며, 많은 무료 기능뿐만 아니라 “Favorites”, “Hidden”, 사용자 정의 목록, 사용자 정의 글쓰기, 스타일 등 많은 프리미엄 기능을 제공한다.  </p><h3 id="2-ChatGPT-for-Google"><a href="#2-ChatGPT-for-Google" class="headerlink" title="2.ChatGPT for Google"></a>2.ChatGPT for Google</h3><p>ChatGPT for Google은 Google, Bing, DuckDuckGo 등의 검색 엔진과 함께 작동하여 ChatGPT의 응답을 검색 결과와 함께 표시해 준다. 이 확장 프로그램을 사용하면 검색 결과를 받은 후 바로 ChatGPT와 대화를 시작할 수도 있다. 주요 기능으로는 모든 인기 있는 검색 엔진 지원, 쿼리와 답변에 대한 ChatGPT와의 채팅 기능, 공식 OpenAI API(GPT-3.5-Turbo 및 GPT-3) 지원, ChatGPT Plus 및 GPT-4 지원 등이 있다.  </p><h3 id="3-YouTube-amp-Article-Summary-powered-by-ChatGPT"><a href="#3-YouTube-amp-Article-Summary-powered-by-ChatGPT" class="headerlink" title="3.YouTube &amp; Article Summary powered by ChatGPT"></a>3.YouTube &amp; Article Summary powered by ChatGPT</h3><p>YouTube &amp; Article Summary powered by ChatGPT는 ChatGPT를 활용하여 YouTube 동영상과 웹 기사의 요약을 제공해주는 크롬 확장 프로그램이다. 이 확장 프로그램을 사용하면 YouTube 동영상을 시청하거나 웹 기사를 읽을 때 요약 내용을 빠르게 확인할 수 있다. 또한, YouTube에서 동영상을 둘러보는 동안 요약 버튼을 클릭하여 쉽게 요약 내용을 확인할 수도 있다.  </p><h3 id="4-프롬프트-지니-ChatGPT-자동-번역기"><a href="#4-프롬프트-지니-ChatGPT-자동-번역기" class="headerlink" title="4.프롬프트 지니: ChatGPT 자동 번역기"></a>4.프롬프트 지니: ChatGPT 자동 번역기</h3><p>프롬프트 지니는 ChatGPT 사용 시 질문을 영어로 번역하여 답변을 한글로 번역해 주는 번역기이다. ChatGPT를 한글로 질문하면 응답이 느리고 짧으며, 이전 대화 내용을 빨리 잊어버리는 문제가 있다. 프롬프트 지니를 사용하면 한글로 질문하면서도 ChatGPT의 성능을 최대한으로 활용할 수 있다. 프롬프트 지니의 장점으로는 2<del>3배 빠른 응답 속도, 2</del>5배 긴 문자 수 출력, 출력 중간에 일어나는 짤림 최소화, ChatGPT가 3~4배 더 긴 대화를 기억할 수 있는 등이 있다.  </p><h3 id="5-WebChatGPT-인터넷-액세스가-가능한-ChatGPT"><a href="#5-WebChatGPT-인터넷-액세스가-가능한-ChatGPT" class="headerlink" title="5.WebChatGPT: 인터넷 액세스가 가능한 ChatGPT"></a>5.WebChatGPT: 인터넷 액세스가 가능한 ChatGPT</h3><p>WebChatGPT는 웹 브라우징을 통해 ChatGPT 프롬프트를 강화하는 크롬 확장 프로그램이다. 이 확장 프로그램은 관련 웹 결과를 ChatGPT 프롬프트에 추가하여 더 정확한 대화를 가능하게 해 준다. 주요 기능으로는 검색어에 대한 웹 결과 얻기, 모든 URL에서 웹페이지 텍스트 추출, 프롬프트 템플릿 추가 및 사용 등이 있다. WebChatGPT는 ChatGPT Plus 사용자에게 제공되는 웹 브라우징 기능과 유사하지만, 보다 가볍고 빠르며 모든 ChatGPT 사용자에게 무료로 제공된다.  </p><p>이 다섯 가지 필수 크롬 확장 프로그램을 사용하면 ChatGPT를 더욱 효과적으로 활용할 수 있다. 각각의 확장 프로그램은 고유한 기능을 제공하여 웹 검색, 번역, 요약 등 다양한 작업을 보다 쉽고 빠르게 수행할 수 있게 해준다.  </p>]]></content>
    
    
    <categories>
      
      <category>INFO</category>
      
    </categories>
    
    
    <tags>
      
      <tag>정보</tag>
      
      <tag>ChatGPT</tag>
      
      <tag>효율</tag>
      
      <tag>크롬</tag>
      
      <tag>확장 프로그램</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2023 FIFA U-20 월드컵 토너먼트 대진</title>
    <link href="/info7/"/>
    <url>/info7/</url>
    
    <content type="html"><![CDATA[<h1 id="대한민국-2023-FIFA-U-20-월드컵-16강-진출-확정"><a href="#대한민국-2023-FIFA-U-20-월드컵-16강-진출-확정" class="headerlink" title="대한민국 2023 FIFA U-20 월드컵 16강 진출 확정!"></a>대한민국 2023 FIFA U-20 월드컵 16강 진출 확정!</h1><p>한국 축구는 국제축구연맹(FIFA) U-20 월드컵에서 3회 연속으로 16강에 진출했다. 이번 대회에서는 조 3위까지도 상위 4개 팀에 포함될 수 있는 기회가 주어져서, 한국이 조 3위로 선전해도 16강 진출이 보장되었다.  </p><p>일본은 한국 시간 기준으로 28일에 아르헨티나 멘도사 스타디움에서 열린 2023 FIFA U-20 월드컵 C조의 3차전에서 1-2로 역전 패배했다. 이로써 일본은 승점 3(1승 2패)으로 조 3위에 밀렸다.  </p><p>따라서, 한국은 16강 진출을 확정했다. 조별리그 최종전에서 감비아와 비기면서 조 2위로 16강에 올랐다.  </p><p>F조 2위가 된 한국은 오는 6월2일 오전 6시 산티아고 델 에스테로 스타디움에서 B조 2위 에콰도르와 16강전을 치른다.  </p><p><img src="/images/post/info7_1.png" alt="info7_1">  </p><h3 id="2023-U-20-FIFA-월드컵-16강-토너먼트-대진"><a href="#2023-U-20-FIFA-월드컵-16강-토너먼트-대진" class="headerlink" title="2023 U-20 FIFA 월드컵 16강 토너먼트 대진"></a>2023 U-20 FIFA 월드컵 16강 토너먼트 대진</h3><p>한국의 상대는 에콰도르다. 한국과 에콰도르는 6월 2일 오전 6시 아르헨티나 산티아고 델 에스테로에 위치한 에스타디오 우니코 마드레 데 시우다데스에서 맞붙는다. 8강 진출에 성공한다면 아르헨티나와 나이지리아 맞대결 승자와 격돌한다.  </p><p><img src="/images/post/info7_2.png" alt="info7_2">  </p>]]></content>
    
    
    <categories>
      
      <category>INFO</category>
      
    </categories>
    
    
    <tags>
      
      <tag>정보</tag>
      
      <tag>이슈</tag>
      
      <tag>월드컵</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>동물보호법 개정 펫티켓 내용 요약</title>
    <link href="/info5/"/>
    <url>/info5/</url>
    
    <content type="html"><![CDATA[<h1 id="동물보호법-개정"><a href="#동물보호법-개정" class="headerlink" title="동물보호법 개정"></a>동물보호법 개정</h1><p>2023년 4월 27일, 동물보호법이 전면 개정 및 시행되었으며 반려인의 동물 관리 의무와 준수사항이 강화된 바 있다.<br>이와 관련하여 서울시는 5월부터 반려인 준수사항을 집중 홍보하기 시작하며 펫티켓 준수를 권고하고 있다.  </p><h3 id="펫티켓"><a href="#펫티켓" class="headerlink" title="펫티켓"></a>펫티켓</h3><p>펫티켓(Pettiquette)은 반려동물(Pet)과 예절(Etiquette)의 합성어로 반려동물을 공공장소에 동반하거나 타인의 반려동물을 마주쳤을 때 갖춰야 할 예절을 말한다.  </p><p>그러면 이번 동물보호법이 개정되면서 지켜야 할 내용은 어떤 것들이 있는지 요약해 보았다.  </p><h3 id="목줄-또는-가슴줄-하네스-사용"><a href="#목줄-또는-가슴줄-하네스-사용" class="headerlink" title="목줄 또는 가슴줄(하네스) 사용"></a>목줄 또는 가슴줄(하네스) 사용</h3><p>개를 외출할 때에는 2m 이내의 목줄 또는 가슴줄을 사용해야 한다.<br>건물 내부 공용공간이나 복도에서는 개를 안거나, 목줄의 목덜미 또는 가슴줄의 손잡이를 잡아서 이동을 제한해야 한다.  </p><h3 id="인식표-부착"><a href="#인식표-부착" class="headerlink" title="인식표 부착"></a>인식표 부착</h3><p>외출 시 인식표를 반드시 부착해야 한다. 부착하지 않을 경우 50만 원 이하의 과태료가 부과된다.<br>인식표에는 개의 이름, 소유자 연락처, 동물등록번호가 기재되어야 한다.  </p><p><img src="/images/post/info5_1.png" alt="info5_1">  </p><p>또한, 개정안 이외에도 다음과 같은 펫티켓을 준수해야 한다.  </p><h3 id="반려견-배설물-수거"><a href="#반려견-배설물-수거" class="headerlink" title="반려견 배설물 수거"></a>반려견 배설물 수거</h3><p>공동주택의 엘리베이터, 계단 등 공용공간 및 사람이 눕거나 앉을 수 있는 기구 위의 배설물은 특히 수거해야 한다.  위반 시 50만 원 이하의 과태료가 부과된다.  </p><h3 id="반려동물을-안은-상태에서-운전금지"><a href="#반려동물을-안은-상태에서-운전금지" class="headerlink" title="반려동물을 안은 상태에서 운전금지"></a>반려동물을 안은 상태에서 운전금지</h3><p>안전운전을 위해 반려동물을 안은 상태로 운전해서는 안 된다. 이를 위반하면 20만 원 이하의 벌금이나 구류 또는 과료에 처할 수 있으며, 차량 유형에 따라 범칙금도 부과된다.  </p><h3 id="반려동물-유기-금지"><a href="#반려동물-유기-금지" class="headerlink" title="반려동물 유기 금지"></a>반려동물 유기 금지</h3><p>반려동물을 버리면 300만 원 이하의 벌금이 부과된다. 특히 맹견을 버리면 2년 이하의 징역 또는 2천만 원 이하의 벌금이 부과된다.  </p><p>위의 내용들은 동물보호법 개정안에 포함된 내용 및 평상시에 지켜야 할 기본적인 내용들로, 이를 준수하여 동물의 복지와 안전을 보호하는데 기여할 수 있다.  </p>]]></content>
    
    
    <categories>
      
      <category>INFO</category>
      
    </categories>
    
    
    <tags>
      
      <tag>정보</tag>
      
      <tag>이슈</tag>
      
      <tag>동물보호법</tag>
      
      <tag>펫티켓</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>애플 iOS 16.5 업데이트 - 신규 기능, 수정 사항</title>
    <link href="/info6/"/>
    <url>/info6/</url>
    
    <content type="html"><![CDATA[<h1 id="iOS-16-5-업데이트-출시"><a href="#iOS-16-5-업데이트-출시" class="headerlink" title="iOS 16.5 업데이트 출시"></a>iOS 16.5 업데이트 출시</h1><p>애플은 최신 iOS 16.5 업데이트를 출시했다. 이번 업데이트에서는 새로운 기능과 몇 가지 문제들이 수정되었다.<br>아래는 업데이트의 주요 내용이다.  </p><p>최근 출시된 일본의 ‘아사히 수퍼드라이 생맥주’가 대란급 인기를 끌면서, 이제는 어디에서 구매할 수 있는지가 중요한 이슈가 되고 있다. 이 맥주를 파는 곳으로는 코스트코, 이마트, 롯데마트, GS, CU 등이 있다.  </p><p><img src="/images/post/info6_1.png" alt="info6_1">  </p><h3 id="1-새로운-프라이드-셀레브레이션-배경화면-추가"><a href="#1-새로운-프라이드-셀레브레이션-배경화면-추가" class="headerlink" title="1.새로운 프라이드 셀레브레이션 배경화면 추가"></a>1.새로운 프라이드 셀레브레이션 배경화면 추가</h3><ul><li>LGBTQ+ 공동체와 문화를 기리기 위해, 잠금 화면용으로 새로운 프라이드 셀레브레이션 배경화면이 추가되었다.</li></ul><h3 id="2-애플-뉴스앱-관련"><a href="#2-애플-뉴스앱-관련" class="headerlink" title="2.애플 뉴스앱 관련"></a>2.애플 뉴스앱 관련</h3><ul><li>스포츠 탭이 새롭게 추가되었다. 하지만 현재는 한국에서는 이 기능을 지원하지 않으며, 해외 사용자들만 이용할 수 있다.</li></ul><h3 id="3-카플레이-CarPlay-에서-팟캐스트-콘텐츠-로딩-문제-수정"><a href="#3-카플레이-CarPlay-에서-팟캐스트-콘텐츠-로딩-문제-수정" class="headerlink" title="3.카플레이(CarPlay)에서 팟캐스트 콘텐츠 로딩 문제 수정"></a>3.카플레이(CarPlay)에서 팟캐스트 콘텐츠 로딩 문제 수정</h3><ul><li>카플레이를 사용할 때 팟캐스트가 콘텐츠를 로드하지 않는 문제가 수정되었다.</li></ul><h3 id="4-Spotlight-응답-문제-수정"><a href="#4-Spotlight-응답-문제-수정" class="headerlink" title="4.Spotlight 응답 문제 수정"></a>4.Spotlight 응답 문제 수정</h3><ul><li>이전에 발생했던 Spotlight가 응답하지 않는 문제가 이번 업데이트에서 수정되었다.</li></ul><h3 id="5-스크린-타임-설정-문제-수정"><a href="#5-스크린-타임-설정-문제-수정" class="headerlink" title="5.스크린 타임 설정 문제 수정"></a>5.스크린 타임 설정 문제 수정</h3><ul><li>스크린 타임 설정이 재설정되거나 동기화되지 않는 문제가 수정되었다.</li></ul><p>업데이트를 설치하려면 아이폰의 설정으로 이동한 후, “일반”을 선택한 다음 “소프트웨어 업데이트”를 탭하여 최신 업데이트를 확인하고 설치할 수 있다.  </p><p>iOS 16.5 업데이트를 통해 더 나은 사용자 경험을 누리시기 바랍니다.  </p>]]></content>
    
    
    <categories>
      
      <category>INFO</category>
      
    </categories>
    
    
    <tags>
      
      <tag>정보</tag>
      
      <tag>애플</tag>
      
      <tag>iOS</tag>
      
      <tag>업데이트</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>체크박스 디자인-2 (checkbox Design-2 with CSS)</title>
    <link href="/uiux6/"/>
    <url>/uiux6/</url>
    
    <content type="html"><![CDATA[<h1 id="체크박스-디자인-2-checkbox-Design-2-with-CSS"><a href="#체크박스-디자인-2-checkbox-Design-2-with-CSS" class="headerlink" title="체크박스 디자인-2 (checkbox Design-2 with CSS)"></a>체크박스 디자인-2 (checkbox Design-2 with CSS)</h1><p>기본 체크박스로 활용할 수 있다.  </p><iframe src="https://rudtn082.github.io/UI/checkbox2/checkbox2.html" width="900" height="160" style="margin: 15px auto; display: block;"></iframe><p>✔️ HTML  </p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs angelscript">&lt;div <span class="hljs-keyword">class</span>=&quot;<span class="hljs-symbol">cbxBox</span>&quot;&gt;<br>    &lt;<span class="hljs-symbol">label</span> <span class="hljs-symbol">class</span>=&quot;<span class="hljs-symbol">box</span>&quot;&gt;<br>        &lt;<span class="hljs-symbol">input</span> <span class="hljs-symbol">type</span>=&quot;<span class="hljs-symbol">checkbox</span>&quot; <span class="hljs-symbol">checked</span>=&quot;&quot;&gt;<br>        &lt;<span class="hljs-symbol">span</span>&gt;&lt;/<span class="hljs-symbol">span</span>&gt;<br>    &lt;/<span class="hljs-symbol">label</span>&gt;<br>&lt;/<span class="hljs-symbol">div</span>&gt;<br></code></pre></td></tr></table></figure><p>✔️ CSS  </p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.cbxBox</span> &#123;<br>    <span class="hljs-attribute">position</span>: relative;<br>    <span class="hljs-attribute">left</span>: <span class="hljs-number">50%</span>;<br>&#125;<br><span class="hljs-selector-class">.box</span> &#123;<br>    <span class="hljs-attribute">display</span>: flex;<br>    <span class="hljs-attribute">align-items</span>: center;<br>&#125;<br><span class="hljs-selector-class">.box</span> <span class="hljs-selector-tag">input</span><span class="hljs-selector-attr">[type=<span class="hljs-string">&quot;checkbox&quot;</span>]</span> &#123;<br>    <span class="hljs-attribute">position</span>: relative;<br>    <span class="hljs-attribute">height</span>: <span class="hljs-number">35px</span>;<br>    <span class="hljs-attribute">width</span>: <span class="hljs-number">35px</span>;<br>    appearance: none;<br>    <span class="hljs-attribute">background-color</span>: <span class="hljs-number">#FFF</span>;<br>    <span class="hljs-attribute">border-radius</span>: <span class="hljs-number">10px</span>;<br>    <span class="hljs-attribute">cursor</span>: pointer;<br>    <span class="hljs-attribute">overflow</span>: hidden;<br>&#125;<br><span class="hljs-selector-class">.box</span> <span class="hljs-selector-tag">input</span><span class="hljs-selector-attr">[type=<span class="hljs-string">&quot;checkbox&quot;</span>]</span><span class="hljs-selector-pseudo">::after</span> &#123;<br>    <span class="hljs-attribute">content</span>: <span class="hljs-string">&#x27;&#x27;</span>;<br>    <span class="hljs-attribute">display</span>: block;<br>    <span class="hljs-attribute">height</span>: <span class="hljs-number">15px</span>;<br>    <span class="hljs-attribute">width</span>: <span class="hljs-number">8px</span>;<br>    <span class="hljs-attribute">border-bottom</span>: <span class="hljs-number">4px</span> solid <span class="hljs-number">#e1f5fe</span>;<br>    <span class="hljs-attribute">border-right</span>: <span class="hljs-number">4px</span> solid <span class="hljs-number">#e1f5fe</span>;<br>    <span class="hljs-attribute">opacity</span>: <span class="hljs-number">0</span>;<br>    <span class="hljs-attribute">transform</span>: <span class="hljs-built_in">rotate</span>(<span class="hljs-number">45deg</span>) <span class="hljs-built_in">translate</span>(-<span class="hljs-number">50%</span>, -<span class="hljs-number">50%</span>);<br>    <span class="hljs-attribute">position</span>: absolute;<br>    <span class="hljs-attribute">top</span>: <span class="hljs-number">45%</span>;<br>    <span class="hljs-attribute">left</span>: <span class="hljs-number">25%</span>;<br>    <span class="hljs-attribute">transition</span>: all .<span class="hljs-number">25s</span> <span class="hljs-built_in">cubic-bezier</span>(<span class="hljs-number">0.075</span>, <span class="hljs-number">0.82</span>, <span class="hljs-number">0.165</span>, <span class="hljs-number">1</span>);<br>&#125;<br><span class="hljs-selector-class">.box</span> <span class="hljs-selector-tag">input</span><span class="hljs-selector-attr">[type=<span class="hljs-string">&quot;checkbox&quot;</span>]</span><span class="hljs-selector-pseudo">::before</span> &#123;<br>    <span class="hljs-attribute">position</span>: absolute;<br>    <span class="hljs-attribute">display</span>: block;<br>    <span class="hljs-attribute">content</span>: <span class="hljs-string">&#x27;&#x27;</span>;<br>    <span class="hljs-attribute">height</span>: <span class="hljs-number">0</span>;<br>    <span class="hljs-attribute">width</span>: <span class="hljs-number">0</span>;<br>    <span class="hljs-attribute">background-color</span>: <span class="hljs-number">#01579b</span>;<br>    <span class="hljs-attribute">border-radius</span>: <span class="hljs-number">50%</span>;<br>    <span class="hljs-attribute">opacity</span>: .<span class="hljs-number">5</span>;<br>    <span class="hljs-attribute">transform</span>: <span class="hljs-built_in">translate</span>(-<span class="hljs-number">50%</span>, -<span class="hljs-number">50%</span>);<br>    <span class="hljs-attribute">top</span>: <span class="hljs-number">50%</span>;<br>    <span class="hljs-attribute">left</span>: <span class="hljs-number">50%</span>;<br>    <span class="hljs-attribute">transition</span>: all .<span class="hljs-number">5s</span> <span class="hljs-built_in">cubic-bezier</span>(<span class="hljs-number">0.075</span>, <span class="hljs-number">0.82</span>, <span class="hljs-number">0.165</span>, <span class="hljs-number">1</span>);<br>&#125;<br><span class="hljs-selector-class">.box</span> <span class="hljs-selector-tag">input</span><span class="hljs-selector-attr">[type=<span class="hljs-string">&quot;checkbox&quot;</span>]</span><span class="hljs-selector-pseudo">:checked</span><span class="hljs-selector-pseudo">::before</span> &#123;<br>    <span class="hljs-attribute">height</span>: <span class="hljs-number">120%</span>;<br>    <span class="hljs-attribute">width</span>: <span class="hljs-number">120%</span>;<br>    <span class="hljs-attribute">opacity</span>: <span class="hljs-number">100%</span>;<br>&#125;<br><span class="hljs-selector-class">.box</span> <span class="hljs-selector-tag">input</span><span class="hljs-selector-attr">[type=<span class="hljs-string">&quot;checkbox&quot;</span>]</span><span class="hljs-selector-pseudo">:checked</span><span class="hljs-selector-pseudo">::after</span> &#123;<br>    <span class="hljs-attribute">opacity</span>: <span class="hljs-number">100%</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>✔️ GitHub<br><a href="https://github.com/rudtn082/UI/tree/main/checkbox2" title="GitHub">링크</a>  </p>]]></content>
    
    
    <categories>
      
      <category>UI_UX</category>
      
    </categories>
    
    
    <tags>
      
      <tag>디자인</tag>
      
      <tag>CSS</tag>
      
      <tag>체크박스</tag>
      
      <tag>checkbox</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2분기 전기요금 인상 가구별 요금계산</title>
    <link href="/info4/"/>
    <url>/info4/</url>
    
    <content type="html"><![CDATA[<h1 id="전기-및-가스요금-인상"><a href="#전기-및-가스요금-인상" class="headerlink" title="전기 및 가스요금 인상"></a>전기 및 가스요금 인상</h1><p>16일부터 전기와 가스요금이 인상될 예정입니다. 특히 전기요금은 1㎾h당 8원씩 인상되며, 예를 들어 4인 가구의 월 평균 전력 사용량이 332㎾h라고 할 때, 월 전기요금은 약 3000원 정도 증가할 것으로 예상됩니다.  </p><p><img src="/images/post/info4_1.png" alt="info4_1">  </p><h3 id="정부와-공사의-대응"><a href="#정부와-공사의-대응" class="headerlink" title="정부와 공사의 대응"></a>정부와 공사의 대응</h3><p>한국전력공사와 한국가스공사는 전기요금 인상에 대한 자구책을 발표했으나, 정부는 이러한 노력만으로는 위기를 극복하기 어렵다고 강조하고 있습니다. 이창양 산업통상자원부 장관은 “에너지 공급의 지속 가능성을 확보하고, 한전과 가스공사의 경영을 정상화하기 위해서는 일정 부분 전기·가스요금의 추가 조정이 불가피하다”고 말했습니다.  </p><h3 id="가구별-인상-요금계산"><a href="#가구별-인상-요금계산" class="headerlink" title="가구별 인상 요금계산"></a>가구별 인상 요금계산</h3><p>에너지총조사 보고서 기준 1인 ~ 4인가구의 월평균 전기사용량을 토대로 인상요금을 계산해보았습니다.<br>청구금액은 아래와 같이 전기요금 + 부가가치세 + 전력산업기반기금을 더한 값에 10원미만은 절사되고 있습니다.  </p><table style="border-collapse: collapse; width: 900px; margin: 10px auto; overflow: auto;" border="1" data-ke-align="alignLeft" data-ke-style="style5"><tbody><tr style="height: 20px;"><td style="width: 8.60465%; height: 30px; text-align: center; background: #2a77eb; color: #fff;" rowspan="2"><b>구</b><b>분</b></td><td style="width: 11.744%; height: 30px; text-align: center; background: #2a77eb; color: #fff;" rowspan="2"><b>월평균</b><br /><b>전기사용량</b></td><td style="width: 35.1163%; height: 20px; text-align: center; background: #2a77eb; color: #fff;" colspan="4"><b>인상 전</b></td><td style="height: 20px; width: 34.6803%; text-align: center; background: #2a77eb; color: #fff;" colspan="4"><b>인상 후</b></td><td style="width: 42.6745%; text-align: center; height: 30px; background: #2a77eb; color: #fff;" rowspan="2"><b>인상금액</b></td></tr><tr style="height: 10px;"><td style="width: 9.04073%; height: 10px; text-align: center; background: #2a77eb; color: #fff;"><b>전기요금</b></td><td style="width: 7.64537%; height: 10px; text-align: center; background: #2a77eb; color: #fff;"><b>부가</b><br /><b>가치세</b><br /><b>(10%)</b></td><td style="width: 9.38953%; height: 10px; text-align: center; background: #2a77eb; color: #fff;"><b>전력산업</b><br /><b>기반기금</b><br /><b>(3.7%)</b></td><td style="width: 9.04072%; height: 10px; text-align: center; background: #2a77eb; color: #fff;"><b>청구금액</b></td><td style="width: 9.15695%; height: 10px; text-align: center; background: #2a77eb; color: #fff;"><b>전기요금</b></td><td style="width: 7.25301%; height: 10px; text-align: center; background: #2a77eb; color: #fff;"><b>부가</b><br /><b>가치세</b><br /><b>(10%)</b></td><td style="width: 9.11337%; height: 10px; text-align: center; background: #2a77eb; color: #fff;"><b>전력산업</b><br /><b>기반기금</b><br /><b>(3.7%)</b></td><td style="width: 9.157%; height: 10px; text-align: center; background: #2a77eb; color: #fff;"><b>청구금액</b></td></tr><tr style="height: 20px;"><td style="width: 8.60465%; height: 20px; text-align: center;">1인가구</td><td style="width: 11.744%; height: 20px; text-align: center;">230 kWh</td><td style="width: 9.04073%; height: 20px; text-align: right;">33,418</td><td style="width: 7.64537%; height: 20px; text-align: right;">3,342</td><td style="width: 9.38953%; height: 20px; text-align: right;">1,230</td><td style="width: 9.04072%; height: 20px; text-align: right;"><b><span style="color: #006dd7;">37,990</span></b></td><td style="width: 9.15695%; height: 20px; text-align: right;">35,258</td><td style="width: 7.25301%; height: 20px; text-align: right;">3,526</td><td style="width: 9.11337%; height: 20px; text-align: right;">1,300</td><td style="width: 9.157%; height: 20px; text-align: right;"><b><span style="color: #006dd7;">40,080</span></b></td><td style="width: 42.6745%; height: 20px; text-align: right;"><span style="color: #ee2323;"><b>🔼 2,090</b></span></td></tr><tr style="height: 20px;"><td style="width: 8.60465%; height: 20px; text-align: center;">2인가구</td><td style="width: 11.744%; height: 20px; text-align: center;">289 <span style="background-color: #f9f9f9; color: #333333; text-align: center;">kWh</span></td><td style="width: 9.04073%; height: 20px; text-align: right;">46,433</td><td style="width: 7.64537%; height: 20px; text-align: right;">4,643</td><td style="width: 9.38953%; height: 20px; text-align: right;">1,710</td><td style="width: 9.04072%; height: 20px; text-align: right;"><b><span style="color: #006dd7;">52,780</span></b></td><td style="width: 9.15695%; height: 20px; text-align: right;">48,745</td><td style="width: 7.25301%; height: 20px; text-align: right;">4,875</td><td style="width: 9.11337%; height: 20px; text-align: right;">1,800</td><td style="width: 9.157%; height: 20px; text-align: right;"><b><span style="color: #006dd7;">55,420</span></b></td><td style="width: 42.6745%; height: 20px; text-align: right;"><span style="color: #ee2323;"><b><span style="background-color: #f9f9f9; text-align: right;">🔼&nbsp;</span>2,640</b></span></td></tr><tr style="height: 20px;"><td style="width: 8.60465%; height: 20px; text-align: center;">3인가구</td><td style="width: 11.744%; height: 20px; text-align: center;">298 <span style="background-color: #f9f9f9; color: #333333; text-align: center;">kWh</span></td><td style="width: 9.04073%; height: 20px; text-align: right;">48,418</td><td style="width: 7.64537%; height: 20px; text-align: right;">4,842</td><td style="width: 9.38953%; height: 20px; text-align: right;">1,790</td><td style="width: 9.04072%; height: 20px; text-align: right;"><b><span style="color: #006dd7;">55,050</span></b></td><td style="width: 9.15695%; height: 20px; text-align: right;">50,802</td><td style="width: 7.25301%; height: 20px; text-align: right;">5,080</td><td style="width: 9.11337%; height: 20px; text-align: right;">1,870</td><td style="width: 9.157%; height: 20px; text-align: right;"><b><span style="color: #006dd7;">57,750</span></b></td><td style="width: 42.6745%; height: 20px; text-align: right;"><span style="color: #ee2323;"><b><span style="background-color: #f9f9f9; text-align: right;">🔼&nbsp;</span>2,700</b></span></td></tr><tr style="height: 20px;"><td style="width: 8.60465%; height: 20px; text-align: center;">4인가구</td><td style="width: 11.744%; height: 20px; text-align: center;">332 <span style="background-color: #f9f9f9; color: #333333; text-align: center;">kWh</span></td><td style="width: 9.04073%; height: 20px; text-align: right;">55,919</td><td style="width: 7.64537%; height: 20px; text-align: right;">5,592</td><td style="width: 9.38953%; height: 20px; text-align: right;">2,060</td><td style="width: 9.04072%; height: 20px; text-align: right;"><b><span style="color: #006dd7;">63,570</span></b></td><td style="width: 9.15695%; height: 20px; text-align: right;">58,575</td><td style="width: 7.25301%; height: 20px; text-align: right;">5,858</td><td style="width: 9.11337%; height: 20px; text-align: right;">2,160</td><td style="width: 9.157%; height: 20px; text-align: right;"><b><span style="color: #006dd7;">66,590</span></b></td><td style="width: 42.6745%; height: 20px; text-align: right;"><span style="color: #ee2323;"><b><span style="background-color: #f9f9f9; text-align: right;">🔼&nbsp;</span>3,020</b></span></td></tr></tbody></table><p>인상 후 전기요금을 직접 계산해보았는데 인상금액은 월 2~3천원정도 인상될 것으로 보입니다.</p><h3 id="에너지캐시백-제도"><a href="#에너지캐시백-제도" class="headerlink" title="에너지캐시백 제도"></a>에너지캐시백 제도</h3><p>높아지는 전기요금에 따라 일반 가구도 에너지캐시백 제도를 확대 적용해 지원을 늘리기로 하고 있습니다.  </p><p>직전 2개년 동월 평균 전력 사용량 대비 5% 이상 절감한 경우, 추가로 30원에서 70원까지 인센티브를 지급하여 최대 1㎾h당 100원까지 전기요금에서 차감될 수 있도록 할 예정입니다. 이를 통해 가정의 전기사용량 절감을 장려하고 에너지 효율화를 촉진할 계획이라고하니, 에너지캐시백 제도를 잘 활용할 수 있도록 해야겠습니다.  </p>]]></content>
    
    
    <categories>
      
      <category>INFO</category>
      
    </categories>
    
    
    <tags>
      
      <tag>정보</tag>
      
      <tag>전기요금</tag>
      
      <tag>인상</tag>
      
      <tag>계산</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>AP 알케미 콘서트 무료 전환</title>
    <link href="/info3/"/>
    <url>/info3/</url>
    
    <content type="html"><![CDATA[<h1 id="AP-알케미"><a href="#AP-알케미" class="headerlink" title="AP 알케미"></a>AP 알케미</h1><p>AP 알케미는 스윙스가 설립한 Just Music, Indigo Music, WEDAPLUGG RECORDS, Mine Field, Sugar Beats를 하나의 회사로 합병하고 AP Alchemy라는 이름을 붙인 것이다. AP Alchemy는 엘리트 고등학생이 대학 수업을 미리 듣고 점수를 딸 수 있게 하는 제도인 Advanced Placement와 연금술을 뜻하는 Alchemy의 합성어로 ‘금(좋은 것)을 만들기 위해 모인 특수(엘리트) 집단’이라는 뜻을 담았다.  </p><h1 id="AP-알케미-컴필레이션-콘서트-인-서울"><a href="#AP-알케미-컴필레이션-콘서트-인-서울" class="headerlink" title="AP 알케미 컴필레이션 콘서트 인 서울"></a>AP 알케미 컴필레이션 콘서트 인 서울</h1><p>스윙스는 자신이 설립한 레이블 ‘AP 알케미’의 단독 콘서트인 ‘AP 알케미 컴필레이션 콘서트 인 서울’을 개최할 예정입니다. 이 공연은 6월 3일에 서울 성북구 고려대학교 화정체육관에서 열릴 예정이다.  </p><p>이 공연은 5개 레이블의 합동 콘서트로 기대감이 크게 쏠렸으나, 판매된 좌석은 총 5000석 중 1000석도 되지 않았다.  이에 스윙스는 “나의 불찰”이라고 하며, 기존에 9만9000원에 판매된 콘서트 티켓을 모두 무료로 진행하기로 밝혔다.  </p><p>스윙스는 이미 예매한 관객들에게는 환불과 지정석 확보를 약속했으며, 신청 방법은 추후에 공지할 예정이다. 그리고 개인 인스타그램을 통해 “내년에는 우리의 가치를 끌어올려 똑같은 자리에서 유료로 공연을 하고 싶다”라고 말하며, 내년까지 가치를 끌어올리겠다고 강조했다.  </p><p>이 공연에는 스윙스, 기리보이, 키드밀리, 양홍원, 한요한, 윤훼이, 릴타치, 다민이, 칠린 호미 등 유명 래퍼들이 대거 참여할 예정으로, 무료로 진행된다는 소식으로 많은 관객들이 기대하고 있다.  </p><p><img src="/images/post/info3_1.jpg" alt="info3_1"> </p>]]></content>
    
    
    <categories>
      
      <category>INFO</category>
      
    </categories>
    
    
    <tags>
      
      <tag>정보</tag>
      
      <tag>AP 알케미</tag>
      
      <tag>콘서트</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SKT, 100% 당첨 세계 화폐 랜덤 뽑기 이벤트 링크</title>
    <link href="/info2/"/>
    <url>/info2/</url>
    
    <content type="html"><![CDATA[<h1 id="100-당첨-세계-화폐-랜덤-뽑기-이벤트"><a href="#100-당첨-세계-화폐-랜덤-뽑기-이벤트" class="headerlink" title="100% 당첨 세계 화폐 랜덤 뽑기 이벤트"></a>100% 당첨 세계 화폐 랜덤 뽑기 이벤트</h1><p>SK텔레콤은 내달에 ‘0 청년 요금제’를 공식 출시하는 것을 앞두고, 사전 알림 참여 선착순 30만 명을 대상으로 ‘100% 당첨 세계 화폐 랜덤 뽑기’ 이벤트를 진행합니다. 이 이벤트는 만 34세 이하 신청자 중 선착순 30만명에게 세계 화폐 10종을 무작위로 지급하고 있습니다.  </p><p>이벤트에 참여하기 위해서는 T월드·T멤버십 배너를 통해 이벤트 페이지에 접속하고 만 34세 이하임을 인증한 후 사전 알림 신청을 하면 됩니다.  </p><p>이번 이벤트는 ‘룰렛’ 방식으로 진행되며, 이벤트 화면에서 ‘Start’ 버튼을 누르면 세계 화폐 10종류 중 하나와 숫자 10, 20, 30 중 하나가 결정됩니다. 지급되는 화폐는 미국 달러화, EU 유로화, 일본 엔화, 인도 루피화, 홍콩 달러화, 멕시코 페소화, 남아공 랜드화, 체코 코루나화, 태국 바트화, 아랍에미레이트 디르함화 등 10종류입니다.  </p><p>당첨된 금액은 네이버 환율 기준으로 환산되어 내달 1일에 네이버페이 포인트 쿠폰 형태로 지급됩니다.  </p><p><img src="/images/post/info2_1.png" alt="info2_1"> </p><h2 id="이벤트-링크"><a href="#이벤트-링크" class="headerlink" title="이벤트 링크"></a>이벤트 링크</h2><p><a href="https://skt0-event.co.kr/comingsoon#/">링크</a>  </p>]]></content>
    
    
    <categories>
      
      <category>INFO</category>
      
    </categories>
    
    
    <tags>
      
      <tag>정보</tag>
      
      <tag>SKT</tag>
      
      <tag>이벤트</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>아사히 생맥주 캔 파는 곳 (편의점, 코스트코, 트레이더 등)</title>
    <link href="/info1/"/>
    <url>/info1/</url>
    
    <content type="html"><![CDATA[<h1 id="아사히-수퍼드라이-생맥주-캔-파는-곳"><a href="#아사히-수퍼드라이-생맥주-캔-파는-곳" class="headerlink" title="아사히 수퍼드라이 생맥주 캔 파는 곳"></a>아사히 수퍼드라이 생맥주 캔 파는 곳</h1><p>최근 출시된 일본의 ‘아사히 수퍼드라이 생맥주’가 대란급 인기를 끌면서, 이제는 어디에서 구매할 수 있는지가 중요한 이슈가 되고 있다. 이 맥주를 파는 곳으로는 코스트코, 이마트, 롯데마트, GS, CU 등이 있다.  </p><p><img src="/images/post/info1_1.jpg" alt="info1_1">  </p><p>코스트코는 예상을 뛰어넘는 수요로 인해 판매 초기에는 아이디 당 세 박스까지만 구매 가능하도록 제한했지만, 이후 두 박스로 기준을 낮추면서도 빠르게 소진됐다. 이후 편의점에서도 판매가 시작되면서 더욱 수요가 증가했다. GS25, CU, 세븐일레븐, 이마트24 등 편의점에서는 5월 1일부터 판매를 시작했으며 초도 물량은 모두 소진됐다.  </p><p>이마트 창고형 할인마트인 트레이더스에서도 5월 4일부터 판매가 시작되었으며, 1인당 1박스(24개)까지 구매할 수 있다. 향후에는 21개 점포에서 판매가 예정되어 있다.  </p><p>홈플러스에서는 약 20개점에서 판매되었으며, 입고 즉시 완판되었다. 4일부터는 1인당 1박스(24개) 구매 제한이 시행되고 있으며, 10일까지는 홈플러스 마트 80개점에서 4캔 기준 1만원에 판매된다.  </p><p>롯데마트에서는 한 캔에 3000원인 제품을 17일까지 4캔 구매 시 1만400원에 판매하고 있다. 구매 제한은 따로 없다.  </p><p>‘아사히 수퍼드라이 생맥주캔’이 국내에서 유통 중인 모든 아사히 캔맥주 제품은 후쿠오카의 하카타 공장에서 만들어졌다고 하니, 후쿠시마산이라는 커뮤니티 루머는 사실이 아니라고 한다. 따라서, 이 제품을 마시고 걱정할 필요는 없을 것이다.  </p>]]></content>
    
    
    <categories>
      
      <category>INFO</category>
      
    </categories>
    
    
    <tags>
      
      <tag>아사히 생맥주</tag>
      
      <tag>정보</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>체크박스 디자인-1 (checkbox Design-1 with CSS)</title>
    <link href="/uiux5/"/>
    <url>/uiux5/</url>
    
    <content type="html"><![CDATA[<h1 id="체크박스-디자인-1-checkbox-Design-1-with-CSS"><a href="#체크박스-디자인-1-checkbox-Design-1-with-CSS" class="headerlink" title="체크박스 디자인-1 (checkbox Design-1 with CSS)"></a>체크박스 디자인-1 (checkbox Design-1 with CSS)</h1><p>기본 체크박스로 활용할 수 있다.   </p><iframe src="https://rudtn082.github.io/UI/checkbox1/checkbox1.html" width="900" height="160" style="margin: 15px auto; display: block;"></iframe><p>✔️ HTML  </p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs angelscript">&lt;div <span class="hljs-keyword">class</span>=&quot;<span class="hljs-symbol">cbxBox</span>&quot;&gt;<br>    &lt;<span class="hljs-symbol">input</span> <span class="hljs-symbol">checked</span>=&quot;&quot; <span class="hljs-symbol">type</span>=&quot;<span class="hljs-symbol">checkbox</span>&quot; <span class="hljs-symbol">id</span>=&quot;<span class="hljs-symbol">cb1</span>&quot;&gt;<br>    &lt;<span class="hljs-symbol">label</span> <span class="hljs-symbol">for</span>=&quot;<span class="hljs-symbol">cb1</span>&quot; <span class="hljs-symbol">class</span>=&quot;<span class="hljs-symbol">cbx</span>&quot;&gt;&lt;/<span class="hljs-symbol">label</span>&gt;<br>&lt;/<span class="hljs-symbol">div</span>&gt;<br></code></pre></td></tr></table></figure><p>✔️ CSS  </p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.cbxBox</span> &#123;<br>    <span class="hljs-attribute">position</span>: relative;<br>&#125;<br><span class="hljs-selector-class">.cbxBox</span> <span class="hljs-selector-class">.cbx</span> &#123;<br>    <span class="hljs-attribute">position</span>: relative;<br>    <span class="hljs-attribute">display</span>: block;<br>    <span class="hljs-attribute">width</span>: <span class="hljs-number">25px</span>;<br>    <span class="hljs-attribute">height</span>: <span class="hljs-number">25px</span>;<br>    <span class="hljs-attribute">border</span>: <span class="hljs-number">1px</span> solid <span class="hljs-number">#a1a1a1</span>;<br>    <span class="hljs-attribute">border-radius</span>: <span class="hljs-number">5px</span>;<br>    <span class="hljs-attribute">cursor</span>: pointer;<br>    <span class="hljs-attribute">transition</span>: all <span class="hljs-number">0.3s</span> ease;<br>&#125;<br><span class="hljs-selector-class">.cbxBox</span> <span class="hljs-selector-class">.cbx</span><span class="hljs-selector-pseudo">:after</span> &#123;<br>    <span class="hljs-attribute">content</span>: <span class="hljs-string">&#x27;&#x27;</span>;<br>    <span class="hljs-attribute">position</span>: absolute;<br>    <span class="hljs-attribute">top</span>: <span class="hljs-number">2px</span>;<br>    <span class="hljs-attribute">left</span>: <span class="hljs-number">10px</span>;<br>    <span class="hljs-attribute">width</span>: <span class="hljs-number">5px</span>;<br>    <span class="hljs-attribute">height</span>: <span class="hljs-number">14px</span>;<br>    <span class="hljs-attribute">opacity</span>: <span class="hljs-number">0</span>;<br>    <span class="hljs-attribute">transform</span>: <span class="hljs-built_in">rotate</span>(<span class="hljs-number">45deg</span>) <span class="hljs-built_in">scale</span>(<span class="hljs-number">0</span>);<br>    <span class="hljs-attribute">border-right</span>: <span class="hljs-number">2px</span> solid <span class="hljs-number">#fff</span>;<br>    <span class="hljs-attribute">border-bottom</span>: <span class="hljs-number">2px</span> solid <span class="hljs-number">#fff</span>;<br>    <span class="hljs-attribute">transition</span>: all <span class="hljs-number">0.3s</span> ease;<br>&#125;<br><span class="hljs-selector-class">.cbxBox</span> <span class="hljs-selector-tag">input</span><span class="hljs-selector-attr">[type=checkbox]</span> &#123;<br>    <span class="hljs-attribute">display</span>: none <span class="hljs-meta">!important</span>;<br>&#125;<br><span class="hljs-selector-class">.cbxBox</span> <span class="hljs-selector-tag">input</span><span class="hljs-selector-attr">[type=checkbox]</span><span class="hljs-selector-pseudo">:checked</span> ~ <span class="hljs-selector-class">.cbx</span> &#123;<br>    <span class="hljs-attribute">border-color</span>: transparent;<br>    <span class="hljs-attribute">background</span>: <span class="hljs-number">#392ca7</span>;<br>    <span class="hljs-attribute">animation</span>: anima <span class="hljs-number">0.6s</span> ease;<br>&#125;<br><span class="hljs-selector-class">.cbxBox</span> <span class="hljs-selector-tag">input</span><span class="hljs-selector-attr">[type=checkbox]</span><span class="hljs-selector-pseudo">:checked</span> ~ <span class="hljs-selector-class">.cbx</span><span class="hljs-selector-pseudo">:after</span> &#123;<br>    <span class="hljs-attribute">opacity</span>: <span class="hljs-number">1</span>;<br>    <span class="hljs-attribute">transform</span>: <span class="hljs-built_in">rotate</span>(<span class="hljs-number">45deg</span>) <span class="hljs-built_in">scale</span>(<span class="hljs-number">1</span>);<br>&#125;<br><span class="hljs-keyword">@keyframes</span> anima &#123;<br>    <span class="hljs-selector-tag">from</span> &#123;<br>        <span class="hljs-attribute">transform</span>: <span class="hljs-built_in">scale</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-number">25%</span> &#123;<br>        <span class="hljs-attribute">transform</span>: <span class="hljs-built_in">scale</span>(<span class="hljs-number">0.95</span>, <span class="hljs-number">0.95</span>);<br>    &#125;<br>    <span class="hljs-number">50%</span> &#123;<br>        <span class="hljs-attribute">transform</span>: <span class="hljs-built_in">scale</span>(<span class="hljs-number">1.15</span>, <span class="hljs-number">1.15</span>);<br>    &#125;<br>    <span class="hljs-number">75%</span> &#123;<br>        <span class="hljs-attribute">transform</span>: <span class="hljs-built_in">scale</span>(<span class="hljs-number">0.95</span>, <span class="hljs-number">0.95</span>);<br>    &#125;<br>    <span class="hljs-selector-tag">to</span> &#123;<br>        <span class="hljs-attribute">transform</span>: <span class="hljs-built_in">scale</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>✔️ GitHub<br><a href="https://github.com/rudtn082/UI/tree/main/checkbox1" title="GitHub">링크</a>  </p>]]></content>
    
    
    <categories>
      
      <category>UI_UX</category>
      
    </categories>
    
    
    <tags>
      
      <tag>디자인</tag>
      
      <tag>CSS</tag>
      
      <tag>체크박스</tag>
      
      <tag>checkbox</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>알림 디자인-1 (notification Design-1 with CSS)</title>
    <link href="/uiux3/"/>
    <url>/uiux3/</url>
    
    <content type="html"><![CDATA[<h1 id="알림-디자인-1-notification-Design-1-with-CSS"><a href="#알림-디자인-1-notification-Design-1-with-CSS" class="headerlink" title="알림 디자인-1 (notification Design-1 with CSS)"></a>알림 디자인-1 (notification Design-1 with CSS)</h1><p>알림 창을 띄워 다른화면으로 이동시키는 용도로 활용할 수 있다.  </p><iframe src="https://rudtn082.github.io/UI/notification1/notification1.html" width="900" height="160" style="margin: 15px auto; display: block;"></iframe><p>✔️ HTML  </p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs gradle">&lt;<span class="hljs-keyword">div</span> <span class="hljs-keyword">class</span>=<span class="hljs-string">&quot;notification&quot;</span>&gt;<br>    &lt;span <span class="hljs-keyword">class</span>=<span class="hljs-string">&quot;material-icons-outlined icon&quot;</span>&gt;info&lt;/span&gt;<br>    &lt;<span class="hljs-keyword">div</span> <span class="hljs-keyword">class</span>=<span class="hljs-string">&quot;messages&quot;</span>&gt;<br>        &lt;<span class="hljs-keyword">div</span> <span class="hljs-keyword">class</span>=<span class="hljs-string">&quot;title&quot;</span>&gt;Info&lt;/<span class="hljs-keyword">div</span>&gt;<br>        &lt;<span class="hljs-keyword">div</span> <span class="hljs-keyword">class</span>=<span class="hljs-string">&quot;sub&quot;</span>&gt;Add your info message here.&lt;/<span class="hljs-keyword">div</span>&gt;<br>    &lt;/<span class="hljs-keyword">div</span>&gt;<br>    &lt;a <span class="hljs-keyword">class</span>=<span class="hljs-string">&quot;button&quot;</span> href=<span class="hljs-string">&quot;javascript:;&quot;</span>&gt;<span class="hljs-keyword">Next</span>&lt;/a&gt;<br>&lt;/<span class="hljs-keyword">div</span>&gt;<br></code></pre></td></tr></table></figure><p>✔️ CSS  </p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.notification</span> &#123;<br>    <span class="hljs-attribute">display</span>: inline-flex;<br>    <span class="hljs-attribute">padding</span>: <span class="hljs-number">10px</span> <span class="hljs-number">20px</span>;<br>    <span class="hljs-attribute">background</span>: <span class="hljs-number">#fff</span>;<br>    <span class="hljs-attribute">border-radius</span>: <span class="hljs-number">10px</span>;<br>    <span class="hljs-attribute">justify-content</span>: space-between;<br>    <span class="hljs-attribute">color</span>: <span class="hljs-number">#212121</span>;<br>    <span class="hljs-attribute">gap</span>: <span class="hljs-number">15px</span>;<br>    <span class="hljs-attribute">box-shadow</span>: <span class="hljs-number">0px</span> <span class="hljs-number">10px</span> <span class="hljs-number">20px</span> <span class="hljs-number">13px</span> <span class="hljs-built_in">rgba</span>(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0.1</span>);<br>    <span class="hljs-attribute">animation</span>: scale .<span class="hljs-number">5s</span> linear alternate-reverse infinite;<br>    <span class="hljs-attribute">text-align</span>: left;<br>&#125;<br><span class="hljs-keyword">@keyframes</span> scale &#123;<br>    <span class="hljs-selector-tag">from</span> &#123;<br>        <span class="hljs-attribute">transform</span>: <span class="hljs-built_in">scale</span>(<span class="hljs-number">0.98</span>);<br>    &#125;<br><br>    <span class="hljs-selector-tag">to</span> &#123;<br>        <span class="hljs-attribute">transform</span>: <span class="hljs-built_in">scale</span>(<span class="hljs-number">1</span>);<br>    &#125;<br>&#125;<br><span class="hljs-selector-class">.notification</span> <span class="hljs-selector-class">.icon</span> &#123;<br>    <span class="hljs-attribute">font-size</span>: <span class="hljs-number">40px</span>;<br>    <span class="hljs-attribute">line-height</span>: <span class="hljs-number">65px</span>;<br>    <span class="hljs-attribute">color</span>: <span class="hljs-number">#303f9f</span>;<br>&#125;<br><span class="hljs-selector-class">.notification</span> <span class="hljs-selector-class">.messages</span> &#123;<br>    <span class="hljs-attribute">display</span>: inline-flex;<br>    <span class="hljs-attribute">flex-direction</span>: column;<br>    <span class="hljs-attribute">justify-content</span>: center;<br>&#125;<br><span class="hljs-selector-class">.notification</span> <span class="hljs-selector-class">.messages</span> <span class="hljs-selector-class">.title</span> &#123;<br>    <span class="hljs-attribute">font-size</span>: <span class="hljs-number">16px</span>;<br>    <span class="hljs-attribute">font-family</span>: <span class="hljs-string">&#x27;NotoSansKR-Medium&#x27;</span>;<br>    <span class="hljs-attribute">text-transform</span>: uppercase;<br>    <span class="hljs-attribute">color</span>: <span class="hljs-number">#494949</span>;<br>&#125;<br><span class="hljs-selector-class">.notification</span> <span class="hljs-selector-class">.messages</span> <span class="hljs-selector-class">.sub</span> &#123;<br>    <span class="hljs-attribute">font-size</span>: <span class="hljs-number">13px</span>;<br>&#125;<br><span class="hljs-selector-class">.notification</span> <span class="hljs-selector-class">.button</span> &#123;<br>    <span class="hljs-attribute">line-height</span>: <span class="hljs-number">65px</span>;<br>    <span class="hljs-attribute">padding</span>: <span class="hljs-number">0px</span> <span class="hljs-number">15px</span>;<br>    <span class="hljs-attribute">font-size</span>: <span class="hljs-number">15px</span>;<br>    <span class="hljs-attribute">text-align</span>: center;<br>    <span class="hljs-attribute">background-color</span>: <span class="hljs-number">#303f9f</span>;<br>    <span class="hljs-attribute">color</span>: <span class="hljs-number">#ffffff</span>;<br>    <span class="hljs-attribute">text-transform</span>: uppercase;<br>    <span class="hljs-attribute">border-radius</span>: <span class="hljs-number">10px</span>;<br>    <span class="hljs-attribute">text-decoration</span>: none;<br>&#125;<br><span class="hljs-selector-class">.notification</span> <span class="hljs-selector-class">.button</span><span class="hljs-selector-pseudo">:hover</span> &#123;<br>    <span class="hljs-attribute">background-color</span>: <span class="hljs-number">#1a237e</span>;<br>    <span class="hljs-attribute">font-family</span>: <span class="hljs-string">&#x27;NotoSansKR-Medium&#x27;</span>;<br>&#125;<br><span class="hljs-keyword">@media</span> all <span class="hljs-keyword">and</span> (<span class="hljs-attribute">max-width</span>: <span class="hljs-number">350px</span>) &#123;<br>    <span class="hljs-selector-class">.notification</span> <span class="hljs-selector-class">.messages</span> <span class="hljs-selector-class">.sub</span> &#123;<br>        <span class="hljs-attribute">display</span>: none;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>✔️ GitHub<br><a href="https://github.com/rudtn082/UI/tree/main/notification1" title="GitHub">링크</a>  </p>]]></content>
    
    
    <categories>
      
      <category>UI_UX</category>
      
    </categories>
    
    
    <tags>
      
      <tag>디자인</tag>
      
      <tag>CSS</tag>
      
      <tag>알림</tag>
      
      <tag>notification</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>스위치 디자인-1 (Switch Design-1 with CSS)</title>
    <link href="/uiux4/"/>
    <url>/uiux4/</url>
    
    <content type="html"><![CDATA[<h1 id="스위치-디자인-1-Switch-Design-1-with-CSS"><a href="#스위치-디자인-1-Switch-Design-1-with-CSS" class="headerlink" title="스위치 디자인-1 (Switch Design-1 with CSS)"></a>스위치 디자인-1 (Switch Design-1 with CSS)</h1><p>기본 스위치로 활용할 수 있다.  </p><iframe src="https://rudtn082.github.io/UI/switch1/switch1.html" width="900" height="160" style="margin: 15px auto; display: block;"></iframe><p>✔️ HTML  </p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs angelscript">&lt;label <span class="hljs-keyword">class</span>=&quot;<span class="hljs-symbol">switch1</span>&quot;&gt;<br>    &lt;<span class="hljs-symbol">input</span> <span class="hljs-symbol">type</span>=&quot;<span class="hljs-symbol">checkbox</span>&quot;&gt;<br>    &lt;<span class="hljs-symbol">span</span> <span class="hljs-symbol">class</span>=&quot;<span class="hljs-symbol">slider</span>&quot;&gt;&lt;/<span class="hljs-symbol">span</span>&gt;<br>&lt;/<span class="hljs-symbol">label</span>&gt;<br></code></pre></td></tr></table></figure><p>✔️ CSS  </p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.switch1</span> &#123;<br>    <span class="hljs-attribute">position</span>: relative;<br>    <span class="hljs-attribute">display</span>: inline-block;<br>    <span class="hljs-attribute">font-size</span>: <span class="hljs-number">15px</span>;<br>    <span class="hljs-attribute">width</span>: <span class="hljs-number">60px</span>;<br>    <span class="hljs-attribute">height</span>: <span class="hljs-number">30px</span>;<br>&#125;<br><span class="hljs-selector-class">.switch1</span> <span class="hljs-selector-class">.slider</span> &#123;<br>    <span class="hljs-attribute">position</span>: absolute;<br>    <span class="hljs-attribute">cursor</span>: pointer;<br>    <span class="hljs-attribute">top</span>: <span class="hljs-number">0</span>;<br>    <span class="hljs-attribute">left</span>: <span class="hljs-number">0</span>;<br>    <span class="hljs-attribute">right</span>: <span class="hljs-number">0</span>;<br>    <span class="hljs-attribute">bottom</span>: <span class="hljs-number">0</span>;<br>    <span class="hljs-attribute">background-color</span>: <span class="hljs-number">#fff</span>;<br>    <span class="hljs-attribute">border-radius</span>: <span class="hljs-number">20px</span>;<br>    <span class="hljs-attribute">border</span>: <span class="hljs-number">1px</span> solid <span class="hljs-number">#ccc</span>;<br>    <span class="hljs-attribute">transition</span>: all .<span class="hljs-number">4s</span> ease-in-out;<br>&#125;<br><span class="hljs-selector-class">.switch1</span> <span class="hljs-selector-class">.slider</span><span class="hljs-selector-pseudo">:before</span> &#123;<br>    <span class="hljs-attribute">position</span>: absolute;<br>    <span class="hljs-attribute">content</span>: <span class="hljs-string">&quot;&quot;</span>;<br>    <span class="hljs-attribute">height</span>: <span class="hljs-number">20px</span>;<br>    <span class="hljs-attribute">width</span>: <span class="hljs-number">20px</span>;<br>    <span class="hljs-attribute">border-radius</span>: <span class="hljs-number">50%</span>;<br>    <span class="hljs-attribute">left</span>: <span class="hljs-number">5px</span>;<br>    <span class="hljs-attribute">bottom</span>: <span class="hljs-number">4px</span>;<br>    <span class="hljs-attribute">background-color</span>: <span class="hljs-number">#adb5bd</span>;<br>    <span class="hljs-attribute">transition</span>: all .<span class="hljs-number">4s</span> ease-in-out;<br>&#125;<br><span class="hljs-selector-tag">input</span><span class="hljs-selector-pseudo">:checked</span> ~ <span class="hljs-selector-class">.slider</span> &#123;<br>    <span class="hljs-attribute">background-color</span>: <span class="hljs-number">#1976d2</span>;<br>    <span class="hljs-attribute">border</span>: <span class="hljs-number">1px</span> solid <span class="hljs-number">#1976d2</span>;<br>&#125;<br><span class="hljs-selector-tag">input</span><span class="hljs-selector-pseudo">:checked</span> ~ <span class="hljs-selector-class">.slider</span><span class="hljs-selector-pseudo">:before</span> &#123;<br>    <span class="hljs-attribute">transform</span>: <span class="hljs-built_in">translate</span>(<span class="hljs-number">27px</span>, <span class="hljs-number">0px</span>);<br>    <span class="hljs-attribute">background-color</span>: <span class="hljs-number">#fff</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>✔️ GitHub<br><a href="https://github.com/rudtn082/UI/tree/main/switch1" title="GitHub">링크</a>  </p>]]></content>
    
    
    <categories>
      
      <category>UI_UX</category>
      
    </categories>
    
    
    <tags>
      
      <tag>디자인</tag>
      
      <tag>CSS</tag>
      
      <tag>스위치</tag>
      
      <tag>switch</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>버튼 디자인-2 (button Design-2 with CSS)</title>
    <link href="/uiux2/"/>
    <url>/uiux2/</url>
    
    <content type="html"><![CDATA[<h1 id="버튼-디자인-2-button-Design-2-with-CSS"><a href="#버튼-디자인-2-button-Design-2-with-CSS" class="headerlink" title="버튼 디자인-2 (button Design-2 with CSS)"></a>버튼 디자인-2 (button Design-2 with CSS)</h1><p>좋아요 버튼 등으로 활용할 수 있는 버튼이다.  </p><iframe src="https://rudtn082.github.io/UI/button2/button2.html" width="900" height="160" style="margin: 15px auto; display: block;"></iframe><p>✔️ HTML  </p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;like&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;material-icons-outlined before&quot;</span>&gt;</span>favorite_border<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;material-icons-outlined after&quot;</span>&gt;</span>favorite<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;text&quot;</span>&gt;</span>Like<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br></code></pre></td></tr></table></figure><p>✔️ CSS  </p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.like</span> &#123;<br>    <span class="hljs-attribute">display</span>: flex;<br>    <span class="hljs-attribute">gap</span>: <span class="hljs-number">10px</span>;<br>    <span class="hljs-attribute">justify-content</span>: space-between;<br>    <span class="hljs-attribute">align-items</span>: center;<br>    <span class="hljs-attribute">padding</span>: <span class="hljs-number">15px</span>;<br>    <span class="hljs-attribute">background-color</span>: <span class="hljs-number">#fc8989</span>;<br>    <span class="hljs-attribute">border-radius</span>: <span class="hljs-number">35px</span>;<br>    <span class="hljs-attribute">border</span>: <span class="hljs-number">0px</span>;<br>    <span class="hljs-attribute">font-size</span>: <span class="hljs-number">25px</span>;<br>    <span class="hljs-attribute">margin</span>: <span class="hljs-number">0</span> auto;<br>    <span class="hljs-attribute">color</span>: <span class="hljs-number">#fff</span>;<br>    <span class="hljs-attribute">cursor</span>: pointer;<br>    <span class="hljs-attribute">transition</span>: all .<span class="hljs-number">5s</span>;<br>&#125;<br><span class="hljs-selector-class">.like</span><span class="hljs-selector-pseudo">:hover</span> &#123;<br>    <span class="hljs-attribute">background-color</span>: <span class="hljs-number">#ff6e6e</span>;<br>&#125;<br><span class="hljs-selector-class">.like</span><span class="hljs-selector-pseudo">:hover</span> <span class="hljs-selector-class">.before</span> &#123;<br>    <span class="hljs-attribute">opacity</span>: <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-selector-class">.like</span> <span class="hljs-selector-class">.after</span> &#123;<br>    <span class="hljs-attribute">position</span>: absolute;<br>    <span class="hljs-attribute">opacity</span>: <span class="hljs-number">0</span>;<br>    <span class="hljs-attribute">color</span>: <span class="hljs-number">#fff</span>;<br>&#125;<br><span class="hljs-selector-class">.like</span><span class="hljs-selector-pseudo">:hover</span> <span class="hljs-selector-class">.after</span> &#123;<br>    <span class="hljs-attribute">opacity</span>: <span class="hljs-number">1</span>;<br>    <span class="hljs-attribute">animation</span>: beat <span class="hljs-number">1s</span> infinite;<br>&#125;<br><span class="hljs-keyword">@keyframes</span> beat &#123;<br>    <span class="hljs-number">0%</span> &#123;<br>        <span class="hljs-attribute">transform</span>: <span class="hljs-built_in">scale</span>(<span class="hljs-number">1</span>);<br>    &#125;<br><br>    <span class="hljs-number">15%</span> &#123;<br>        <span class="hljs-attribute">transform</span>: <span class="hljs-built_in">scale</span>(<span class="hljs-number">1.15</span>);<br>    &#125;<br><br>    <span class="hljs-number">30%</span> &#123;<br>        <span class="hljs-attribute">transform</span>: <span class="hljs-built_in">scale</span>(<span class="hljs-number">1</span>);<br>    &#125;<br><br>    <span class="hljs-number">45%</span> &#123;<br>        <span class="hljs-attribute">transform</span>: <span class="hljs-built_in">scale</span>(<span class="hljs-number">1.15</span>);<br>    &#125;<br><br>    <span class="hljs-number">60%</span> &#123;<br>        <span class="hljs-attribute">transform</span>: <span class="hljs-built_in">scale</span>(<span class="hljs-number">1</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>✔️ GitHub<br><a href="https://github.com/rudtn082/UI/tree/main/button2" title="GitHub">링크</a>  </p>]]></content>
    
    
    <categories>
      
      <category>UI_UX</category>
      
    </categories>
    
    
    <tags>
      
      <tag>버튼</tag>
      
      <tag>디자인</tag>
      
      <tag>CSS</tag>
      
      <tag>button</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>다이소 딸기 키우기 (D+21)</title>
    <link href="/daily1/"/>
    <url>/daily1/</url>
    
    <content type="html"><![CDATA[<h1 id="다이소-딸기-키우기-D-21"><a href="#다이소-딸기-키우기-D-21" class="headerlink" title="다이소 딸기 키우기 (D+21)"></a>다이소 딸기 키우기 (D+21)</h1><p>3주 전에 다이소 구경 중<br>딸기를 키울 수 있는 종이화분을 발견했다.</p><p>단돈 천 원 ㅋㅋ</p><p><img src="/images/post/daily1_1.jpg" alt="daily1_1"></p><p>진짜 키울 수 있나? 호기심에 사봤다.<br>2주 동안 계속 물을 줘도 새싹이 자라지 않아서<br>너무 추웠나? 흙을 잘 안 덮었나? 등등의 생각이 들었다.</p><p>그런데 3주정도 되니까 새싹이 자라는 게 보였다!<br>바로 (또) 다이소에 가서 작은 화분 2개를 사서 분갈이를 해줬다.</p><p><img src="/images/post/daily1_2.png" alt="daily1_2"></p><p><img src="/images/post/daily1_3.png" alt="daily1_3"></p><p>내 작은 방에서 얼마나 키울 수 있을지 궁금하다.</p>]]></content>
    
    
    <categories>
      
      <category>daily</category>
      
    </categories>
    
    
    <tags>
      
      <tag>다이소</tag>
      
      <tag>딸기</tag>
      
      <tag>식물</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>버튼 디자인-1 (button Design-1 with CSS)</title>
    <link href="/uiux1/"/>
    <url>/uiux1/</url>
    
    <content type="html"><![CDATA[<h1 id="버튼-디자인-1-button-Design-1-with-CSS"><a href="#버튼-디자인-1-button-Design-1-with-CSS" class="headerlink" title="버튼 디자인-1 (button Design-1 with CSS)"></a>버튼 디자인-1 (button Design-1 with CSS)</h1><p>여러개의 버튼이 같은 레벨에 있어야할 때 사용할 수 있다.  </p><iframe src="https://rudtn082.github.io/UI/button1/button1.html" width="900" height="160" style="margin: 15px auto; display: block;"></iframe><p>✔️ HTML  </p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;buttonBox&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;button red&quot;</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;javascript:;&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>Button<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;material-icons-outlined icons&quot;</span>&gt;</span>delete<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;button blue&quot;</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;javascript:;&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>Button<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;material-icons-outlined icons&quot;</span>&gt;</span>save<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;button green&quot;</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;javascript:;&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>Button<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;material-icons-outlined icons&quot;</span>&gt;</span>done<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure><p>✔️ CSS  </p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.buttonBox</span> &#123;<br>    <span class="hljs-attribute">display</span>: flex;<br>    <span class="hljs-attribute">width</span>: <span class="hljs-number">100%</span>;<br>    <span class="hljs-attribute">height</span>: <span class="hljs-number">50px</span>;<br>&#125;<br><span class="hljs-selector-class">.buttonBox</span> <span class="hljs-selector-class">.button</span> &#123;<br>    <span class="hljs-attribute">flex</span>: <span class="hljs-number">1</span>;<br>    <span class="hljs-attribute">color</span>: <span class="hljs-number">#aaa</span>;<br>    <span class="hljs-attribute">background</span>: <span class="hljs-number">#fff</span>;<br>    <span class="hljs-attribute">border-right</span>: <span class="hljs-number">1px</span> solid <span class="hljs-number">#ccc</span>;<br>    <span class="hljs-attribute">font-size</span>: <span class="hljs-number">17px</span>;<br>    <span class="hljs-attribute">text-align</span>: center;<br>    <span class="hljs-attribute">line-height</span>: <span class="hljs-number">50px</span>;<br>    <span class="hljs-attribute">transition</span>: all <span class="hljs-number">0.5s</span> ease-in-out;<br>    <span class="hljs-attribute">text-decoration</span>: none;<br>&#125;<br><span class="hljs-selector-class">.buttonBox</span> <span class="hljs-selector-class">.button</span><span class="hljs-selector-pseudo">:last-child</span> &#123;<br>    <span class="hljs-attribute">border</span>: <span class="hljs-number">0px</span>;<br>&#125;<br><span class="hljs-selector-class">.buttonBox</span> <span class="hljs-selector-class">.button</span><span class="hljs-selector-pseudo">:hover</span> &#123;<br>    <span class="hljs-attribute">flex</span>: <span class="hljs-number">2</span>;<br>&#125;<br><span class="hljs-selector-class">.buttonBox</span> <span class="hljs-selector-class">.button</span><span class="hljs-selector-class">.red</span><span class="hljs-selector-pseudo">:hover</span> &#123;<br>    <span class="hljs-attribute">color</span>: <span class="hljs-number">#fff</span>;<br>    <span class="hljs-attribute">background</span>: <span class="hljs-number">#d32f2f</span>;<br>&#125;<br><span class="hljs-selector-class">.buttonBox</span> <span class="hljs-selector-class">.button</span><span class="hljs-selector-class">.blue</span><span class="hljs-selector-pseudo">:hover</span> &#123;<br>    <span class="hljs-attribute">color</span>: <span class="hljs-number">#fff</span>;<br>    <span class="hljs-attribute">background</span>: <span class="hljs-number">#1976d2</span>;<br>&#125;<br><span class="hljs-selector-class">.buttonBox</span> <span class="hljs-selector-class">.button</span><span class="hljs-selector-class">.green</span><span class="hljs-selector-pseudo">:hover</span> &#123;<br>    <span class="hljs-attribute">color</span>: <span class="hljs-number">#fff</span>;<br>    <span class="hljs-attribute">background</span>: <span class="hljs-number">#388e3c</span>;<br>&#125;<br><span class="hljs-selector-class">.buttonBox</span> <span class="hljs-selector-class">.button</span> <span class="hljs-selector-class">.icons</span> &#123;<br>    <span class="hljs-attribute">vertical-align</span>: text-bottom;<br>    <span class="hljs-attribute">width</span>: <span class="hljs-number">0</span>;<br>    <span class="hljs-attribute">margin-left</span>: <span class="hljs-number">5px</span>;<br>    <span class="hljs-attribute">overflow</span>: hidden;<br>    <span class="hljs-attribute">font-size</span>: <span class="hljs-number">22px</span>;<br>    <span class="hljs-attribute">transition</span>: width <span class="hljs-number">0.5s</span> ease-in-out;<br>&#125;<br><span class="hljs-keyword">@media</span> all <span class="hljs-keyword">and</span> (<span class="hljs-attribute">min-width</span>: <span class="hljs-number">420px</span>) &#123;<br>    <span class="hljs-selector-class">.buttonBox</span> <span class="hljs-selector-class">.button</span><span class="hljs-selector-pseudo">:hover</span> <span class="hljs-selector-class">.icons</span> &#123;<br>        <span class="hljs-attribute">width</span>: <span class="hljs-number">20px</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>✔️ GitHub<br><a href="https://github.com/rudtn082/UI/tree/main/button1" title="GitHub">링크</a>  </p>]]></content>
    
    
    <categories>
      
      <category>UI_UX</category>
      
    </categories>
    
    
    <tags>
      
      <tag>버튼</tag>
      
      <tag>디자인</tag>
      
      <tag>CSS</tag>
      
      <tag>button</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[안드로이드 프레임워크 개선] - strlcpy1</title>
    <link href="/strlcpy1/"/>
    <url>/strlcpy1/</url>
    
    <content type="html"><![CDATA[<h1 id="안드로이드-프레임워크-개선"><a href="#안드로이드-프레임워크-개선" class="headerlink" title="[안드로이드 프레임워크 개선]"></a>[안드로이드 프레임워크 개선]</h1><h2 id="strlcpy1"><a href="#strlcpy1" class="headerlink" title="strlcpy1"></a>strlcpy1</h2><h3 id="안드로이드-소스코드-구성"><a href="#안드로이드-소스코드-구성" class="headerlink" title="안드로이드 소스코드 구성"></a>안드로이드 소스코드 구성</h3><p>bionic&#x2F; - 안드로이드 표준 C 라이브러리<br>bootable&#x2F; - 부트로더 및 Disk Installer 등<br>build&#x2F; - Makefile 관련 세팅파일들, script, map file<br>development&#x2F; - 개발 시 필요한 utility &amp; application<br>external&#x2F; - 안드로이드 프레임워크가 아닌 외부에서 가져온 라이브러리와 바이너리 위치<br>frameworks&#x2F; - android framework, C&#x2F;C++(JNI포함)&#x2F;JAVA source들, 일부 HAL source도 포함<br>　　　　&#x2F;base - Android Framework source<br>　　　　&#x2F;libs : Android base library<br>　　　　&#x2F;audioflinger : Android audio service &amp; HAL source<br>　　　　&#x2F;surfaceflinger : Android video service &amp; HAL<br>　　　　&#x2F;ui :Application Framework에서 JNI를 통해서  호출되는 Android framework의 client part, HAL (Input device의 경우)  - EventHub.cpp<br>　　　　&#x2F;utils : wrapping class, 압축관련 유틸리티 등<br>　　　　&#x2F;binder : Android Binder &amp; Anonymous shared memory<br>　　　　&#x2F;cmds : binder관련인 service manager소스와 여러가지 command들<br>　　　　&#x2F;media : media관련 client &amp; service library<br>hardware&#x2F; - HAL source &amp; include, 일반적으로 android에서 사용하는 hardware관련 소스들을 포함, 반드시 이 디렉토리에만 위치하는 것은 아니다(vendor 디렉토리에 존재하는 경우도 많음)<br>out&#x2F; - 컴파일 된 결과물이 생성되는 디렉토리<br>packages&#x2F; - android 기본 application source(JAVA)<br>prebuilt&#x2F; - compiler &amp; binaries<br>system&#x2F; - android의 기본 binary 소스<br>      &#x2F;core&#x2F;init :  android init source<br>      &#x2F;core&#x2F;vold :  external storage 제어 모듈  </p><h3 id="strlcpy가-사용되는-곳-정리"><a href="#strlcpy가-사용되는-곳-정리" class="headerlink" title="strlcpy가 사용되는 곳 정리"></a>strlcpy가 사용되는 곳 정리</h3><p>환경 : Android-6.0.1_r77  </p><p><img src="/images/post/str1_1.png" alt="str_1" title="str1_1">  </p><p>링크 : <a href="https://docs.google.com/spreadsheets/d/1GucItCNYztFqANwKHoCE1N-0Nap_DhEjrBPiBnQGsL0/edit?usp=sharing">https://docs.google.com/spreadsheets/d/1GucItCNYztFqANwKHoCE1N-0Nap_DhEjrBPiBnQGsL0/edit?usp=sharing</a>  </p><p>안드로이드 6.0.1_r77 버전 기준 총 488개의 파일에서 1568개의 strlcpy()가 사용 중이고, 오디오나 미디어쪽 하드웨어쪽 소스에서 가장 많이 사용하는 것 같다.  </p>]]></content>
    
    
    <categories>
      
      <category>Android</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Android</tag>
      
      <tag>안드로이드 프레임워크 개선</tag>
      
      <tag>strlcpy</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[안드로이드 프레임워크 개선] - PackageManager10</title>
    <link href="/PackageManager10/"/>
    <url>/PackageManager10/</url>
    
    <content type="html"><![CDATA[<h1 id="안드로이드-프레임워크-개선"><a href="#안드로이드-프레임워크-개선" class="headerlink" title="[안드로이드 프레임워크 개선]"></a>[안드로이드 프레임워크 개선]</h1><h2 id="PackageManager10"><a href="#PackageManager10" class="headerlink" title="PackageManager10"></a>PackageManager10</h2><h3 id="멘토님-의견"><a href="#멘토님-의견" class="headerlink" title="멘토님 의견"></a>멘토님 의견</h3><p>① Git log를 봐도 5년간 change가 없는 곳이다.  </p><p>② 안드로이드의 경우 OpenSource이기 때문에 간혹 라이센스 문제라던지 기타 등등의 이유로 이해할 수 없는 라이브러리를 쓰기도 한다.(경험적인 의견)  </p><p>③ 어쨌든 개선 포인트에 대해서 실험 결과를 바탕으로 결론까지 도출해 보면 좋을 것 같다.  </p><p>④ Contribution의 경우 특별한 방법이 있는 것은 아니고, 지금 Git을 통해 소스를 받은 상태인데, 코드 수정 후에 Commit을 만들고 repo upload 등을 통해 업로드해봐라.<br>(리뷰어 점수를 받고 merge가 되니까 올리는 것은 걱정하지 말라.)</p><h3 id="100번-측정"><a href="#100번-측정" class="headerlink" title="100번 측정(?)"></a>100번 측정(?)</h3><p><img src="/images/post/PM10_1.png" alt="PM10_1" title="PM10_1">  </p><p>100번을 측정하고 보니, 개선이 안되어있었다. 이유를 찾아보니, 잘못된 로그로 측정하고 있었다.  </p><p>100번 측정하는 것은 다음 주에 다시 진행할 예정이다.  </p><h3 id="strlcpy-수정"><a href="#strlcpy-수정" class="headerlink" title="strlcpy 수정"></a>strlcpy 수정</h3><p>로그 수정하기 위해 코드를 보다가 수정하려던 strlcpy()를 잘못 작성한 것을 확인했다.<br>기존 strlcpy()는 마지막에 널값을 추가해주는데, 우리가 작성한 코드는 널값을 넣어주지 않았었다.  </p><p>-수정 전-  </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">size_t</span>                 </span><br><span class="hljs-function"><span class="hljs-title">strlcpy</span><span class="hljs-params">(<span class="hljs-type">char</span>* dst, <span class="hljs-type">const</span> <span class="hljs-type">char</span>* src, <span class="hljs-type">size_t</span> siz)</span>    </span><br><span class="hljs-function"></span>&#123;<br>   <span class="hljs-built_in">memcpy</span>(dst, src, siz);<br><br>   <span class="hljs-keyword">return</span> <span class="hljs-built_in">strlen</span>(src);<br>&#125;<br></code></pre></td></tr></table></figure><p>-수정 후-  </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">size_t</span>                 </span><br><span class="hljs-function"><span class="hljs-title">strlcpy</span><span class="hljs-params">(<span class="hljs-type">char</span>* dst, <span class="hljs-type">const</span> <span class="hljs-type">char</span>* src, <span class="hljs-type">size_t</span> siz)</span>    </span><br><span class="hljs-function"></span>&#123;<br>   <span class="hljs-type">size_t</span> srclen, returnV = <span class="hljs-built_in">strlen</span>(src);<br><br>   siz--;<br><br>   srclen = returnV;<br><br>   <span class="hljs-keyword">if</span> (srclen &gt; siz)<br>      srclen = siz;<br><br>   <span class="hljs-built_in">memcpy</span>(dst, src, srclen);<br>   dst[srclen] = <span class="hljs-string">&#x27;\0&#x27;</span>;<br><br>   <span class="hljs-keyword">return</span> returnV;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="문제점"><a href="#문제점" class="headerlink" title="문제점"></a>문제점</h3><p>(추측) 말 그대로 copy기 때문에 우리가 바꾼 부분이 첫 번째 부팅과 새로 앱을 깔았을 경우에서만 사용되는 것 같음<br>-&gt; 검증해야 함, 논문을 쓸 수 있을지?(매번 켤 때마다 개선되는 것이 아니기 때문에)  </p><h3 id="앞으로-방향"><a href="#앞으로-방향" class="headerlink" title="앞으로 방향"></a>앞으로 방향</h3><ol><li>전체 부팅시간을 측정해보고 개선이 된다면 그대로 부팅속도 향상 쪽으로<br>(패키지 스캐닝 개선으로 주제를 잡을 것이면 copy말고도 find부분도 개선이 필요한가?)  </li><li>부팅속도 개선이 안된다면 메모리 블록 복사를 통한 안드로이드 개선쪽으로(다른 곳에서도 strlcpy를 사용하기 때문에)</li></ol><p>기존 논문 제목과 목차를 다음과 같이 하려고 했었는데, 방향을 결정하고 PPT 제작 예정  </p><p><img src="/images/post/PM10_2.png" alt="PM10_2" title="PM10_2">  </p><p><img src="/images/post/PM10_3.png" alt="PM10_3" title="PM10_3">  </p>]]></content>
    
    
    <categories>
      
      <category>Android</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Android</tag>
      
      <tag>안드로이드 프레임워크 개선</tag>
      
      <tag>PackageManager</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[안드로이드 프레임워크 개선] - PackageManager9</title>
    <link href="/PackageManager9/"/>
    <url>/PackageManager9/</url>
    
    <content type="html"><![CDATA[<h1 id="안드로이드-프레임워크-개선"><a href="#안드로이드-프레임워크-개선" class="headerlink" title="[안드로이드 프레임워크 개선]"></a>[안드로이드 프레임워크 개선]</h1><h2 id="PackageManager9"><a href="#PackageManager9" class="headerlink" title="PackageManager9"></a>PackageManager9</h2><h3 id="문제의-if문"><a href="#문제의-if문" class="headerlink" title="문제의 if문"></a>문제의 if문</h3><p>지난주 아래의 if문이 무조건 true로 밖에 나올 수 없다고 생각했었는데, strlcpy()를 수정하기 전에 실제로 그러한지 확인을 했다.  </p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-selector-tag">if</span> (<span class="hljs-built_in">strlcpy</span>(localFileName, nativeLibPath.<span class="hljs-built_in">c_str</span>(), <span class="hljs-built_in">sizeof</span>(localFileName)) != nativeLibPath.<span class="hljs-built_in">size</span>()) &#123;<br>    <span class="hljs-selector-tag">ALOGD</span>(<span class="hljs-string">&quot;Couldn&#x27;t allocate local file name for library&quot;</span>);<br>    <span class="hljs-selector-tag">return</span> <span class="hljs-selector-tag">INSTALL_FAILED_INTERNAL_ERROR</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>strlcpy()의 결과로 nativeLibPath.c_str()의 문자열의 길이와 nativeLibPath.size()를 비교하게 되는 코드인데,<br>결국 리턴 받은 utf_chars_의 길이와 strlen(utf_chars_)를 수행하는 꼴이 된다.<br>혹시 우리가 모르는 예외가 있을 수 있다고 생각해 직접 비교하는 코드를 만들어 확인했다.  </p><p><img src="/images/post/PM9_1.png" alt="PM9_1" title="PM9_1">  </p><p>0~30 길이의 문자열을 랜덤으로 생성해서, strlcpy의 결과와 해당 문자열을 strlen 한 결과를 비교하여 false가 나오는지 확인했다.<br>결과는 10만 번을 수행했지만 다음과 같이 모두 true로 나왔다.  </p><p><img src="/images/post/PM9_2.png" alt="PM9_2" title="PM9_2">  </p>]]></content>
    
    
    <categories>
      
      <category>Android</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Android</tag>
      
      <tag>안드로이드 프레임워크 개선</tag>
      
      <tag>PackageManager</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[안드로이드 프레임워크 개선] - PackageManager8</title>
    <link href="/PackageManager8/"/>
    <url>/PackageManager8/</url>
    
    <content type="html"><![CDATA[<h1 id="안드로이드-프레임워크-개선"><a href="#안드로이드-프레임워크-개선" class="headerlink" title="[안드로이드 프레임워크 개선]"></a>[안드로이드 프레임워크 개선]</h1><h2 id="PackageManager8"><a href="#PackageManager8" class="headerlink" title="PackageManager8"></a>PackageManager8</h2><p>지난주에 strlcpy를 memcpy로 변경해보았는데, 속도는 빨라졌지만, 동일하게 동작하는지 알 수 없었다.<br>먼저 우리가 모르는 부분에 대해서 공부를 해보기로 했다.  </p><h3 id="strlcpy"><a href="#strlcpy" class="headerlink" title="strlcpy()"></a>strlcpy()</h3><p>Version : android-6.0.1_r77<br>소스 코드 : <a href="https://android.googlesource.com/platform/system/core/+/refs/tags/android-6.0.1_r77/libcutils/strlcpy.c">https://android.googlesource.com/platform/system/core/+/refs/tags/android-6.0.1_r77/libcutils/strlcpy.c</a>  </p><p>src를 dst로 siz크기만큼 copy 한다. strncpy()와 비슷해 보였지만 다음과 같은 다른 점이 있었다.<br>먼저, strcpy()는 널값까지 복사가 되지만 오버플로우 문제가 있다.<br>strncpy()는 널값을 상관하지 않고 n의 길이만큼 복사하게 된다. n의 길이에 따라서 널값을 복사하지 않을 때가 있고, 성능 저하 문제가 있다.  </p><p>strlcpy()는 OpenBSD 프로젝트를 통해 유래된 비표준 C 함수였다.<br>다른 점이 있다면 strlcpy()는 주어진 크기가 0이 아닌 모든 문자열에 대해 대상 문자열을 NUL 종료하도록 보장합니다.  </p><p>그리고 보통 strncpy()를 사용하면 strlen()를 사용하여 결과의 길이를 찾는 것이 일반적이기 마련인데, strlcpy()의 리턴 값을 결괏값의 길이로 하여 최종 strlen()을 찾는 것이 더 이상 필요하지 않는다.  </p><p>다음과 같은 strlcpy()의 예시를 작성해보았다.  </p><p><img src="/images/post/PM8_1.png" alt="PM8_1" title="PM8_1">  </p><p>아래와 같이 동작을 하고 마지막에 s - src - 1 (쓰레기값 - 기본값 - 널값)으로, 결과적으로는 src 문자열 길이를 리턴해준다.  </p><p><img src="/images/post/PM8_2.png" alt="PM8_2" title="PM8_2">  </p><h3 id="memcpy"><a href="#memcpy" class="headerlink" title="memcpy()"></a>memcpy()</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span>  <span class="hljs-comment">// C++ 에서는 &lt;cstring&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">void</span>* <span class="hljs-title">memcpy</span><span class="hljs-params">(<span class="hljs-type">void</span>* destination, <span class="hljs-type">const</span> <span class="hljs-type">void</span>* source, <span class="hljs-type">size_t</span> num)</span></span>;<br></code></pre></td></tr></table></figure><p>memcpy()는 source가 가리키는 곳 부터 num바이트 만큼을 destination에 복사한다.<br>(이 때, destination과 source의 타입은 모두 위 함수와 무관하다)  </p><p>strlcpy()와 다른점은 strncpy()와 같이 널 종료 문자(null terminating character)을 검사하지 않는다. num 바이트 만큼을 복사한다.  </p><h3 id="localFileName-가변-배열-선언"><a href="#localFileName-가변-배열-선언" class="headerlink" title="localFileName 가변 배열 선언?"></a>localFileName 가변 배열 선언?</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">const</span> <span class="hljs-type">size_t</span> fileNameLen = <span class="hljs-built_in">strlen</span>(fileName);<br><span class="hljs-type">char</span> localFileName[nativeLibPath.<span class="hljs-built_in">size</span>() + fileNameLen + <span class="hljs-number">2</span>];<br></code></pre></td></tr></table></figure><p>‘C99 표준’에서는 프로그램 실행 중에 크기가 변할 수 있는 배열인 VLA(Variable Length Array)를 지원한다고한다.  </p><p><img src="/images/post/PM8_3.png" alt="PM8_3" title="PM8_3">  </p><p>그래서 안드로이드 6.0.1을 빌드하기 위해서 필요한 gcc버전을 확인해보았는데, 4.8.4 버전을 사용하고 있었다.<br>gcc 4.8.4 버전의 메뉴얼을 확인해보았다.  </p><p><img src="/images/post/PM8_4.png" alt="PM8_4" title="PM8_4">  </p><p><img src="/images/post/PM8_5.png" alt="PM8_5" title="PM8_5">  </p><p>gcc계열의 컴파일러에서는(4.5이상) 가변 길이 배열에 대한 표준안이 채택되어 사용 중이다.  </p><p>우리가 평소에 윈도우에서 사용하는 Visual Studio는 C99 표준이 전부다 적용된 것이 아니라 가변 길이 배열은 사용이 불가능하다고 한다.  </p><h3 id="ScopedUtfChars"><a href="#ScopedUtfChars" class="headerlink" title="ScopedUtfChars"></a>ScopedUtfChars</h3><p>com_android_internal_content_NativeLibraryHelper.cpp에서 nativeLibPath가 ScopedUtfChars형을 갖게된다.<br>.c_str()와 .size()가 등장하는데, return값은 다음과 같다.  </p><p>const char* utf_chars_</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">const</span> <span class="hljs-type">char</span>* <span class="hljs-title">c_str</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123;<br>  <span class="hljs-keyword">return</span> utf_chars_;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">size_t</span> <span class="hljs-title">size</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-built_in">strlen</span>(utf_chars_);<br>&#125;<br></code></pre></td></tr></table></figure><p>함수 선언에 사용되는 const는 이 함수가 값을 변경하지 않음을 보장한다.  </p><p>nativeLibPath.size()는 문자열의 길이를 뜻하는 것.</p><h3 id="memcpy-로-변경"><a href="#memcpy-로-변경" class="headerlink" title="memcpy()로 변경?"></a>memcpy()로 변경?</h3><p>memcpy로 변경하기 위해서는 if문의 nativeLibPath.c_str() 길이와</p><p>기존 코드는 다음과 같다.  </p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-selector-tag">if</span> (<span class="hljs-built_in">strlcpy</span>(localFileName, nativeLibPath.<span class="hljs-built_in">c_str</span>(), <span class="hljs-built_in">sizeof</span>(localFileName)) != nativeLibPath.<span class="hljs-built_in">size</span>()) &#123;<br>    <span class="hljs-selector-tag">ALOGD</span>(<span class="hljs-string">&quot;Couldn&#x27;t allocate local file name for library&quot;</span>);<br>    <span class="hljs-selector-tag">return</span> <span class="hljs-selector-tag">INSTALL_FAILED_INTERNAL_ERROR</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>nativeLibPath.c_str()의 문자열 길이와 nativeLibPath.size()의 값을 비교하게 된다.  </p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-selector-tag">memcpy</span>(localFileName, nativeLibPath.<span class="hljs-built_in">c_str</span>(), <span class="hljs-built_in">sizeof</span>(localFileName))<br><span class="hljs-selector-tag">if</span>(<span class="hljs-built_in">strlen</span>(nativeLibPath.<span class="hljs-built_in">c_str</span>()) != nativeLibPath.<span class="hljs-built_in">size</span>()) &#123;<br>  <span class="hljs-selector-tag">ALOGD</span>(<span class="hljs-string">&quot;Couldn&#x27;t allocate local file name for library&quot;</span>);<br>  <span class="hljs-selector-tag">return</span> <span class="hljs-selector-tag">INSTALL_FAILED_INTERNAL_ERROR</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>로 변경한다면 같은 내용이 될 것같다…. 하지만.. 두 가지의 의문점이 있었다.<br>① memcpy()를 하고나서 strlen()을 한다면 속도의 개선이 있을지?<br>② nativeLibPath.c_str()의 문자열의 길이와 nativeLibPath.size()를 비교하는 의미를 잘 모르겠다. 결국에는 같은 것을 비교하는 꼴이라 if문 안으로 들어올 일이 전혀 없다고 생각한다.  </p><h3 id="strlcpy-를-커스텀"><a href="#strlcpy-를-커스텀" class="headerlink" title="strlcpy()를 커스텀?"></a>strlcpy()를 커스텀?</h3><p>그래서 memcpy를 사용하여 개선을 하는 것도 좋지만 다른 방법을 생각해보았다.<br>strlcpy() 자체를 커스텀해서 기존의 고치려는 코드는 그대로 냅두고, strlcpy.c 파일을 수정하는 방법도 괜찮을 것 같다.  </p><p>실제로 구글링 결과 아직 확인해보지는 못했지만, Implement strlcpy라는 글이 있는 것을 보아 충분히 가능할 것으로 보인다.  </p>]]></content>
    
    
    <categories>
      
      <category>Android</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Android</tag>
      
      <tag>안드로이드 프레임워크 개선</tag>
      
      <tag>PackageManager</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[안드로이드 프레임워크 개선] - PackageManager7</title>
    <link href="/PackageManager7/"/>
    <url>/PackageManager7/</url>
    
    <content type="html"><![CDATA[<h1 id="안드로이드-프레임워크-개선"><a href="#안드로이드-프레임워크-개선" class="headerlink" title="[안드로이드 프레임워크 개선]"></a>[안드로이드 프레임워크 개선]</h1><h2 id="PackageManager7"><a href="#PackageManager7" class="headerlink" title="PackageManager7"></a>PackageManager7</h2><p>시간이 오래걸리는 파트를 분석했고, 이번주는 시간이 오래 걸리는 파트에서 부르는 메소드를 분석하기로 했다.  </p><p>Version : android-6.0.1_r77<br>PackageManagerService.java  </p><p>소스 코드 : <a href="https://android.googlesource.com/platform/frameworks/base/+/refs/tags/android-6.0.1_r77/services/core/java/com/android/server/pm/PackageManagerService.java">https://android.googlesource.com/platform/frameworks/base/+/refs/tags/android-6.0.1_r77/services/core/java/com/android/server/pm/PackageManagerService.java</a>  </p><h3 id="derivePackageAbi"><a href="#derivePackageAbi" class="headerlink" title="derivePackageAbi()"></a>derivePackageAbi()</h3><p>Line : 7554 ~ 7685  </p><p>해당 메소드는 ABI를 결정하고 내부 앱인지를 판단하여 lib 라이브러리를 설치한다.<br>scanPackageDirtyLI에서 부르는 메소드로, 앱의 개수마다 불리게 되어 개선이 필요해 보인다.  </p><p>① setNativeLibraryPaths(pkg)를 호출하여 lib 디렉토리를 작성<br>(시스템에 내장 APK가있는 경우 system&#x2F;lib, vendor&#x2F;lib와 같은 시스템 APK 디렉토리에 lib 디렉토리를 작성하고)<br>(사용자가 APK를 설치하는 경우 data&#x2F;app-lib 아래의 pk 디렉토리와 같은 lib 디렉토리를 작성.)  </p><p>②-1 lib 라이브러리를 추출해야하는 경우, 즉 extractLibs가 true 인 경우 NativeLibraryHelper.copyNativeBinariesForSupportedAbi()를 호출하여 ABI를 일치시키고 ABI 디렉토리에 해당하는 lib 파일을 해당 디렉토리로 복사한다.  </p><p>②-2 lib 라이브러리가 필요하지 않은 경우, NativeLibraryHelper.findSupportedAbi()가 ABI와 일치하도록 호출된다.  </p><p><strong>새로 설치된 APK의 경우 lib 라이브러리를 추출해야 한다. 즉 extractLibs가 true.</strong>  </p><p>③ APKprimaryCpuAbi, secondaryCpuAbi를 설정한다.  </p><p><em>ABI란?</em><br><em>API보다 저수준(바이너리에서 호환) &#x2F; 두 개의 바이너리 프로그램 모듈 사이의 interface 이다. 보통 한 쪽은 라이브러리 혹은 운영체제이고, 다른 한 쪽은 사용자가 동작시키는 프로그램이다.</em>  </p><p>derivePackageAbi() 메소드에서 앱 마다 걸리는 시간을 측정 해 보기위해 다음과 같은 코드를 이용했다.  </p><p><img src="/images/post/PM7_1.png" alt="PM7_1" title="PM7_1">  </p><p>다음과 같은 시간이 걸렸으며, 설치된 앱 개수에 따라서 오랜 시간이 걸릴 것으로 예상된다.  </p><p><img src="/images/post/PM7_2.png" alt="PM7_2" title="PM7_2">  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">derivePackageAbi</span><span class="hljs-params">(PackageParser.Package pkg, File scanFile,</span><br><span class="hljs-params">                             String cpuAbiOverride, <span class="hljs-type">boolean</span> extractLibs)</span><br>        <span class="hljs-keyword">throws</span> PackageManagerException &#123;<br><br>        setNativeLibraryPaths(pkg); <span class="hljs-comment">// ① 호출하여 lib 디렉토리를 작성  </span><br><br>        <span class="hljs-keyword">if</span> (pkg.isForwardLocked() || pkg.applicationInfo.isExternalAsec() ||<br>                (isSystemApp(pkg) &amp;&amp; !pkg.isUpdatedSystemApp())) &#123;<br>            extractLibs = <span class="hljs-literal">false</span>; <span class="hljs-comment">// extractLibs 값 결정</span><br>        &#125;<br><br>        <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">nativeLibraryRootStr</span> <span class="hljs-operator">=</span> pkg.applicationInfo.nativeLibraryRootDir;<br>        <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-variable">useIsaSpecificSubdirs</span> <span class="hljs-operator">=</span> pkg.applicationInfo.nativeLibraryRootRequiresIsa;<br>        NativeLibraryHelper.<span class="hljs-type">Handle</span> <span class="hljs-variable">handle</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">try</span> &#123;<br>            handle = NativeLibraryHelper.Handle.create(scanFile);<br><br>            <span class="hljs-keyword">final</span> <span class="hljs-type">File</span> <span class="hljs-variable">nativeLibraryRoot</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(nativeLibraryRootStr);<br><br>            pkg.applicationInfo.primaryCpuAbi = <span class="hljs-literal">null</span>; <span class="hljs-comment">// ③ 설정해야 할 것</span><br>            pkg.applicationInfo.secondaryCpuAbi = <span class="hljs-literal">null</span>; <span class="hljs-comment">// ③ 설정해야 할 것</span><br><br>            <span class="hljs-keyword">if</span> (isMultiArch(pkg.applicationInfo)) &#123;<br><br>                <span class="hljs-keyword">if</span> (pkg.cpuAbiOverride != <span class="hljs-literal">null</span><br>                        &amp;&amp; !NativeLibraryHelper.CLEAR_ABI_OVERRIDE.equals(pkg.cpuAbiOverride)) &#123;<br>                    Slog.w(TAG, <span class="hljs-string">&quot;Ignoring abiOverride for multi arch application.&quot;</span>);<br>                &#125;<br><br>                <span class="hljs-type">int</span> <span class="hljs-variable">abi32</span> <span class="hljs-operator">=</span> PackageManager.NO_NATIVE_LIBRARIES;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">abi64</span> <span class="hljs-operator">=</span> PackageManager.NO_NATIVE_LIBRARIES;<br><br>                <span class="hljs-keyword">if</span> (Build.SUPPORTED_32_BIT_ABIS.length &gt; <span class="hljs-number">0</span>) &#123;<br>                    <span class="hljs-keyword">if</span> (extractLibs) &#123; <span class="hljs-comment">// ②-1, extractLibs가 true 인 경우</span><br>                        abi32 = NativeLibraryHelper.copyNativeBinariesForSupportedAbi(handle,<br>                                nativeLibraryRoot, Build.SUPPORTED_32_BIT_ABIS,<br>                                useIsaSpecificSubdirs);<br>                    &#125; <span class="hljs-keyword">else</span> &#123; ②-<span class="hljs-number">2</span>, extractLibs가 <span class="hljs-literal">false</span> 인 경우<br>                        abi32 = NativeLibraryHelper.findSupportedAbi(handle, Build.SUPPORTED_32_BIT_ABIS);<br>                    &#125;<br>                &#125;<br><br>                maybeThrowExceptionForMultiArchCopy(<br>                        <span class="hljs-string">&quot;Error unpackaging 32 bit native libs for multiarch app.&quot;</span>, abi32);<br><br>                <span class="hljs-keyword">if</span> (Build.SUPPORTED_64_BIT_ABIS.length &gt; <span class="hljs-number">0</span>) &#123;<br>                    <span class="hljs-keyword">if</span> (extractLibs) &#123; <span class="hljs-comment">// ②-1, extractLibs가 true 인 경우</span><br>                        abi64 = NativeLibraryHelper.copyNativeBinariesForSupportedAbi(handle,<br>                                nativeLibraryRoot, Build.SUPPORTED_64_BIT_ABIS,<br>                                useIsaSpecificSubdirs);<br>                    &#125; <span class="hljs-keyword">else</span> &#123; ②-<span class="hljs-number">2</span>, extractLibs가 <span class="hljs-literal">false</span> 인 경우<br>                        abi64 = NativeLibraryHelper.findSupportedAbi(handle, Build.SUPPORTED_64_BIT_ABIS);<br>                    &#125;<br>                &#125;<br><br>                maybeThrowExceptionForMultiArchCopy(<br>                        <span class="hljs-string">&quot;Error unpackaging 64 bit native libs for multiarch app.&quot;</span>, abi64);<br><br>                <span class="hljs-keyword">if</span> (abi64 &gt;= <span class="hljs-number">0</span>) &#123;<br>                    pkg.applicationInfo.primaryCpuAbi = Build.SUPPORTED_64_BIT_ABIS[abi64]; <span class="hljs-comment">// ③ ABI설정</span><br>                &#125;<br><br>                <span class="hljs-keyword">if</span> (abi32 &gt;= <span class="hljs-number">0</span>) &#123;<br>                    <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">abi</span> <span class="hljs-operator">=</span> Build.SUPPORTED_32_BIT_ABIS[abi32];<br>                    <span class="hljs-keyword">if</span> (abi64 &gt;= <span class="hljs-number">0</span>) &#123;<br>                        pkg.applicationInfo.secondaryCpuAbi = abi; <span class="hljs-comment">// ③ ABI설정</span><br>                    &#125; <span class="hljs-keyword">else</span> &#123;<br>                        pkg.applicationInfo.primaryCpuAbi = abi; <span class="hljs-comment">// ③ ABI설정</span><br>                    &#125;<br>                &#125;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                String[] abiList = (cpuAbiOverride != <span class="hljs-literal">null</span>) ?<br>                        <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>[] &#123; cpuAbiOverride &#125; : Build.SUPPORTED_ABIS;<br><br>                <span class="hljs-type">boolean</span> <span class="hljs-variable">needsRenderScriptOverride</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>                <span class="hljs-keyword">if</span> (Build.SUPPORTED_64_BIT_ABIS.length &gt; <span class="hljs-number">0</span> &amp;&amp; cpuAbiOverride == <span class="hljs-literal">null</span> &amp;&amp;<br>                        NativeLibraryHelper.hasRenderscriptBitcode(handle)) &#123;<br>                    abiList = Build.SUPPORTED_32_BIT_ABIS;<br>                    needsRenderScriptOverride = <span class="hljs-literal">true</span>;<br>                &#125;<br><br>                <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> copyRet;<br>                <span class="hljs-keyword">if</span> (extractLibs) &#123; <span class="hljs-comment">// ②-1, extractLibs가 true 인 경우</span><br>                    copyRet = NativeLibraryHelper.copyNativeBinariesForSupportedAbi(handle,<br>                            nativeLibraryRoot, abiList, useIsaSpecificSubdirs);<br>                &#125; <span class="hljs-keyword">else</span> &#123; ②-<span class="hljs-number">2</span>, extractLibs가 <span class="hljs-literal">false</span> 인 경우<br>                    copyRet = NativeLibraryHelper.findSupportedAbi(handle, abiList);<br>                &#125;<br>                <span class="hljs-keyword">if</span> (copyRet &lt; <span class="hljs-number">0</span> &amp;&amp; copyRet != PackageManager.NO_NATIVE_LIBRARIES) &#123;<br>                    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">PackageManagerException</span>(INSTALL_FAILED_INTERNAL_ERROR,<br>                            <span class="hljs-string">&quot;Error unpackaging native libs for app, errorCode=&quot;</span> + copyRet);<br>                &#125;<br>                <span class="hljs-keyword">if</span> (copyRet &gt;= <span class="hljs-number">0</span>) &#123;<br>                    pkg.applicationInfo.primaryCpuAbi = abiList[copyRet]; <span class="hljs-comment">// ③ ABI설정</span><br>                &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (copyRet == PackageManager.NO_NATIVE_LIBRARIES &amp;&amp; cpuAbiOverride != <span class="hljs-literal">null</span>) &#123;<br>                    pkg.applicationInfo.primaryCpuAbi = cpuAbiOverride; <span class="hljs-comment">// ③ ABI설정</span><br>                &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (needsRenderScriptOverride) &#123;<br>                    pkg.applicationInfo.primaryCpuAbi = abiList[<span class="hljs-number">0</span>]; <span class="hljs-comment">// ③ ABI설정</span><br>                &#125;<br>            &#125;<br>        &#125; <span class="hljs-keyword">catch</span> (IOException ioe) &#123;<br>            Slog.e(TAG, <span class="hljs-string">&quot;Unable to get canonical file &quot;</span> + ioe.toString());<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            IoUtils.closeQuietly(handle);<br>        &#125;<br><br>        setNativeLibraryPaths(pkg);<br>    &#125;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Android</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Android</tag>
      
      <tag>안드로이드 프레임워크 개선</tag>
      
      <tag>PackageManager</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[안드로이드 프레임워크 개선] - PackageManager6</title>
    <link href="/PackageManager6/"/>
    <url>/PackageManager6/</url>
    
    <content type="html"><![CDATA[<h1 id="안드로이드-프레임워크-개선"><a href="#안드로이드-프레임워크-개선" class="headerlink" title="[안드로이드 프레임워크 개선]"></a>[안드로이드 프레임워크 개선]</h1><h2 id="PackageManager6"><a href="#PackageManager6" class="headerlink" title="PackageManager6"></a>PackageManager6</h2><h3 id="scanPackageDirtyLI"><a href="#scanPackageDirtyLI" class="headerlink" title="scanPackageDirtyLI"></a>scanPackageDirtyLI</h3><p>Version : android-6.0.1_r77<br>PackageManagerService.java<br>Line : 6482 ~ 7545  </p><p>소스 코드 : <a href="https://android.googlesource.com/platform/frameworks/base/+/refs/tags/android-6.0.1_r77/services/core/java/com/android/server/pm/PackageManagerService.java">https://android.googlesource.com/platform/frameworks/base/+/refs/tags/android-6.0.1_r77/services/core/java/com/android/server/pm/PackageManagerService.java</a>  </p><p>PackageManagerService.java의 <strong>scanPackageDirtyLI</strong> 메소드 중 오래걸리는 파트를 확인하기 위해 다음과 같은 방법을 통해 로그를 찍었다.  </p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">long scanStart = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">SystemClock</span>.</span></span>uptime<span class="hljs-constructor">Millis()</span>;<br><br>:<br>:<br><br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Slog</span>.</span></span>i(TAG, <span class="hljs-string">&quot;Time to scan part 1: &quot;</span><br>                  + ((<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">SystemClock</span>.</span></span>uptime<span class="hljs-constructor">Millis()</span>-scanStart)/<span class="hljs-number">1000</span>f)<br>                  + <span class="hljs-string">&quot; seconds&quot;</span>);<br></code></pre></td></tr></table></figure><p>로그는 다음과 같이 출력되었으며 그 아래와 같이 평균을 내었다.  </p><p><img src="/images/post/PM6_1.png" alt="PM6_1" title="PM6_1">  </p><h5 id="파트1-6482-6555-평균-0-0004초"><a href="#파트1-6482-6555-평균-0-0004초" class="headerlink" title="파트1 - 6482 ~ 6555 : 평균 0.0004초"></a>파트1 - 6482 ~ 6555 : 평균 0.0004초</h5><h5 id="파트2-6565-6666-평균-0-0000714초"><a href="#파트2-6565-6666-평균-0-0000714초" class="headerlink" title="파트2 - 6565 ~ 6666 : 평균 0.0000714초"></a>파트2 - 6565 ~ 6666 : 평균 0.0000714초</h5><h5 id="파트3-6668-6822-평균-0-0000371초"><a href="#파트3-6668-6822-평균-0-0000371초" class="headerlink" title="파트3 - 6668 ~ 6822 : 평균 0.0000371초"></a>파트3 - 6668 ~ 6822 : 평균 0.0000371초</h5><h5 id="파트4-6824-6961-평균-0-0000928초"><a href="#파트4-6824-6961-평균-0-0000928초" class="headerlink" title="파트4 - 6824 ~ 6961 : 평균 0.0000928초"></a>파트4 - 6824 ~ 6961 : 평균 0.0000928초</h5><h5 id="파트5-6963-7148-평균-0-0315초"><a href="#파트5-6963-7148-평균-0-0315초" class="headerlink" title="파트5 - 6963 ~ 7148 : 평균 0.0315초"></a>파트5 - 6963 ~ 7148 : 평균 0.0315초</h5><h5 id="파트6-7153-7545-평균-0-0000714초"><a href="#파트6-7153-7545-평균-0-0000714초" class="headerlink" title="파트6 - 7153 ~ 7545 : 평균 0.0000714초"></a>파트6 - 7153 ~ 7545 : 평균 0.0000714초</h5><p>라는 결과를 얻었다. 로그를 통해서 파트5부분이 가장 오래걸리며, 해결이 시급한 부분으로 보인다.  </p><h3 id="6963-7148"><a href="#6963-7148" class="headerlink" title="6963 ~ 7148"></a>6963 ~ 7148</h3><p>가장 시간이 오래걸렸던 파트부분을 다시 세 부분으로 나누어서 시간을 측정했다.  </p><h5 id="파트1-6963-7023-평균-0-0161초"><a href="#파트1-6963-7023-평균-0-0161초" class="headerlink" title="파트1 - 6963 ~ 7023 : 평균 0.0161초"></a>파트1 - 6963 ~ 7023 : 평균 0.0161초</h5><h5 id="파트2-7029-7091-평균-0-0141초"><a href="#파트2-7029-7091-평균-0-0141초" class="headerlink" title="파트2 - 7029 ~ 7091 : 평균 0.0141초"></a>파트2 - 7029 ~ 7091 : 평균 0.0141초</h5><h5 id="파트3-7093-7148-평균-0초"><a href="#파트3-7093-7148-평균-0초" class="headerlink" title="파트3 - 7093 ~ 7148 : 평균 0초"></a>파트3 - 7093 ~ 7148 : 평균 0초</h5><p>라는 결과를 얻었다. 해당 시간값을 통해서 부팅속도 개선을 위한 영역을 좁힐 수 있었다.  </p>]]></content>
    
    
    <categories>
      
      <category>Android</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Android</tag>
      
      <tag>안드로이드 프레임워크 개선</tag>
      
      <tag>PackageManager</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[안드로이드 프레임워크 개선] - PackageManager5</title>
    <link href="/PackageManager5/"/>
    <url>/PackageManager5/</url>
    
    <content type="html"><![CDATA[<h1 id="안드로이드-프레임워크-개선"><a href="#안드로이드-프레임워크-개선" class="headerlink" title="[안드로이드 프레임워크 개선]"></a>[안드로이드 프레임워크 개선]</h1><h2 id="PackageManager5"><a href="#PackageManager5" class="headerlink" title="PackageManager5"></a>PackageManager5</h2><h3 id="scanPackageDirtyLI"><a href="#scanPackageDirtyLI" class="headerlink" title="scanPackageDirtyLI"></a>scanPackageDirtyLI</h3><p>지난주 빌드를 통해 로그를 출력하는 것을 성공했기 때문에 이번에는 PackageManagerService.java의 <strong>scanPackageDirtyLI</strong> 메소드를 분석하기로 했다.  </p><h3 id="scanPackageDirtyLI-분석"><a href="#scanPackageDirtyLI-분석" class="headerlink" title="scanPackageDirtyLI 분석"></a>scanPackageDirtyLI 분석</h3><p>Version : android-6.0.1_r77<br>PackageManagerService.java<br>Line : 6482 ~ 7545  </p><p>소스 코드 : <a href="https://android.googlesource.com/platform/frameworks/base/+/refs/tags/android-6.0.1_r77/services/core/java/com/android/server/pm/PackageManagerService.java">https://android.googlesource.com/platform/frameworks/base/+/refs/tags/android-6.0.1_r77/services/core/java/com/android/server/pm/PackageManagerService.java</a>  </p><p>일단 개선이 가능할 것 같다고 생각하는 부분에 대해서 작성 해 보았다.  </p><h4 id="1-Line-6638"><a href="#1-Line-6638" class="headerlink" title="1. Line : 6638"></a>1. Line : 6638</h4><p><img src="/images/post/PM5_1.png" alt="PM5_1" title="PM5_1">  </p><p>이 부분은 먼저, 6595번째 줄에서 pkg가 시스템 앱이 아닌 경우 다음과 같이 null로 지정해주었다.  </p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs 1c">if (!isSystemApp(pkg)) &#123;<br>    <span class="hljs-comment">// Only system apps can use these features.</span><br>    pkg.mOriginalPackages = <span class="hljs-literal">null</span>;<br>    pkg.mRealPackage = <span class="hljs-literal">null</span>;<br>    pkg.mAdoptPermissions = <span class="hljs-literal">null</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>그러면 시스템 앱이 아닌 사용자가 설치한 애플리케이션에 대해서 for문을 이용해 처음부터 끝까지 반복하게 되는데, 사용자가 설치한 앱이 많을 수록 많은 시간이 소요될 것으로 예상되며 개선할 수 있다고도 생각한다.  </p><h4 id="2-Line-6783"><a href="#2-Line-6783" class="headerlink" title="2. Line : 6783"></a>2. Line : 6783</h4><p><img src="/images/post/PM5_2.png" alt="PM5_2" title="PM5_2">  </p><p>이 부분도 마찬가지로 for문을 이용하여 0부터 N까지 반복한다. 이중 for문을 사용하기 떄문에 충분히 개선 할 수 있다고 생각한다.  </p><h4 id="3-Line-7228"><a href="#3-Line-7228" class="headerlink" title="3. Line : 7228"></a>3. Line : 7228</h4><p><img src="/images/post/PM5_3.png" alt="PM5_3" title="PM5_3">  </p><p>이 부분도 마찬가지로 for문을 이용하여 0부터 N까지 반복한다. 이중 for문을 사용하기 떄문에 충분히 개선 할 수 있다고 생각한다.  </p><h4 id="그외-개선과-관련된-생각"><a href="#그외-개선과-관련된-생각" class="headerlink" title="그외 개선과 관련된 생각.."></a>그외 개선과 관련된 생각..</h4><p>scanPackageDirtyLI 메소드에서 시스템 앱일 경우와 아닌 경우를 나누는 경우가 몇 번 존재했던 것 같다. 애초에 scanPackageDirtyLI를 두 개를 만들고 매개변수를 다르게 오버로딩하여 시스템 앱일 경우와 아닌 경우 다른 메소드를 실행하는 것은 어떨까?…  </p>]]></content>
    
    
    <categories>
      
      <category>Android</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Android</tag>
      
      <tag>안드로이드 프레임워크 개선</tag>
      
      <tag>PackageManager</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[안드로이드 프레임워크 개선] - PackageManager4</title>
    <link href="/PackageManager4/"/>
    <url>/PackageManager4/</url>
    
    <content type="html"><![CDATA[<h1 id="안드로이드-프레임워크-개선"><a href="#안드로이드-프레임워크-개선" class="headerlink" title="[안드로이드 프레임워크 개선]"></a>[안드로이드 프레임워크 개선]</h1><h2 id="PackageManager4"><a href="#PackageManager4" class="headerlink" title="PackageManager4"></a>PackageManager4</h2><h3 id="역할-분담"><a href="#역할-분담" class="headerlink" title="역할 분담"></a>역할 분담</h3><p>지난주 코드 분석을 통해서 우리는 PackageManagerService.java의 <strong>scanPackageDirtyLI</strong> 메소드, <strong>PackageParser.java</strong> 를 집중적으로 봐야겠다고 파악했다.<br>PackageManagerService.java 에서 PackageParser.java를 부르기 때문에, PackageParser.java를 먼저 보기로 했고, 1차적으로 다음과 같이 분담하여 분석을 하기로 했다.  </p><ol><li>parsePermission, parsePermissiongroup, parsePermissiontree  </li><li>parseActivity, parseActivityalias, parseProvider  </li><li>parseService, parsePackage, parseInstrumentation</li></ol><p>의 메소드를 중에서 나는 3번 service, package, instrumentation 메소드 리뷰를 맡았다.  </p><h3 id="PackageParser-java-분석"><a href="#PackageParser-java-분석" class="headerlink" title="PackageParser.java 분석"></a>PackageParser.java 분석</h3><p>Version : android-6.0.1_r77<br>PackageParser.java  </p><p>소스 코드 : <a href="https://android.googlesource.com/platform/frameworks/base/+/refs/tags/android-6.0.1_r77/core/java/android/content/pm/PackageParser.java">https://android.googlesource.com/platform/frameworks/base/+/refs/tags/android-6.0.1_r77/core/java/android/content/pm/PackageParser.java</a>  </p><p>위 9개의 메소드가 아래와 같이 동일한 형태를 보였다.  </p><h4 id="1-parseService-메소드"><a href="#1-parseService-메소드" class="headerlink" title="1. parseService 메소드"></a>1. parseService 메소드</h4><p>Line : 3779 ~ 3899  </p><p>해당 메소드는 새로운 Service 객체인 s를 생성하여 s의 info 값의 exported, permission, flags, processName을 설정하고 마지막에 s를 리턴한다.<br>(인자로 받은 패키지가 Heavy-weight applications이면 메인 프로세스에서 서비스할 수 없다는 에러를 가짐)  </p><h4 id="2-parsePackage-메소드"><a href="#2-parsePackage-메소드" class="headerlink" title="2. parsePackage 메소드"></a>2. parsePackage 메소드</h4><p>Line : 752 ~ 758  </p><p>해당 메소드는 인자로 받은 packageFile이 있으면(디렉토리가 존재하면) parseClusterPackage를 실행하고, 존재하지 않으면 parseMonolithicPackage를 실행한다.  </p><h5 id="2-1-parseClusterPackage-메소드"><a href="#2-1-parseClusterPackage-메소드" class="headerlink" title="2-1. parseClusterPackage 메소드"></a>2-1. parseClusterPackage 메소드</h5><p>Line : 769 ~ 814  </p><p>주어진 디렉토리를 받아 처리한다.  </p><p>해당 메소드는 Core App일 경우에만 동작하며, 패키지 이름, 버전 코드, base APK, split names(패키지 명 나눈 것)을 검사 후 Package를 리턴한다.  </p><h5 id="2-2-parseMonolithicPackage-메소드"><a href="#2-2-parseMonolithicPackage-메소드" class="headerlink" title="2-2. parseMonolithicPackage 메소드"></a>2-2. parseMonolithicPackage 메소드</h5><p>Line : 827 ~ 834  </p><p>2-1과 다르게 주어진 APK파일을 받아 처리한다.  </p><p>해당 메소드는 Core App일 경우에만 동작하며, parseBaseApk를 통해 얻은 Package를 리턴한다.  </p><h4 id="3-parseInstrumentation-메소드"><a href="#3-parseInstrumentation-메소드" class="headerlink" title="3. parseInstrumentation 메소드"></a>3. parseInstrumentation 메소드</h4><p>Line : 2339 ~ 2397  </p><p>안드로이드에서 Instrumentation는 테스트 중인 어플리케이션을 컨트롤 하고 상태를 확인할 수 있도록 제공하는 프레임워크 라고한다.  </p><p>해당 메소드는 Instrumentation인 a를 생성해서targetPackage, handleProfiling, functionalTest 값을 채워 에러가 없는경우 a를 리턴하고 에러가 있는경우 null을 리턴한다.  </p><h3 id="빌드-후-플래싱-재시도"><a href="#빌드-후-플래싱-재시도" class="headerlink" title="빌드 후 플래싱 재시도"></a>빌드 후 플래싱 재시도</h3><p>지난번 빌드에서 제대로 빌드하여 디바이스에 플래싱 되었는지 제대로 확인할 수 없었다.<br>빌드가 제대로 확인되었는지 보기 위해 PackageManagerService.java의 scanDirLI메소드의 Log를 이용하여 확인했다.  </p><p><img src="/images/post/PM4_1.png" alt="PM4_1" title="PM4_1">  </p><p>DEBUG_PACKAGE_SCANNING 플래그 부분의 if문을 벗겨내고, TEST용 로그를 추가하여 재빌드했다.  </p><p><img src="/images/post/PM4_2.png" alt="PM4_2" title="PM4_2">  </p><p>로그를 확인해보니, 아래와 같이 정상적으로 출력이 되었다. 빌드와 플래싱이 제대로 되는 것을 확인할 수 있었다.  </p><p><img src="/images/post/PM4_3.png" alt="PM4_3" title="PM4_3">  </p><h3 id="scanPackageDirtyLI-메소드-분석-및-향후-계획"><a href="#scanPackageDirtyLI-메소드-분석-및-향후-계획" class="headerlink" title="scanPackageDirtyLI 메소드 분석 및 향후 계획"></a>scanPackageDirtyLI 메소드 분석 및 향후 계획</h3><p>현재 scanPackageDirtyLI 메소드를 정밀하게 분석하기 위해 다음과 같이 주석을 달아놓은 상태이다.  </p><p><img src="/images/post/PM4_4.png" alt="PM4_4" title="PM4_4">  </p><p>PackageParser.java를 일부만 봤을 때는 특별한 점이나 개선해야 할 부분이 있는지 확인하지 못했다.<br>플래싱이 제대로 되는것을 확인했기 때문에 먼저 scanPackageDirtyLI 메소드를 정밀하게 분석하고 개선할 사항이 있는지 분석할 예정이다.  </p>]]></content>
    
    
    <categories>
      
      <category>Android</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Android</tag>
      
      <tag>안드로이드 프레임워크 개선</tag>
      
      <tag>PackageManager</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[안드로이드 프레임워크 개선] - PackageManager3</title>
    <link href="/PackageManager3/"/>
    <url>/PackageManager3/</url>
    
    <content type="html"><![CDATA[<h1 id="안드로이드-프레임워크-개선"><a href="#안드로이드-프레임워크-개선" class="headerlink" title="[안드로이드 프레임워크 개선]"></a>[안드로이드 프레임워크 개선]</h1><h2 id="PackageManager3"><a href="#PackageManager3" class="headerlink" title="PackageManager3"></a>PackageManager3</h2><h3 id="역할-분담"><a href="#역할-분담" class="headerlink" title="역할 분담"></a>역할 분담</h3><p>우리는 지난주에 이어 빌드한 내용을 넥서스 5 디바이스에 플래싱 하기로 하였다.<br>우여곡절 끝에 플래싱 한 디바이스는 벽돌이 되어서, 일단 역할 분담을 하고 프로젝트를 계속 진행하기로 하였다.  </p><ol><li>넥서스 5 플래싱 진행.  </li><li>PackageManagerService.java의 생성자 파트 코드 리뷰.  </li><li>‘DEBUG_PACKAGE_SCANNING’ 플래그가 포함된 파트 리뷰.</li></ol><p>이 중에서 나는 3번 ‘DEBUG_PACKAGE_SCANNING’ 플래그가 포함된 파트 리뷰를 맡았다.  </p><h3 id="코드-분석"><a href="#코드-분석" class="headerlink" title="코드 분석"></a>코드 분석</h3><p>Version : android-6.0.1_r77<br>PackageManagerService.java  </p><p>소스 코드 : <a href="https://android.googlesource.com/platform/frameworks/base/+/refs/tags/android-6.0.1_r77/services/core/java/com/android/server/pm/PackageManagerService.java">https://android.googlesource.com/platform/frameworks/base/+/refs/tags/android-6.0.1_r77/services/core/java/com/android/server/pm/PackageManagerService.java</a>  </p><p>DEBUG_PACKAGE_SCANNING 플래그는 2개의 메소드안에서 다루어지고 있다.  </p><h4 id="1-scanDirLI-메소드"><a href="#1-scanDirLI-메소드" class="headerlink" title="1. scanDirLI 메소드"></a>1. scanDirLI 메소드</h4><p>Line : 5625 ~ 5662   </p><p><strong>scanDirLI</strong>는 <strong>PackageManagerService</strong>에서 패키지들을 synchronized 할 때 사용된다.  </p><p>해당 메소드는 directory 내의 package를 확인한 후 package별로 <strong>scanPackageLI</strong>를 수행하며, 인스톨에 실패한 invalid package를 삭제한다.  </p><p>DEBUG_PACKAGE_SCANNING 플래그가 true일 경우에는 스캐닝 중인 app의 directory, scanFlags, parseFlags를 로그로 출력한다.  </p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs gradle"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> scanDirLI(<span class="hljs-keyword">File</span> dir, <span class="hljs-keyword">int</span> parseFlags, <span class="hljs-keyword">int</span> scanFlags, <span class="hljs-keyword">long</span> currentTime) &#123;<br>    <span class="hljs-keyword">final</span> <span class="hljs-keyword">File</span>[] files = dir.listFiles();<br>    <span class="hljs-keyword">if</span> (ArrayUtils.isEmpty(files)) &#123;<br>        Log.d(TAG, <span class="hljs-string">&quot;No files in app dir &quot;</span> + dir);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>     <span class="hljs-comment">//  Scanning 로그 출력  //</span><br>    <span class="hljs-keyword">if</span> (DEBUG_PACKAGE_SCANNING) &#123;<br>        Log.d(TAG, <span class="hljs-string">&quot;Scanning app dir &quot;</span> + dir + <span class="hljs-string">&quot; scanFlags=&quot;</span> + scanFlags<br>                + <span class="hljs-string">&quot; flags=0x&quot;</span> + Integer.toHexString(parseFlags));<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">File</span> <span class="hljs-keyword">file</span> : files) &#123;<br>        <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> isPackage = (isApkFile(<span class="hljs-keyword">file</span>) || <span class="hljs-keyword">file</span>.isDirectory())<br>                &amp;&amp; !PackageInstallerService.isStageName(<span class="hljs-keyword">file</span>.getName());<br>        <span class="hljs-keyword">if</span> (!isPackage) &#123;<br>            <span class="hljs-comment">// Ignore entries which are not packages</span><br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br>        <span class="hljs-keyword">try</span> &#123;<br>            scanPackageLI(<span class="hljs-keyword">file</span>, parseFlags | PackageParser.PARSE_MUST_BE_APK,<br>                    scanFlags, currentTime, <span class="hljs-keyword">null</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (PackageManagerException e) &#123;<br>            Slog.w(TAG, <span class="hljs-string">&quot;Failed to parse &quot;</span> + <span class="hljs-keyword">file</span> + <span class="hljs-string">&quot;: &quot;</span> + e.getMessage());<br>            <span class="hljs-comment">// Delete invalid userdata apps</span><br>            <span class="hljs-keyword">if</span> ((parseFlags &amp; PackageParser.PARSE_IS_SYSTEM) == <span class="hljs-number">0</span> &amp;&amp;<br>                    e.error == PackageManager.INSTALL_FAILED_INVALID_APK) &#123;<br>                logCriticalInfo(Log.WARN, <span class="hljs-string">&quot;Deleting invalid package at &quot;</span> + <span class="hljs-keyword">file</span>);<br>                <span class="hljs-keyword">if</span> (<span class="hljs-keyword">file</span>.isDirectory()) &#123;<br>                    mInstaller.rmPackageDir(<span class="hljs-keyword">file</span>.getAbsolutePath());<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    <span class="hljs-keyword">file</span>.<span class="hljs-keyword">delete</span>();<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="2-scanPackageDirtyLI-메소드"><a href="#2-scanPackageDirtyLI-메소드" class="headerlink" title="2. scanPackageDirtyLI 메소드"></a>2. scanPackageDirtyLI 메소드</h4><p>Line : 6482 ~ 7545  </p><p><strong>scanPackageDirtyLI</strong>는 <strong>scanPackageLI</strong>에서 부르며, <strong>scanPackageLI</strong>는 <strong>scanDirLI</strong>에서 부른다.  </p><p>해당 메소드는 인자로 받은 package를 분석하여 다시 return한다.<br>(분석 내용은 패키지 업데이트 여부, codePath, partition(system partition or data partition), certificate, 버전 체크 등등)  </p><p>DEBUG_PACKAGE_SCANNING 플래그가 true일 경우에는 다음을 로그로 출력한다.<br><em>line 6545 - 스캐닝 중인 app의 name</em><br><em>line 6572 - PackageSetting 값이 있을 때, Package의 codePath, 세팅값의 codePathString, resourcePathString</em><br><em>line 6611 - Package의 mSharedUserId가 null이 아닌 경우, Package의 mSharedUserId, 세팅값의 userId, packages</em><br><em>line 6939 - normal package이며 해당 directory가 존재하지 않을 경우</em><br><em>line 7259 - Package의 Provider가 존재할때? provider 이름, info name, Syncable한지</em><br><em>line 7285 - Providers의 info.name</em><br><em>line 7305 - Services의 info.name</em><br><em>line 7325 - receivers의 info.name</em><br><em>line 7345 - activities의 info.name</em><br><em>line 7379 - permissionGroups의 info.name</em><br><em>line 7480 - Permissions의 info.name</em><br><em>line 7508 - Instrumentation의 info.name</em>   </p><p>아래 코드는 내용이 많기 때문에, DEBUG_PACKAGE_SCANNING 플래그가 포함된 부분만 발췌  </p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br></pre></td><td class="code"><pre><code class="hljs gradle"><span class="hljs-keyword">private</span> PackageParser.<span class="hljs-keyword">Package</span> scanPackageDirtyLI(PackageParser.<span class="hljs-keyword">Package</span> pkg, <span class="hljs-keyword">int</span> parseFlags,<br>        <span class="hljs-keyword">int</span> scanFlags, <span class="hljs-keyword">long</span> currentTime, UserHandle user) <span class="hljs-keyword">throws</span> PackageManagerException &#123;<br>    <span class="hljs-comment">//  Scanning 로그 출력  //</span><br>    <span class="hljs-keyword">if</span> (DEBUG_PACKAGE_SCANNING) &#123;<br>      <span class="hljs-keyword">if</span> ((parseFlags &amp; PackageParser.PARSE_CHATTY) != <span class="hljs-number">0</span>) <span class="hljs-comment">// PackageParser</span><br>          Log.d(TAG, <span class="hljs-string">&quot;Scanning package &quot;</span> + pkg.packageName);<br>    &#125;<br><br>    :<br>    :<br><br>    <span class="hljs-keyword">if</span> ((scanFlags &amp; SCAN_REQUIRE_KNOWN) != <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">if</span> (mExpectingBetter.containsKey(pkg.packageName)) &#123;<br>            logCriticalInfo(Log.WARN,<br>                    <span class="hljs-string">&quot;Relax SCAN_REQUIRE_KNOWN requirement for package &quot;</span> + pkg.packageName);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            PackageSetting known = mSettings.peekPackageLPr(pkg.packageName);<br>            <span class="hljs-keyword">if</span> (known != <span class="hljs-keyword">null</span>) &#123;<br>                <span class="hljs-comment">//  Scanning 로그 출력  //</span><br>                <span class="hljs-keyword">if</span> (DEBUG_PACKAGE_SCANNING) &#123;<br>                    Log.d(TAG, <span class="hljs-string">&quot;Examining &quot;</span> + pkg.codePath<br>                            + <span class="hljs-string">&quot; and requiring known paths &quot;</span> + known.codePathString<br>                            + <span class="hljs-string">&quot; &amp; &quot;</span> + known.resourcePathString);<br>                &#125;<br>                <span class="hljs-keyword">if</span> (!pkg.applicationInfo.getCodePath().equals(known.codePathString)<br>                        || !pkg.applicationInfo.getResourcePath().equals(known.resourcePathString)) &#123;<br>                    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> PackageManagerException(INSTALL_FAILED_PACKAGE_CHANGED,<br>                            <span class="hljs-string">&quot;Application package &quot;</span> + pkg.packageName<br>                            + <span class="hljs-string">&quot; found at &quot;</span> + pkg.applicationInfo.getCodePath()<br>                            + <span class="hljs-string">&quot; but expected at &quot;</span> + known.codePathString + <span class="hljs-string">&quot;; ignoring.&quot;</span>);<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    :<br>    :<br><br>    <span class="hljs-keyword">synchronized</span> (mPackages) &#123;<br>        <span class="hljs-keyword">if</span> (pkg.mSharedUserId != <span class="hljs-keyword">null</span>) &#123;<br>            suid = mSettings.getSharedUserLPw(pkg.mSharedUserId, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-keyword">true</span>);<br>            <span class="hljs-keyword">if</span> (suid == <span class="hljs-keyword">null</span>) &#123;<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> PackageManagerException(INSTALL_FAILED_INSUFFICIENT_STORAGE,<br>                        <span class="hljs-string">&quot;Creating application package &quot;</span> + pkg.packageName<br>                        + <span class="hljs-string">&quot; for shared user failed&quot;</span>);<br>            &#125;<br>            <span class="hljs-comment">//  Scanning 로그 출력  //</span><br>            <span class="hljs-keyword">if</span> (DEBUG_PACKAGE_SCANNING) &#123;<br>                <span class="hljs-keyword">if</span> ((parseFlags &amp; PackageParser.PARSE_CHATTY) != <span class="hljs-number">0</span>) <span class="hljs-comment">// PackageParser</span><br>                    Log.d(TAG, <span class="hljs-string">&quot;Shared UserID &quot;</span> + pkg.mSharedUserId + <span class="hljs-string">&quot; (uid=&quot;</span> + suid.userId<br>                            + <span class="hljs-string">&quot;): packages=&quot;</span> + suid.packages);<br>            &#125;<br>        &#125;<br><br>        :<br>        :<br>    &#125;<br><br>    :<br>    :<br><br>    <span class="hljs-keyword">if</span> (mPlatformPackage == pkg) &#123;<br>        <span class="hljs-comment">// The system package is special.</span><br>        dataPath = <span class="hljs-keyword">new</span> <span class="hljs-keyword">File</span>(Environment.getDataDirectory(), <span class="hljs-string">&quot;system&quot;</span>);<br>        pkg.applicationInfo.dataDir = dataPath.getPath();<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-comment">// This is a normal package, need to make its data directory.</span><br>      dataPath = Environment.getDataUserPackageDirectory(pkg.volumeUuid,<br>              UserHandle.USER_OWNER, pkg.packageName);<br>      <span class="hljs-keyword">boolean</span> uidError = <span class="hljs-keyword">false</span>;<br>      <span class="hljs-keyword">if</span> (dataPath.exists()) &#123;<br><br>        :<br>        :<br><br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">//  Scanning 로그 출력  //</span><br>            <span class="hljs-keyword">if</span> (DEBUG_PACKAGE_SCANNING) &#123;<br>                <span class="hljs-keyword">if</span> ((parseFlags &amp; PackageParser.PARSE_CHATTY) != <span class="hljs-number">0</span>) <span class="hljs-comment">// PackageParser</span><br>                    Log.v(TAG, <span class="hljs-string">&quot;Want this data dir: &quot;</span> + dataPath);<br>            &#125;<br>            <span class="hljs-comment">//invoke installer to do the actual installation</span><br>            <span class="hljs-keyword">int</span> ret = createDataDirsLI(pkg.volumeUuid, pkgName, pkg.applicationInfo.uid,<br>                    pkg.applicationInfo.seinfo);<br>            <span class="hljs-keyword">if</span> (ret &lt; <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-comment">// Error from installer</span><br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> PackageManagerException(INSTALL_FAILED_INSUFFICIENT_STORAGE,<br>                        <span class="hljs-string">&quot;Unable to create data dirs [errorCode=&quot;</span> + ret + <span class="hljs-string">&quot;]&quot;</span>);<br>            &#125;<br>            <span class="hljs-keyword">if</span> (dataPath.exists()) &#123;<br>                pkg.applicationInfo.dataDir = dataPath.getPath();<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                Slog.w(TAG, <span class="hljs-string">&quot;Unable to create data directory: &quot;</span> + dataPath);<br>                pkg.applicationInfo.dataDir = <span class="hljs-keyword">null</span>;<br>            &#125;<br>        &#125;<br><br><br>    :<br>    :<br><br>    <span class="hljs-comment">// writer</span><br>    <span class="hljs-keyword">synchronized</span> (mPackages) &#123;<br>        <span class="hljs-comment">// We don&#x27;t expect installation to fail beyond this point</span><br><br>        :<br>        :<br><br>        <span class="hljs-keyword">int</span> N = pkg.providers.<span class="hljs-keyword">size</span>();<br>        StringBuilder r = <span class="hljs-keyword">null</span>;<br>        <span class="hljs-keyword">int</span> i;<br>        <span class="hljs-keyword">for</span> (i=<span class="hljs-number">0</span>; i&lt;N; i++) &#123;<br><br>          :<br>          :<br><br>          String names[] = p.info.authority.split(<span class="hljs-string">&quot;;&quot;</span>);<br>          p.info.authority = <span class="hljs-keyword">null</span>;<br>          <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; names.length; j++) &#123;<br><br>            :<br>            :<br><br>            <span class="hljs-keyword">if</span> (!mProvidersByAuthority.containsKey(names[j])) &#123;<br>                mProvidersByAuthority.put(names[j], p);<br>                <span class="hljs-keyword">if</span> (p.info.authority == <span class="hljs-keyword">null</span>) &#123;<br>                    p.info.authority = names[j];<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    p.info.authority = p.info.authority + <span class="hljs-string">&quot;;&quot;</span> + names[j];<br>                &#125;<br>                <span class="hljs-comment">//  Scanning 로그 출력  //</span><br>                <span class="hljs-keyword">if</span> (DEBUG_PACKAGE_SCANNING) &#123;<br>                    <span class="hljs-keyword">if</span> ((parseFlags &amp; PackageParser.PARSE_CHATTY) != <span class="hljs-number">0</span>) <span class="hljs-comment">// PackageParser</span><br>                        Log.d(TAG, <span class="hljs-string">&quot;Registered content provider: &quot;</span> + names[j]<br>                                + <span class="hljs-string">&quot;, className = &quot;</span> + p.info.name + <span class="hljs-string">&quot;, isSyncable = &quot;</span><br>                                + p.info.isSyncable);<br>                &#125;<br>            &#125;<br>          &#125;<br>        &#125;<br><br>        <span class="hljs-comment">//  Scanning 로그 출력  //</span><br>        <span class="hljs-keyword">if</span> (r != <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-keyword">if</span> (DEBUG_PACKAGE_SCANNING) Log.d(TAG, <span class="hljs-string">&quot;  Providers: &quot;</span> + r);<br>        &#125;<br><br>        N = pkg.services.<span class="hljs-keyword">size</span>();<br>        r = <span class="hljs-keyword">null</span>;<br>        <span class="hljs-keyword">for</span> (i=<span class="hljs-number">0</span>; i&lt;N; i++) &#123;<br>            PackageParser.Service s = pkg.services.get(i); <span class="hljs-comment">// PackageParser</span><br>            s.info.processName = fixProcessName(pkg.applicationInfo.processName,<br>                    s.info.processName, pkg.applicationInfo.uid);<br>            mServices.addService(s);<br>            <span class="hljs-keyword">if</span> ((parseFlags&amp;PackageParser.PARSE_CHATTY) != <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-keyword">if</span> (r == <span class="hljs-keyword">null</span>) &#123;<br>                    r = <span class="hljs-keyword">new</span> StringBuilder(<span class="hljs-number">256</span>);<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    r.<span class="hljs-keyword">append</span>(<span class="hljs-string">&#x27; &#x27;</span>);<br>                &#125;<br>                r.<span class="hljs-keyword">append</span>(s.info.name);<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-comment">//  Scanning 로그 출력  //</span><br>        <span class="hljs-keyword">if</span> (r != <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-keyword">if</span> (DEBUG_PACKAGE_SCANNING) Log.d(TAG, <span class="hljs-string">&quot;  Services: &quot;</span> + r);<br>        &#125;<br><br>        :<br>        :<br><br>        <span class="hljs-comment">//  이런식으로 Receivers, Activities, Permission Groups, Permissions, Instrumentation로그 출력   //</span><br><br>        :<br>        :<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>전체적인 흐름을 보았는데, 스캐닝에 관련된 내용 중 개선을 한다면 <strong>scanPackageDirtyLI</strong> 부분을 더 보거나<br>PackageParser의 내용이 많이 나오는데, <strong>PackageParser.java</strong>를 정밀하게 보는 것이 좋을 것 같다.  </p><h3 id="디바이스-플래싱"><a href="#디바이스-플래싱" class="headerlink" title="디바이스 플래싱"></a>디바이스 플래싱</h3><p>보유하고 있는 기기인 넥서스 5에 플래싱 완료하였다.  </p><p><img src="/images/post/PM3_1.png" alt="PM3_1" title="PM3_1">  </p><p>다음에는 이전에 사용하려고 했던 갤럭시 A8 (SM-A800S)도 순정 펌웨어를 받아 플래싱 해보려고 한다.  </p>]]></content>
    
    
    <categories>
      
      <category>Android</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Android</tag>
      
      <tag>안드로이드 프레임워크 개선</tag>
      
      <tag>PackageManager</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[안드로이드 프레임워크 개선] - PackageManager2</title>
    <link href="/PackageManager2/"/>
    <url>/PackageManager2/</url>
    
    <content type="html"><![CDATA[<h1 id="안드로이드-프레임워크-개선"><a href="#안드로이드-프레임워크-개선" class="headerlink" title="[안드로이드 프레임워크 개선]"></a>[안드로이드 프레임워크 개선]</h1><h2 id="PackageManager2"><a href="#PackageManager2" class="headerlink" title="PackageManager2"></a>PackageManager2</h2><h3 id="디바이스-선정"><a href="#디바이스-선정" class="headerlink" title="디바이스 선정"></a>디바이스 선정</h3><p>지난주 adb shell과 안드로이드 스튜디오를 통한 logcat을 출력할 때는 갤럭시 A8 2016 (SM-A800S) 기기를 임시로 사용하였다.  </p><p>팀원들과 회의 결과 코드를 수정하고 빌드하는 데 구글 레퍼런스 디바이스를 사용하는 것이 좋다고 판단하였다.<br>우리가 개선하고자 하는 안드로이드 버전은 6.0.1 버전으로 현재 보유하고 있는 갤럭시 넥서스는 해당 버전을 지원하지 않았다.  </p><p>우리는 넥서스 5를 테스트 및 개선을 위한 디바이스로 선정하였고, 앞으로 해당 디바이스를 통해 개선을 진행한다.  </p><p>운영체제 및 버전 : Android 6.0.1_r77  </p><h3 id="빌드-환경-구성"><a href="#빌드-환경-구성" class="headerlink" title="빌드 환경 구성"></a>빌드 환경 구성</h3><p>빌드 환경 구성은 아래의 블로그를 참고했다.<br><a href="https://gamdekong.tistory.com/55?category=763105">https://gamdekong.tistory.com/55?category=763105</a>  </p><h4 id="repo-설치"><a href="#repo-설치" class="headerlink" title="repo 설치"></a>repo 설치</h4><p>보유하고 있는 넥서스 5에 포팅하기 위한 android-6.0.1_r77 버전의 AOSP 소스를 받아온다.  </p><p><img src="/images/post/PM2_1.png" alt="PM2_1" title="PM2_1">  </p><p>소스를 받아온 후 빌드하기 위한 프로그램을 설치하고, mk파일을 수정한다.  </p><h4 id="빌드-make"><a href="#빌드-make" class="headerlink" title="빌드(make)"></a>빌드(make)</h4><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">make</span><br></code></pre></td></tr></table></figure><p>명령어를 통해 빌드를 수행한다.  </p><p><img src="/images/post/PM2_2.png" alt="PM2_2" title="PM2_2">  </p><p>빌드 완료 후 에뮬레이터를 실행한다.<br>나와 같은 경우는 터미널이 바로 꺼지는 경우가 발생해서, 구동 시 마다 환경 설정을 다시 했다.  </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">source</span> build/envsetup.sh<br>lunch aosp_arm-eng<br>emulator &amp;<br></code></pre></td></tr></table></figure><p><img src="/images/post/PM2_3.png" alt="PM2_3" title="PM2_3">  </p><h3 id="코드-수정-및-빌드"><a href="#코드-수정-및-빌드" class="headerlink" title="코드 수정 및 빌드"></a>코드 수정 및 빌드</h3><p>우리는 PackageManager 부분의 Package Scanning 시간을 줄이는 방식을 통해 개선을 수행하고자 하기 때문에, Scanning log를 보기위해 PackageManagerService.java 코드를 수정 후 빌드해야 한다.  </p><p><a href="https://android.googlesource.com/platform/frameworks/base/+/a029ea1/services/java/com/android/server/pm/PackageManagerService.java#189">https://android.googlesource.com/platform/frameworks/base/+/a029ea1/services/java/com/android/server/pm/PackageManagerService.java#189</a> 소스를 보게 되면,  </p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-keyword">private</span> <span class="hljs-type">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> DEBUG_PACKAGE_SCANNING = <span class="hljs-literal">false</span>;<br></code></pre></td></tr></table></figure><p>의 DEBUG flag값이 있다. 이 값을 true로 해놓고 빌드해서 올려 package scanning에 관련된 로그를 확인하는 것이 목표이다.  </p><p>다음과 같이 수정 후 make 명령어를 통해 빌드 하였다.  </p><p><img src="/images/post/PM2_4.png" alt="PM2_4" title="PM2_4">  </p><h3 id="Scanning-결과"><a href="#Scanning-결과" class="headerlink" title="Scanning 결과"></a>Scanning 결과</h3><p>디바이스에 올려서 확인하기 전, 우선 에뮬레이터를 이용해서 로그값을 확인했다.  </p><p><img src="/images/post/PM2_5.png" alt="PM2_5" title="PM2_5">  </p><p><img src="/images/post/PM2_6.png" alt="PM2_6" title="PM2_6">  </p><p>Scanning에 관련된 로그들이 출력된 것을 확인할 수 있었다.  </p><p>하지만 PackageManagerService.java 코드를 살펴보니, Scanning에 관련된 다른 로그들도 출력되어야 할 것 같은데, 다른 로그들은 출력되지 않았다.  </p><h4 id="더-찾아봐야-할-로그들"><a href="#더-찾아봐야-할-로그들" class="headerlink" title="더 찾아봐야 할 로그들"></a>더 찾아봐야 할 로그들</h4><p>DEBUG flag값을 따라서 어떤 로그들이 출력되어야 하는지 확인해보았다.  </p><p>DEBUG_PACKAGE_SCANNING을 true로 변경했기 때문에, 관련 조건문에 있는 로그들은 다음과 같다.  </p><ul><li>Log.d(TAG, “Scanning app dir “ + dir + “ scanMode&#x3D;” + scanMode + “ flags&#x3D;0x” + Integer.toHexString(flags));  </li><li>Log.d(TAG, “Scanning package “ + pkg.packageName);  </li><li>Log.d(TAG, “Shared UserID “ + pkg.mSharedUserId + “ (uid&#x3D;” + suid.userId + “): packages&#x3D;” + suid.packages);  </li><li>Log.v(TAG, “Want this data dir: “ + dataPath);  </li><li>Log.d(TAG, “Registered content provider: “ + names[j] + “, className &#x3D; “ + p.info.name + “, isSyncable &#x3D; “ + p.info.isSyncable);  </li><li>Log.d(TAG, “  Providers: “ + r);  </li><li>Log.d(TAG, “  Services: “ + r);  </li><li>Log.d(TAG, “  Receivers: “ + r);  </li><li>Log.d(TAG, “  Activities: “ + r);  </li><li>Log.d(TAG, “  Permission Groups: “ + r);  </li><li>Log.d(TAG, “  Permissions: “ + r);  </li><li>Log.d(TAG, “  Instrumentation: “ + r);</li></ul>]]></content>
    
    
    <categories>
      
      <category>Android</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Android</tag>
      
      <tag>안드로이드 프레임워크 개선</tag>
      
      <tag>PackageManager</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[안드로이드 프레임워크 개선] - PackageManager</title>
    <link href="/PackageManager1/"/>
    <url>/PackageManager1/</url>
    
    <content type="html"><![CDATA[<h1 id="안드로이드-프레임워크-개선"><a href="#안드로이드-프레임워크-개선" class="headerlink" title="[안드로이드 프레임워크 개선]"></a>[안드로이드 프레임워크 개선]</h1><h2 id="PackageManager"><a href="#PackageManager" class="headerlink" title="PackageManager"></a>PackageManager</h2><h3 id="주제-선정"><a href="#주제-선정" class="headerlink" title="주제 선정"></a>주제 선정</h3><p>지난 학기 동안 ‘인사이드 안드로이드’ 책을 통해서 안드로이드의 구조에 대해서 전반적으로 파악하는 시간을 가졌다.<br>또한 6월 1일에 진행되었던, 이원영 선배님께서 멘토링을 통하여 Common Framework에 대한 내용과 개선을 어떻게 진행하면 좋을지에 대하여 다루어 주셨다.<br>우리 팀은 이를 종합하여 기존에 설정하였던 전반적인 안드로이드 개선에 대한 주제를 구체화하기로 했다.  </p><h4 id="부팅시간-개선"><a href="#부팅시간-개선" class="headerlink" title="부팅시간 개선"></a>부팅시간 개선</h4><p>우리는 부팅시간 개선이라는 주제를 선정하였다.<br>이를 위하여 여러 가지 방법이 있겠지만, 부팅시간에 영향을 줄만한 Package Scanning 시간을 줄이는 것을 세부 목표로 잡았다.<br>Scanning 시간을 줄이기 위해서 PackageManager 쪽 코드를 공부해보고 Package Scanning 시간에 불필요한 Scanning을 하는지를 알아보려고 한다.  </p><h5 id="부팅-로그-출력"><a href="#부팅-로그-출력" class="headerlink" title="부팅 로그 출력"></a>부팅 로그 출력</h5><p>먼저, 부팅 시에 Package Scanning에 대한 흐름을 보아야 한다.<br>단말기를 재부팅시키고 로그를 확인해보는 과정을 가졌다.  </p><p>이를 확인하고자 하는 단말기는 갤럭시 A8 2016 (SM-A800S)으로, 6.0.1 버전으로 다운그레이드 하였다.<br>먼저, 안드로이드 스튜디오의 Logcat기능을 통해서 로그를 확인해보았다.<br>PackageManager로 태그를 걸어 PackageManager부분만 확인한 결과는 다음과 같다.  </p><p><img src="/images/post/PM1_1.png" alt="PM1_1" title="PM1_1">  </p><p>이 방법을 사용할 때는 단말기가 꺼져있을 때 오프라인으로 되어있어, 부팅 중 로그를 출력하지 못하는 것 같다.  </p><p>다음 방법으로 adb shell을 이용하여 로그를 출력해보았다.  </p><p><img src="/images/post/PM1_2.png" alt="PM1_2" title="PM1_2">  </p><p>안드로이드 구조를 공부했던 것 처럼 먼저 start init process 부분이 있었다.<br>더 내려가서 확인해보니, 우리가 확인해야할 부분인 PackageManager 부분을 확인할 수 있었다.  </p><p><img src="/images/post/PM1_3.png" alt="PM1_3" title="PM1_3">  </p><p>Start PackageManagerService  </p><p><img src="/images/post/PM1_4.png" alt="PM1_4" title="PM1_4">  </p><p>End PackageManagerService  </p><p>다음 주 부터는 로그를 확인하여 불필요한 Scanning이 있는지 분석할 예정이다.  </p><h5 id="adb-shell-명령어"><a href="#adb-shell-명령어" class="headerlink" title="adb shell 명령어"></a>adb shell 명령어</h5><p>adb shell의 명령어 같은 경우에는 안드로이드 개발자 문서에 설명되어 있다.  </p><p><a href="https://developer.android.com/studio/command-line/adb?hl=ko#shellcommands">https://developer.android.com/studio/command-line/adb?hl=ko#shellcommands</a>  </p><h3 id="Android-Package-Manager-and-Package-Installer"><a href="#Android-Package-Manager-and-Package-Installer" class="headerlink" title="Android Package Manager and Package Installer"></a>Android Package Manager and Package Installer</h3><p>원문 : <a href="http://kpbird.blogspot.com/2012/10/in-depth-android-package-manager-and.html">http://kpbird.blogspot.com/2012/10/in-depth-android-package-manager-and.html</a>  </p><h4 id="Package-Manager와-Package-Installer는-무엇인가"><a href="#Package-Manager와-Package-Installer는-무엇인가" class="headerlink" title="Package Manager와 Package Installer는 무엇인가?"></a>Package Manager와 Package Installer는 무엇인가?</h4><p>PackageInstaller는 Android에 Package를 설치하는 기본 Application이다.<br>PackageInstaller는 Application&#x2F;Package를 관리하기 위한 사용자 인터페이스를 제공한다.<br>PackageInstaller는 InstallAppProgress Activity를 호출해 사용자의 명령을 전달받는다.  </p><p>InstallAppProgress는 indalld를 통해 Package 설치를 Package Manager Service에게 요청한다.<br>소스코드는 <Android Source>&#x2F;packages&#x2F;apps&#x2F;PackageInstaller 에서 확인할 수 있다.  </p><p>installd 데몬의 가장 중요한 역할은 Linux 데몬 소켓인 &#x2F;dev &#x2F;socket &#x2F;installed를 통해 Package Manager Service로 부터 요청을 받는 것이다. installd는 Root Permission으로 APK 설치를 위한 단계를 수행하게 된다.<br>[Ref: <a href="https://github.com/android/platform_frameworks_base/blob/master/cmds/installd/commands.c]">https://github.com/android/platform_frameworks_base/blob/master/cmds/installd/commands.c]</a>  </p><p>PackageManager는 Application 설치, 삭제, 업그레이드를 위한 API이다.<br>APK파일을 설치할 때, PackageManager는 Package (APK) 파일을 분석해 확인창을 보여주고, OK 버튼을 누르면 PackageManager가 4개의 Parameter를 갖는 InstallPackage 메소드를 호출한다. (Paramter : uri, installFlags, observer, installPackageName)   PackageManager는 Package 서비스를 실행하고 Package 서비스에서 분산이 이루어진다.<br>PackageInstaller 소스코드의 “PackageInstallerActivity.java” 와 “InstallAppProgress.java”를 확인해 보자.<br>system_service 프로세스로 동작하는 Package Manager 서비스와 install 데몬 (installd)은 system 부팅 시점에 native process로 동작한다.  </p><h4 id="Package-Manager와-Package-Installer의-소스코드를-어디서-찾을-수-있는가"><a href="#Package-Manager와-Package-Installer의-소스코드를-어디서-찾을-수-있는가" class="headerlink" title="Package Manager와 Package Installer의 소스코드를 어디서 찾을 수 있는가?"></a>Package Manager와 Package Installer의 소스코드를 어디서 찾을 수 있는가?</h4><p>&lt; Package Manager &gt;<br>frameworks&#x2F;base&#x2F;services&#x2F;java&#x2F;com&#x2F;android&#x2F;server&#x2F;pm&#x2F;Settings.java<br>frameworks&#x2F;base&#x2F;services&#x2F;java&#x2F;com&#x2F;android&#x2F;server&#x2F;pm&#x2F;PackageManagerService.java<br>frameworks&#x2F;base&#x2F;services&#x2F;java&#x2F;com&#x2F;android&#x2F;server&#x2F;pm&#x2F;IPackageManager.aidl<br>frameworks&#x2F;base&#x2F;services&#x2F;java&#x2F;com&#x2F;android&#x2F;server&#x2F;pm&#x2F;PackageSignatures.java<br>frameworks&#x2F;base&#x2F;services&#x2F;java&#x2F;com&#x2F;android&#x2F;server&#x2F;pm&#x2F;PreferredActivity.java<br>frameworks&#x2F;services&#x2F;java&#x2F;com&#x2F;android&#x2F;server&#x2F;PreferredComponent.java<br>frameworks&#x2F;core&#x2F;java&#x2F;android&#x2F;content&#x2F;IntentFilter.java<br>frameworks&#x2F;base&#x2F;core&#x2F;java&#x2F;android&#x2F;content&#x2F;pm&#x2F;PackageParser.java<br>frameworks&#x2F;base&#x2F;services&#x2F;java&#x2F;com&#x2F;android&#x2F;server&#x2F;pm&#x2F;Installer.java<br>frameworks&#x2F;base&#x2F;core&#x2F;java&#x2F;com&#x2F;android&#x2F;internal&#x2F;app&#x2F;IMediaContainerService.aidl<br>frameworks&#x2F;base&#x2F;packages&#x2F;DefaultContainerService&#x2F;src&#x2F;com&#x2F;android&#x2F;defcontainer&#x2F;DefaultContainerService.java  </p><p>&lt; Package Installer &gt;<br>packages&#x2F;apps&#x2F;PackageInstaller&#x2F;src&#x2F;com&#x2F;android&#x2F;packageinstaller&#x2F;PackageInstallerActivity.java<br>packages&#x2F;apps&#x2F;PackageInstaller&#x2F;src&#x2F;com&#x2F;android&#x2F;packageinstaller&#x2F;PackageUtil.java<br>packages&#x2F;apps&#x2F;PackageInstaller&#x2F;src&#x2F;com&#x2F;android&#x2F;packageinstaller&#x2F;InstallAppProgress.java  </p>]]></content>
    
    
    <categories>
      
      <category>Android</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Android</tag>
      
      <tag>안드로이드 프레임워크 개선</tag>
      
      <tag>PackageManager</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[인사이드 안드로이드] 챕터 11 - 자바 시스템 서비스 동작 분석</title>
    <link href="/chapter11/"/>
    <url>/chapter11/</url>
    
    <content type="html"><![CDATA[<h1 id="인사이드-안드로이드"><a href="#인사이드-안드로이드" class="headerlink" title="[인사이드 안드로이드]"></a>[인사이드 안드로이드]</h1><h2 id="Chapter11-자바-시스템-서비스-동작-분석"><a href="#Chapter11-자바-시스템-서비스-동작-분석" class="headerlink" title="Chapter11 - 자바 시스템 서비스 동작 분석"></a>Chapter11 - 자바 시스템 서비스 동작 분석</h2><h3 id="액티비티-매니저-서비스"><a href="#액티비티-매니저-서비스" class="headerlink" title="액티비티 매니저 서비스"></a>액티비티 매니저 서비스</h3><p>액티비티 매니저 서비스는 자바 시스템 서비스의 일종인 코어 플랫폼 서비스로서 안드로이드 애플리케이션 컴포넌트인 액티비티, 서비스, 브로드캐스트 리시버등을 생성하고, 이들의 생명주기를 관리하는 역할을 한다.  </p><p>ApiDemos 예제 코드에 들어있는 Remote Service Controller 애플리케이션을 토대로 액티비티 매니저 서비스가 안드로이드의 애플리케이션 서비스를 어떻게 생성하고 해당 서비스의 생명주기를 어떻게 제어하는지 알아본다.  </p><p><img src="/images/post/JS1.png" alt="JS1" title="JS1">  </p><p>Remote Service Controller 예제 애플리케이션은 별도의 프로세스를 통해 리모트 서비스를 실행하는 예제로 ⑴ ‘Start Service’ 버튼을 누르면 ⑵ RemoteService가 시작되는 간단한 프로그램이다.  </p><p><img src="/images/post/JS2.png" alt="JS2" title="JS2">  </p><p>⑴ 안드로이드 애플리케이션은 startService()나 bindService() API를 통해 애플리케이션 서비스를 생성한다.<br>⑵ 애플리케이션으로부터 startService()를 통해 서비스 실행 요청을 받은 액티비 매니저 서비스는 요청받은 서비스 클래스(RemoteService.class)를 바로 로드하는 것이 아니라 Zygote에게 서비스를 실행시키기 위한 ActivityThread 생성을 요청한다.<br>⑶ 액티비티 매니저 서비스로부터 ActivityThread 실행을 요청받은 Zygote는 새로운 프로세스를 생성한 다음 그위에 ActivityThread 클래스를 로딩한다.<br>⑷ ActivityThread에게 RemoteService 서비스의 생성을 요청한다.<br>⑸ ActivityThread는 RemoteService를 실행한다.  </p><p>이렇듯 안드로이드의 액티비티 매니저 서비스는 애플리케이션 서비스를 포함한 액티비티, 브로드캐스트 리시버 같은 안드로이드 애플리케이션 컴포넌트를 생성하는 중요한 역할을 하는 시스템 서비스다.  </p><h3 id="액티비티-매니저-서비스를-통한-서비스-생성-코드-분석"><a href="#액티비티-매니저-서비스를-통한-서비스-생성-코드-분석" class="headerlink" title="액티비티 매니저 서비스를 통한 서비스 생성 코드 분석"></a>액티비티 매니저 서비스를 통한 서비스 생성 코드 분석</h3><p>액티비티가 startService() API 메서드를 호출할 경우 액티비티 매니저 서비스가 어떻게 애플리케이션 서비스를 생성하는지 소스 코드를 바탕으로 자세히 살펴보자  </p><h4 id="Controller-액티비티-startService-메서드-호출"><a href="#Controller-액티비티-startService-메서드-호출" class="headerlink" title="Controller 액티비티 - startService() 메서드 호출"></a>Controller 액티비티 - startService() 메서드 호출</h4><p>⑴과 같이 ‘Start Servcie’ 버튼을 누르면 코드 11-1의 이벤트 핸들러가 호출된다. 이 경우 단순히 인텐트(intent)를 인자로 startService() API 메서드를 호출한다.  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-type">OnClickListener</span> <span class="hljs-variable">mStartListener</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">OnClickListener</span>() &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onClick</span><span class="hljs-params">(View v)</span> &#123;<br>        startService(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Intent</span>(<span class="hljs-string">&quot;com.example.android.apis.app.REMOTE_SERVICE&quot;</span>));<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="액티비티-매니저-서비스의-startService-메서드-호출-과정-바인더-RPC-활용"><a href="#액티비티-매니저-서비스의-startService-메서드-호출-과정-바인더-RPC-활용" class="headerlink" title="액티비티 매니저 서비스의 startService() 메서드 호출 과정(바인더 RPC 활용)"></a>액티비티 매니저 서비스의 startService() 메서드 호출 과정(바인더 RPC 활용)</h4><p>액티비티에서 호출한 startService() API는 서비스 생성 및 실행과 관련된 내용을 액티비티 매니저 서비스에 요청하는 기능만 수행할 뿐 실제 구현은 액티비티 매니저 서비스에 속한, 동일한 이름을 가진 startService() 스텁 메서드에 들어 있다.  </p><p>즉, 액티비티에서 호출한 startService() API는 자바 서비스 프레임워크 기반에서 바인더 RPC 형태로 액티비티 매니저 서비스에서 제공하는 startService() 스텁 메서드를 호출하게 되는 것이다.  </p><p><img src="/images/post/JS3.png" alt="JS3" title="JS3">  </p><p>⑴ Controller 액티비티 - ActivityManagerProxy 객체의 startService() 프록시 메서드를 호출<br>⑵ ActivityManagerProxy 객체 - 자바 서비스 프레임워크를 통해 ActivityManagerNative 객체에 START_SERVICE_TRANSACTION RPC 코드와 바인더 RPC 데이터를 전송<br>⑶ ActivityManagerNative 객체 - ActivityManagerService에 포함된 startService() 스텁 메서드를 호출  </p><h5 id="⑴-Controller-액티비티"><a href="#⑴-Controller-액티비티" class="headerlink" title="⑴ Controller 액티비티"></a>⑴ Controller 액티비티</h5><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs scala">public <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ContextWrapper</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Context</span> </span>&#123;<br>    <span class="hljs-type">Context</span> mBase;<br><br>    public <span class="hljs-type">ComponentName</span> startService(<span class="hljs-type">Intent</span> service) &#123;<br>        <span class="hljs-keyword">return</span> mBase.startService(service); <span class="hljs-comment">// ContextImpl 객체의 startService() 메서드 호출</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>ContextWrapper는 context 추상 클래스를 확장한 클래스로 멤버 변수 mBase에 저장된 context 객체를 래핑(wrapping)하는 역할을 한다. 현재 ContextWrapper 객체는 그림에서 볼 수 있듯이 Controller 액티비티의 ContextImpl 객체를 래핑하고 있다.  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> ComponentName <span class="hljs-title function_">startService</span><span class="hljs-params">(Intent service)</span> &#123;<br>    <span class="hljs-type">ComponentName</span> <span class="hljs-variable">cn</span> <span class="hljs-operator">=</span> ActivityManagerNative.getDefault().startService(<br>                          mMainThread.getApplicationThread(), service,<br>                          service.resolveTypeIfNeeded(getContentResolver()));<br><br>    <span class="hljs-keyword">return</span> cn;<br>&#125;<br></code></pre></td></tr></table></figure><p>다음 그림은 위 코드의 핵심 부분인 ActivityManagerNative.getDefault().startService()의 과정을 나타낸다. 아래 그림에서도 확인할 수 있듯이 ActivityManagerNative.getDefault() 함수는 결국 ActivityManagerProxy 객체를 반환하는데 이 객체는 액티비티 매니저 서비스가 제공하는 IActivityManager 서비스 인터페이스 기반의 메서드들을 바인더 RPC 를 통해서 호출하는 역할을 한다. 따라서 액티비티 측에서는 이 객체를 통해 startService() 스텁 메서드처럼 액티비티 매니저 서비스가 제공하는 IActivityManager 인터페이스에 포함된 다양한 메서드를 로컬 함수를 호출하듯 자유롭게 이용할 수 있다.  </p><p><img src="/images/post/JS4.png" alt="JS4" title="JS4">  </p><p>따라서 ActivityManagerNative.getDefault().startService() 메서드는 ActivityManagerProxy 클래스의 startService() 프록시 메서드를 호출한다. 이는 결국 ActivityManagerService의 startService() 스텁 메서드를 원격으로 호출하는 역할을 수행한다.  </p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">public ComponentName start<span class="hljs-constructor">Service(IApplicationThread <span class="hljs-params">caller</span>, Intent <span class="hljs-params">service</span>, String <span class="hljs-params">resolvedType</span>)</span><br></code></pre></td></tr></table></figure><p>startService() 메서드의 주요 인자를 간단히 살펴보면 첫 번째 인자인 caller는 IApplicationThread 타입의 변수로서 액티비티 매니저 서비스로부터 전송된 IApplicationThread 서비스 인터페이스 기반의 바인더 RPC 를 처리하는 역할을 수행한다.  </p><h5 id="⑵-ActivityManagerProxy-객체-startService-프록시-메서드-처리"><a href="#⑵-ActivityManagerProxy-객체-startService-프록시-메서드-처리" class="headerlink" title="⑵ ActivityManagerProxy 객체 - startService() 프록시 메서드 처리"></a>⑵ ActivityManagerProxy 객체 - startService() 프록시 메서드 처리</h5><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs haskell"><span class="hljs-title">public</span> <span class="hljs-type">ComponentName</span> startService(<span class="hljs-type">IApplicationThread</span> caller, <span class="hljs-type">Intent</span> service,<br>        <span class="hljs-type">String</span> resolvedType) throws <span class="hljs-type">RemoteException</span><br>&#123;<br>    <span class="hljs-type">Parcel</span> <span class="hljs-class"><span class="hljs-keyword">data</span> = <span class="hljs-type">Parcel</span>.obtain();</span><br>    <span class="hljs-type">Parcel</span> reply = <span class="hljs-type">Parcel</span>.obtain();<br><br>    // 전송 <span class="hljs-class"><span class="hljs-keyword">data</span> 생성 (인자값을 <span class="hljs-title">data</span>에 저장)</span><br>    <span class="hljs-class"><span class="hljs-keyword">data</span>.writeInterfaceToken(<span class="hljs-type">IActivityManager</span>.<span class="hljs-title">descriptor</span>);</span><br>    <span class="hljs-class"><span class="hljs-keyword">data</span>.writeStrongBinder(<span class="hljs-title">caller</span> != <span class="hljs-title">null</span> ? <span class="hljs-title">caller</span>.<span class="hljs-title">asBinder</span>() : null);</span><br>    service.writeToParcel(<span class="hljs-class"><span class="hljs-keyword">data</span>, 0);</span><br>    <span class="hljs-class"><span class="hljs-keyword">data</span>.writeString(<span class="hljs-title">resolvedType</span>);</span><br><br>    // 바인더 <span class="hljs-type">RPC</span> 데이터 전송<br>    mRemote.transact(<span class="hljs-type">START_SERVICE_TRANSACTION</span>, <span class="hljs-class"><span class="hljs-keyword">data</span>, reply, 0);</span><br>    reply.readException();<br>    <span class="hljs-type">ComponentName</span> res = <span class="hljs-type">ComponentName</span>.readFromParcel(reply);<br>    <span class="hljs-class"><span class="hljs-keyword">data</span>.recycle();</span><br>    reply.recycle();<br><br>    return res;<br>&#125;<br></code></pre></td></tr></table></figure><p>위 코드에서 mRemote.transact() 메서드는 자바 객체에서 바인더 RPC 데이터를 전송하는 데 쓰인다. ActivityManagerProxy 객체는 startService() 프록시 메서드의 인자로 전달된 caller, service, resolved에 들어 있는 값을 바인더 RPC 데이터를 저장하는 데 사용되는 Pacel 객체 변수인 data에 저장한다. 그런 다음 START_SERVICE_TRANSACTION 트랜잭션을 통해 저장한 data 값을 ActivityManagerNative 객체에 전달한다.  </p><h5 id="⑶-ActivityManagerNative-객체-startService-스텁-메서드-호출"><a href="#⑶-ActivityManagerNative-객체-startService-스텁-메서드-호출" class="headerlink" title="⑶ ActivityManagerNative 객체 - startService() 스텁 메서드 호출"></a>⑶ ActivityManagerNative 객체 - startService() 스텁 메서드 호출</h5><p>ActivityManagerNative 객체는 상대편인 ActivityManagerProxy 객체에게서 전달받은 RPC 코드를 토대로 액티비티 매니저 서비스에서 호출한 스텁 매서드를 파악한다. 여기서는 ActivityManagerProxy 객체가 START_SERVICE_TRANSACTION RPC코드를 전송했으므로 아래 코드에서 볼 수 있듯이 startService() 스텁 메서드가 호출돼야 한다.  </p><p>다음은 startService() 스텁 메서드에 전달해야 할 인자를 구해서 startService() 스텁 메서드를 실제로 호출하면 된다. 이를 위해 RPC 데이터를 언마샬링한 후, 액티비티 매니저 서비스의 startService() 스텁 메서드를 호출한다.  </p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs haskell"><span class="hljs-title">public</span> boolean onTransact(int code, <span class="hljs-type">Parcel</span> <span class="hljs-class"><span class="hljs-keyword">data</span>, <span class="hljs-type">Parcel</span> reply, int flags)</span><br>        throws <span class="hljs-type">RemoteException</span> &#123;<br>    switch (code) &#123;<br>    <span class="hljs-keyword">case</span> <span class="hljs-type">START_ACTIVITY_TRANSACTION</span>:<br>    &#123;<br>        <span class="hljs-class"><span class="hljs-keyword">data</span>.enforceInterface(<span class="hljs-type">IActivityManager</span>.<span class="hljs-title">descriptor</span>);</span><br>        <span class="hljs-type">IBinder</span> b = <span class="hljs-class"><span class="hljs-keyword">data</span>.readStrongBinder();</span><br>        <span class="hljs-type">IApplicationThread</span> app = <span class="hljs-type">ApplicationThreadNative</span>.asInterface(b);<br>        <span class="hljs-type">Intent</span> intent = <span class="hljs-type">Intent</span>.<span class="hljs-type">CREATOR</span>.createFromParcel(<span class="hljs-class"><span class="hljs-keyword">data</span>);</span><br>        <span class="hljs-type">String</span> resolvedType = <span class="hljs-class"><span class="hljs-keyword">data</span>.readString();</span><br><br>        <span class="hljs-type">Uri</span>[] grantedUriPermissions = <span class="hljs-class"><span class="hljs-keyword">data</span>.createTypedArray(<span class="hljs-type">Uri</span>.<span class="hljs-type">CREATOR</span>);</span><br>        int grantedMode = <span class="hljs-class"><span class="hljs-keyword">data</span>.readInt();</span><br>        <span class="hljs-type">IBinder</span> resultTo = <span class="hljs-class"><span class="hljs-keyword">data</span>.readStrongBinder();</span><br>        <span class="hljs-type">String</span> resultWho = <span class="hljs-class"><span class="hljs-keyword">data</span>.readString();    </span><br>        int requestCode = <span class="hljs-class"><span class="hljs-keyword">data</span>.readInt();</span><br>        boolean onlyIfNeeded = <span class="hljs-class"><span class="hljs-keyword">data</span>.readInt() != 0;</span><br>        boolean debug = <span class="hljs-class"><span class="hljs-keyword">data</span>.readInt() != 0;</span><br>        <span class="hljs-type">String</span> profileFile = <span class="hljs-class"><span class="hljs-keyword">data</span>.readString();</span><br>        <span class="hljs-type">ParcelFileDescriptor</span> profileFd = <span class="hljs-class"><span class="hljs-keyword">data</span>.readInt() != 0</span><br>                ? <span class="hljs-class"><span class="hljs-keyword">data</span>.readFileDescriptor() : null;</span><br>        boolean autoStopProfiler = <span class="hljs-class"><span class="hljs-keyword">data</span>.readInt() != 0;</span><br>        int result = startActivity(app, intent, resolvedType,<br>                grantedUriPermissions, grantedMode, resultTo, resultWho,<br>                requestCode, onlyIfNeeded, debug, profileFile, profileFd, autoStopProfiler);<br>        reply.writeNoException();<br>        reply.writeInt(result);<br>        return true;<br>    &#125;<br>    :<br>    return super.onTransact(code, <span class="hljs-class"><span class="hljs-keyword">data</span>, reply, flags);</span><br>&#125;<br></code></pre></td></tr></table></figure><p>onTransact() 메서드의 역할은 아래 그림과 같이 ActivityManagerProxy의 startService() 프록시 메서드의 인자 값(caller, service, resolvedType)이 마샬링된 data 변수(Parcel 객체)를 바인더 RPC를 통해 수신한 다음, data 변수를 언마샬링하고 각 데이터를 별도의 변수에 저장하는 것이다. 그러고 나서 저장된 변수를 인자로 삼아 액티비티 매니저 서비스의 startService() 스텁 메서드를 호출하는 것이다.  </p><p><img src="/images/post/JS5.png" alt="JS5" title="JS5">  </p><p>아래 코드에 대해 살펴보면,</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">IApplicationThread app = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">ApplicationThreadNative</span>.</span></span><span class="hljs-keyword">as</span><span class="hljs-constructor">Interface(<span class="hljs-params">b</span>)</span>;<br></code></pre></td></tr></table></figure><p>ApplicationThreadNative.asInterface() 메서드는 ApplicationThreadNative 객체에 대응하는 ApplicationThreadProxy 객체를 생성한다. 그러고 나면 서비스 생성을 요청한 RemoteActivityController 액티비티와 액티비티 매니저 서비스 간에는 다음 그림과 같이 두 개의 바인더 연결이 성립된다. 액티비티는 IActivityManager 서비스 인터페이스 기반의 바인더 RPC를 통해 서비스 실행, 인텐트 송수신 등의 기능 수행을 요청할 수 있다. 반대로 액티비티 매니저 서비스는 IApplicationThread 인터페이스 기반의 바인더 RPC를 통해 자신과 연결된 애플리케이션을 제어할 수 있다.  </p><p><img src="/images/post/JS6.png" alt="JS6" title="JS6">  </p><h4 id="액티비티-매니저-서비스-startService-스텁-메서드-실행"><a href="#액티비티-매니저-서비스-startService-스텁-메서드-실행" class="headerlink" title="액티비티 매니저 서비스 - startService() 스텁 메서드 실행"></a>액티비티 매니저 서비스 - startService() 스텁 메서드 실행</h4><p>이제 액티비티 매니저 서비스가 요청받은 서비스를 어떻게 실행하는지 살펴본다.  </p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-function"><span class="hljs-keyword">public</span> ComponentName <span class="hljs-title">startService</span><span class="hljs-params">(IApplicationThread caller, Intent service,</span></span><br><span class="hljs-params"><span class="hljs-function">        <span class="hljs-type">String</span> resolvedType, <span class="hljs-type">int</span> userId)</span> </span>&#123;<br><br>        <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> callingPid = Binder.<span class="hljs-built_in">getCallingPid</span>();<br>        <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> callingUid = Binder.<span class="hljs-built_in">getCallingUid</span>();<br>        <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> origId = Binder.<span class="hljs-built_in">clearCallingIdentity</span>();<br>        ComponentName res = mServices.<span class="hljs-built_in">startServiceLocked</span>(caller, service,<br>                resolvedType, callingPid, callingUid, userId);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br></code></pre></td></tr></table></figure><p>이 메서드에서 주로 하는 일은 startServiceLocked() 메서드를 호출하는 것이다.  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java">ComponentName <span class="hljs-title function_">startServiceLocked</span><span class="hljs-params">(IApplicationThread caller, Intent service, String</span><br><span class="hljs-params">            resolvedType, <span class="hljs-type">int</span> callingPid, <span class="hljs-type">int</span> callingUid, <span class="hljs-type">int</span> userId)</span> &#123;<br>    <span class="hljs-comment">// retrieveServiceLocked() 메서드의 반환값인 ServiceLookupResult 구조체 변수 res로부터 ServiceRecord 값을 얻는다.</span><br>    <span class="hljs-type">ServiceLookupResult</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span><br>            retrieveServiceLocked(service, resolvedType,<br>                    callingPid, callingUid, userId, <span class="hljs-literal">true</span>, callerFg);<br>    <span class="hljs-type">ServiceRecord</span> <span class="hljs-variable">r</span> <span class="hljs-operator">=</span> res.record;<br>    <span class="hljs-keyword">return</span> startServiceInnerLocked(smap, service, r, callerFg, addToStarting);<br>&#125;<br></code></pre></td></tr></table></figure><p>이 메서드에서 주로 하는 일은 ServiceRecord 값을 얻는 것이다. ServiceRecord는 안드로이드 애플리케이션 서비스에 대한 각종 정보(서비스 패키지명과 위치, 권한, 서비스 프로세스 정보, 실행 통계 정보 등)가 담긴 클래스이다.  </p><p>이렇게 구한 ServiceRecord 객체를 bringUpServiceLocked() 메서드의 첫 번째 인자로 전달한다.  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String <span class="hljs-title function_">bringUpServiceLocked</span><span class="hljs-params">(ServiceRecord r, <span class="hljs-type">int</span> intentFlags,</span><br><span class="hljs-params">            <span class="hljs-type">boolean</span> execInFg, <span class="hljs-type">boolean</span> whileRestarting)</span> &#123;<br><br>    <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">appName</span> <span class="hljs-operator">=</span> r.processName;<br>    <span class="hljs-type">ProcessRecord</span> <span class="hljs-variable">app</span> <span class="hljs-operator">=</span> getProcessRecordLocked(appName, r.appInfo.uid);<br><br>    <span class="hljs-keyword">if</span> (app != <span class="hljs-literal">null</span> &amp;&amp; app.thread != <span class="hljs-literal">null</span>) &#123;<br>          <span class="hljs-comment">// 기존 프로세스 영역 내에서 서비스를 실행함.</span><br>          realStartServiceLocked(r, app, execInFg);<br>          <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br><br>    startProcessLocked(appName, r.appInfo, <span class="hljs-literal">true</span>, intentFlags, <span class="hljs-string">&quot;service&quot;</span>, r.name, <span class="hljs-literal">false</span>);<br>    mPendingServices.add(r);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>bringUpServiceLocked() 메서드는 ServiceRecord 객체를 참조해서 해당 서비스가 실행된 프로세스 이름과 uid를 통해 ProcessRecord 객체가 존재하는지 검사한다. 이를 위해 getProcessRecordLocked() 메서드가 호출된다.  </p><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs processing"><span class="hljs-keyword">final</span> ProcessRecord <span class="hljs-title function_">startProcessLocked</span>(<span class="hljs-built_in">String</span> processName, ApplicationInfo info,<br>            <span class="hljs-type">boolean</span> knownToBeDead, <span class="hljs-type">int</span> intentFlags, <span class="hljs-built_in">String</span> hostingType, ComponentName hostingName,<br>            <span class="hljs-type">boolean</span> allowWhileBooting) &#123;<br>                <span class="hljs-comment">// ProcessRecord를 새로 생성</span><br>                app = <span class="hljs-title function_">getProcessRecordLocked</span>(<span class="hljs-literal">null</span>, info, processName);<br>                mProcessNames.<span class="hljs-property">put</span>(processName, info.<span class="hljs-property">uid</span>, app);<br>                <span class="hljs-title function_">startProcessLocked</span>(app, hostingType, hostingNameStr);<br><br>                <span class="hljs-title function_">return</span> (app.<span class="hljs-property">pid</span> != <span class="hljs-number">0</span>) ? app : <span class="hljs-literal">null</span>;<br>            &#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">startProcessLocked</span>(ProcessRecord app, <span class="hljs-built_in">String</span> hostingType, <span class="hljs-built_in">String</span> hostingNameStr) &#123;<br>  <span class="hljs-type">int</span> uid = app.<span class="hljs-property">info</span>.<span class="hljs-property">uid</span>;<br>  <span class="hljs-type">int</span>[] gids = <span class="hljs-literal">null</span>;<br>  <span class="hljs-type">int</span> debugFlags = <span class="hljs-number">0</span>;<br><br>  gids = mContext.<span class="hljs-property">getPackageManager</span>().<span class="hljs-property">getPackageGids</span>(app.<span class="hljs-property">info</span>.<span class="hljs-property">packageName</span>);<br><br>  <span class="hljs-type">int</span> pid = Process.<span class="hljs-property">start</span>(<span class="hljs-string">&quot;android.app.ActivityThread&quot;</span>, <span class="hljs-literal">null</span>, uid, uid, gids, debugFlags, <span class="hljs-literal">null</span>);<br><br>  <span class="hljs-comment">// 액티비티 매니저 서비스의 mPidsSelfLocked 해시에 생성된 프로세스의 pid 값을 key로 해서 ProcessRecord 객체를 저장함.</span><br>  <span class="hljs-variable">this</span>.<span class="hljs-property">mPidsSelfLocked</span>.<span class="hljs-property">put</span>(pid, app);<br>&#125;<br></code></pre></td></tr></table></figure><p>ActivityManagerService 클래스 코드에는 두 개의 startProcessLocked() 메서드가 존재한다.  </p><p>첫 번째 startProcessLocked() 메서드의 역할은 리모트 서비스를 실행하기 위해 새로 생성할 프로세스 정보를 포함하는 ProcessRecord 객체를 만들고, 이를 mProcessNames 큐에 삽입하는 것이다. 이 과정이 성공적으로 끝나면 두 번째 startProcessLocked() 메서드를 호출한다.  </p><p>두 번째 startProcessLocked() 메서더의 역할은 Process 클래스의 start() 메서드를 통해 Zygote에게 android.app.ActivityThread 프로세스 생성을 요청하는 것이다.  </p><h4 id="ActivityThread-클래스의-main-메서드-실행"><a href="#ActivityThread-클래스의-main-메서드-실행" class="headerlink" title="ActivityThread 클래스의 main() 메서드 실행"></a>ActivityThread 클래스의 main() 메서드 실행</h4><p>지금부터는 Zygote가 서비스 실행을 위해 액티비티 매니저 서비스가 요청한 ActivityThread 클래스를 새로운 프로세스 상에서 어떻게 실행하는지 알아본다.  </p><p>클래스의 실행을 요청받으면 새로운 프로세스를 생성하고 그 위에 해당 클래스를 로드한 후 해당 클래스의 main() 메서드를 호출한다.  </p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ActivityThread</span> extends ClientTransactionHandler &#123;<br>    <span class="hljs-comment">// ApplicationThread() 생성</span><br>    <span class="hljs-keyword">final</span> ApplicationThread mAppThread = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ApplicationThread</span>();<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-type">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">void</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">String</span>[] args)</span> </span>&#123;<br>            <span class="hljs-built_in">Process</span>.<span class="hljs-built_in">setArgV0</span>(<span class="hljs-string">&quot;&lt;pre-initialized&gt;&quot;</span>);<br>            Looper.<span class="hljs-built_in">prepareMainLooper</span>(); <span class="hljs-comment">// Looper.prepareMainLooper() 메서드를 이용해서 메시지 큐를 생성</span><br>            ActivityThread thread = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ActivityThread</span>(); <span class="hljs-comment">// ActivityThread 객체를 생성</span><br>            thread.<span class="hljs-built_in">attach</span>(<span class="hljs-literal">false</span>);<br>            Looper.<span class="hljs-built_in">loop</span>();<br>        &#125;<br><br>        <span class="hljs-comment">// 메시지 핸들러</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-type">void</span> <span class="hljs-title">handleMessage</span><span class="hljs-params">(Message msg)</span> </span>&#123;<br>           <span class="hljs-keyword">switch</span> (msg.what) &#123;<br>             :<br>             <span class="hljs-keyword">case</span> CREATE_SERVICE:<br>                   <span class="hljs-built_in">handleCreateService</span>((CreateServiceData)msg.obj);<br>                   <span class="hljs-keyword">break</span>;<br>             <span class="hljs-keyword">case</span> SERVICE_ARGS:<br>                   <span class="hljs-built_in">handleServiceArgs</span>((ServiceArgsData)msg.obj);<br>                   <span class="hljs-keyword">break</span>;<br>             <span class="hljs-keyword">case</span> STOP_SERVICE:<br>                   <span class="hljs-built_in">handleStopService</span>((IBinder)msg.obj);<br>                   <span class="hljs-keyword">break</span>;<br>             :<br>           &#125;<br>       &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>Looper는 각 스레드의 메시지 루프를 실행하는 클래스.</p><p>ActivityThread 객체는 액티비티 매니저 서비스와의 상호작용을 통해 안드로이드 애플리케이션 프로세스의 메인 스레드 실행 및 액티비티 스케줄링 등을 수행한다.  </p><p>attach() 메서드는 다음 그림과 같은 과정을 보인다.  </p><p><img src="/images/post/JS7.png" alt="JS7" title="JS7">  </p><p>⑴ ActivityThread - ActivityManagerProxy 객체의 attachApplication() 프록시 메서드를 호출<br>⑵ ActivityManagerProxy 객체 - ActivityManagerNative 객체에 ATTACH_APPLICATION_TRANSACTION RPC 코드와 바인더 RPC 데이터를 전송<br>⑶ ActivityManagerNative 객체 - ActivityManagerService에 포함된 attachApplication() 스텁 메서드를 호출  </p><p>코드를 바탕으로 attach() 메서드가 바인더 RPC를 통해 attachApplication()을 어떻게 호출하는지 알아보자.  </p><h5 id="⑴-ActivityThread-attachApplication-프록시-메서드-호출"><a href="#⑴-ActivityThread-attachApplication-프록시-메서드-호출" class="headerlink" title="⑴ ActivityThread - attachApplication() 프록시 메서드 호출"></a>⑴ ActivityThread - attachApplication() 프록시 메서드 호출</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">attach</span><span class="hljs-params">(<span class="hljs-type">boolean</span> system)</span> &#123;<br>    :<br>    <span class="hljs-keyword">if</span> (!system) &#123;<br>        <span class="hljs-type">IActivityManager</span> <span class="hljs-variable">mgr</span> <span class="hljs-operator">=</span> ActivityManagerNative.getDefault();<br>        <span class="hljs-keyword">try</span> &#123;<br>            mgr.attachApplication(mAppThread);<br>        &#125; <span class="hljs-keyword">catch</span> (RemoteException ex) &#123;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>이 메서드의 주요 기능은 ActivityThread와 액티비티 매니저 서비스 간에 IActivityManager 인터페이스 기반의 바인더 RPC를 위한 연결을 설정하는 것이다. 바인더 RPC 연결이 설정되면 ActivityThread는 ActivityManagerProxy 객체를 통해 액티비티 매니저 서비스에게 특정 작업을 요청할 수 있다.  </p><h5 id="⑵-ActivityManagerProxy-객체"><a href="#⑵-ActivityManagerProxy-객체" class="headerlink" title="⑵ ActivityManagerProxy 객체"></a>⑵ ActivityManagerProxy 객체</h5><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs haskell"><span class="hljs-title">public</span> void attachApplication(<span class="hljs-type">IApplicationThread</span> app)<br>&#123;<br>  <span class="hljs-type">Parcel</span> <span class="hljs-class"><span class="hljs-keyword">data</span> = <span class="hljs-type">Parcel</span>.obtain();</span><br>  <span class="hljs-type">Parcel</span> reply = <span class="hljs-type">Parcel</span>.obtain();<br>  <span class="hljs-class"><span class="hljs-keyword">data</span>.writeInterfaceToken(<span class="hljs-type">IActivityManager</span>.<span class="hljs-title">descriptor</span>);</span><br>  <span class="hljs-class"><span class="hljs-keyword">data</span>.writeStrongBinder(<span class="hljs-title">app</span>.<span class="hljs-title">asBinder</span>());</span><br>  mRemote.transact(<span class="hljs-type">ATTACH_APPLICATION_TRANSACTION</span>, <span class="hljs-class"><span class="hljs-keyword">data</span>, reply, 0);</span><br>&#125;<br></code></pre></td></tr></table></figure><p>⑴ 에서 호출된 attachApplication() 프록시 메서드를 살펴보면, app 매개변수를 통해 전달받은 ApplicationThread에 대한 바인더 객체를 마샬링해서 ATTACH_APPLICATION_TRANSACTION RPC 코드와 바인더 RPC 데이터를 ActivityManagerNative 객체에 전달한다.  </p><h5 id="⑶-ActivityManagerNative-객체-attachApplication-스텁-메서드를-호출"><a href="#⑶-ActivityManagerNative-객체-attachApplication-스텁-메서드를-호출" class="headerlink" title="⑶ ActivityManagerNative 객체 - attachApplication() 스텁 메서드를 호출"></a>⑶ ActivityManagerNative 객체 - attachApplication() 스텁 메서드를 호출</h5><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">public boolean on<span class="hljs-constructor">Transact(<span class="hljs-params">int</span> <span class="hljs-params">code</span>, Parcel <span class="hljs-params">data</span>, Parcel <span class="hljs-params">reply</span>, <span class="hljs-params">int</span> ?<span class="hljs-params">ags</span>)</span><br>&#123;<br>  switch (code) &#123;<br>    :<br>    case ATTACH_APPLICATION_TRANSACTION: &#123;<br>      IApplicationThread app = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">ApplicationThreadNative</span>.</span></span><span class="hljs-keyword">as</span><span class="hljs-constructor">Interface(<span class="hljs-params">data</span>.<span class="hljs-params">readStrongBinder</span>()</span>);<br>      attach<span class="hljs-constructor">Application(<span class="hljs-params">app</span>)</span>;<br>      return <span class="hljs-literal">true</span>;<br>    &#125;<br>    :<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>ActivityThread가 보낸 ATTACH_APPLICATION_TRANSACTION RPC 코드와 바인더 RPC 데이터는 ActivityManagerNative 객체의 onTransact() 메서드를 통해 처리된다.  </p><p>지금까지의 과정을 정리하면 ActivityThread 객체는 attach() 메서드를 통해 액티비티 매니저 서비스가 자신을 제어할 수 있도록 바인더 RPC 연결을 설정한다. 연결이 설정되고 나면 액티비티 매니저 서비스의 attachApplication() 스텁 메서드가 호출된다.  </p><h4 id="액티비티-매니저-서비스-attachApplication-스텁-메서드-처리"><a href="#액티비티-매니저-서비스-attachApplication-스텁-메서드-처리" class="headerlink" title="액티비티 매니저 서비스 - attachApplication() 스텁 메서드 처리"></a>액티비티 매니저 서비스 - attachApplication() 스텁 메서드 처리</h4><p>attachApplication() 스텁 메서드의 전체적인 동작 과정  </p><p><img src="/images/post/JS8.png" alt="JS8" title="JS8">  </p><p>⑴ 액티비티 매니저 서비스 - ActivityManagerProxy 객체의 scheduleCreateService() 프록시 메서드 호출  </p><p>⑵ ActivityManagerProxy 객체 - ActivityThread의 ActivityManagerNative 객체에 SCHEDULE_CREATE_SERVICE_TRANSACTION RPC 코드와 바인더 RPC 데이터 전송  </p><p>⑶ ActivityManagerNative 객체 - ApplicationCreateService의 ApplicationThread 객체에 포함된 scheduleCreateService() 스텁 메서드 호출   </p><p>⑷ ApplicationThread 객체 - ApplicationCreateService의 ActivityThread에 메시지큐를 이용해 CREATE_SERVICE 메시지 전달  </p><p>⑸ ActivityThread 객체 - RemoteService 서비스 생성 및 서비스 생명주기에 따른 onCreate() 호출  </p><h5 id="⑴-액티비티-매니저-서비스-scheduleCreateService-프록시-메서드-호출"><a href="#⑴-액티비티-매니저-서비스-scheduleCreateService-프록시-메서드-호출" class="headerlink" title="⑴ 액티비티 매니저 서비스 - scheduleCreateService() 프록시 메서드 호출"></a>⑴ 액티비티 매니저 서비스 - scheduleCreateService() 프록시 메서드 호출</h5><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">public final void attach<span class="hljs-constructor">Application(IApplicationThread <span class="hljs-params">thread</span>)</span><br>&#123;<br>  <span class="hljs-built_in">int</span> callingPid - <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Binder</span>.</span></span>get<span class="hljs-constructor">CallingPid()</span>;<br>  attach<span class="hljs-constructor">ApplicationLocked(<span class="hljs-params">thread</span>, <span class="hljs-params">callingPid</span>)</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>이 메서드는 단순히 attachApplicationLocked() 메서드를 호출하는 역할을 한다.<br>thread인자는 ApplicationThreadProxy 객체, callingPid 인자는 attachApplication() 스텁 메서드를 호출한 프로세스의 pid.</p><p>다음 코드는 attachApplicationLocked() 메서드의 주요 부분이다.  </p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-comment">// thread는 ApplicationThreadProxy 객체를 가리킴</span><br><span class="hljs-function">pricate <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title">attachApplicationLocked</span><span class="hljs-params">(IApplicationThread thread, <span class="hljs-type">int</span> pid)</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-comment">// 생성된 ActivityThread의 pid 값을 가지는 ProcessRecord를 얻음</span><br>  ProcessRecord app;<br>  app = mPidsSelfLocked.<span class="hljs-built_in">get</span>(pid);<br><br>  <span class="hljs-comment">// ProcessRecord와 ApplicationThreadProxy 객체를 연결함</span><br>  app.thread = thread;<br><br>  <span class="hljs-comment">// 실행할 서비스의 ServiceRecord를 얻음</span><br>  ServiceRecord sr = null;<br><br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;mPendingServices.<span class="hljs-built_in">size</span>(); i++) &#123;<br>    sr = mPendingServices.<span class="hljs-built_in">get</span>(i); <span class="hljs-comment">// 큐에 저장했던 RemoteService에 대한 ServiceRecord 객체를 얻는다.  </span><br>    mPendingServices.<span class="hljs-built_in">remove</span>(i);<br>    i--;<br><br>    <span class="hljs-built_in">realStartServiceLocked</span>(sr, app); <span class="hljs-comment">// ProcessRecord와 ServiceRecord 값을 realStartServiceLocked() 메서드로 전달한다.  </span><br>  &#125;<br><br>  <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/images/post/JS9.png" alt="JS9" title="JS9">  </p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-keyword">private</span> final void real<span class="hljs-constructor">StartServiceLocked(ServiceRecord <span class="hljs-params">r</span>, ProcessRecord <span class="hljs-params">app</span>)</span><br>&#123;<br>  app.thread.schedule<span class="hljs-constructor">CreateService(<span class="hljs-params">r</span>, <span class="hljs-params">r</span>.<span class="hljs-params">serviceInfo</span>)</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>내부적으로 app.thread.scheduleCreateService() 메서드를 호출한다. app.thread에는 서비스 실행을 요청한 ActivityThread를 제어하기 위한 ApplicationThreadProxy 객체가 저장돼 있다.<br>app.thread.scheduleCreateService() 메서드는 ApplicationThreadProxy의 scheduleCreateService() 메서드를 호출한다.  </p><h5 id="⑵-ActivityManagerProxy-객체-바인더-RPC-데이터-전송"><a href="#⑵-ActivityManagerProxy-객체-바인더-RPC-데이터-전송" class="headerlink" title="⑵ ActivityManagerProxy 객체 - 바인더 RPC 데이터 전송"></a>⑵ ActivityManagerProxy 객체 - 바인더 RPC 데이터 전송</h5><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs haskell"><span class="hljs-title">public</span> final void scheduleCreateService(<span class="hljs-type">IBinder</span> token, <span class="hljs-type">ServiceInfo</span> info)<br>&#123;<br>  <span class="hljs-type">Parcel</span> <span class="hljs-class"><span class="hljs-keyword">data</span> = <span class="hljs-type">Parcel</span>.obtain();</span><br>  <span class="hljs-class"><span class="hljs-keyword">data</span>.writeStrongBinder(<span class="hljs-title">token</span>);</span><br>  info.writeToParcel(<span class="hljs-class"><span class="hljs-keyword">data</span>, 0);</span><br>  mRemote.transact(<span class="hljs-type">SCHEDULE_CREATE_SERVICE_TRANSACTION</span>, <span class="hljs-class"><span class="hljs-keyword">data</span>, null, <span class="hljs-type">IBinder</span>.<span class="hljs-type">FLAG_ONEWAY</span>);</span><br>&#125;<br></code></pre></td></tr></table></figure><p>scheduleCreateService() 프록시 메서드는 생성할 서비스(여기서는 RemoteService)에 대한 정보를 포함한 ServiceInfo 객체를 SCHEDULE_CREATE_SERVICE_TRANSACTION RPC 코드와 RPC 데이터를 통해 ApplicationThreadNative 객체에 전달한다.  </p><h5 id="⑶-ActivityManagerNative-객체-scheduleCreateService-스텁-메서드-호출"><a href="#⑶-ActivityManagerNative-객체-scheduleCreateService-스텁-메서드-호출" class="headerlink" title="⑶ ActivityManagerNative 객체 - scheduleCreateService() 스텁 메서드 호출"></a>⑶ ActivityManagerNative 객체 - scheduleCreateService() 스텁 메서드 호출</h5><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">public boolean on<span class="hljs-constructor">Transact(<span class="hljs-params">int</span> <span class="hljs-params">code</span>, Parcel <span class="hljs-params">data</span>, Parcel <span class="hljs-params">reply</span>, <span class="hljs-params">int</span> <span class="hljs-params">flags</span>)</span><br>&#123;<br>  switch(code) &#123;<br>    :<br>    case SCHEDULE_CREATE_SERVICE_TRANSACTION: &#123;<br>      IBinder token = data.read<span class="hljs-constructor">StrongBinder()</span>;<br>      serviceInfo info = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">ServiceInfo</span>.</span><span class="hljs-module"><span class="hljs-identifier">CREATOR</span>.</span></span>create<span class="hljs-constructor">FromParcel(<span class="hljs-params">data</span>)</span>;<br>      schedule<span class="hljs-constructor">CreateService(<span class="hljs-params">token</span>, <span class="hljs-params">info</span>)</span>;<br>      return <span class="hljs-literal">true</span>;<br>    &#125;<br>    :<br>  &#125;<br><br>  return super.on<span class="hljs-constructor">Transact(<span class="hljs-params">code</span>, <span class="hljs-params">data</span>, <span class="hljs-params">reply</span>, ?<span class="hljs-params">ags</span>)</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>ApplicationThreadProxy 객체가 data 변수에 마샬링해서 전달한 ServiceRecord 객체(Binder 객체를 확장한 객체)와 ServiceInfo 객체를 언마샬링한 다음 각각 token과 info 변수에 저장한다. 그리고 이렇게 바인더 RPC로부터 수신한 데이터를 저장한 token과 info를 각각 ActivityThread의 scheduleCreateService() 스텁 메서드의 인자로 넘긴다.  </p><h5 id="⑷-ApplicationThread-객체-ActivityThread로-CREATE-SERVICE-메시지-전달"><a href="#⑷-ApplicationThread-객체-ActivityThread로-CREATE-SERVICE-메시지-전달" class="headerlink" title="⑷ ApplicationThread 객체 - ActivityThread로 CREATE_SERVICE 메시지 전달"></a>⑷ ApplicationThread 객체 - ActivityThread로 CREATE_SERVICE 메시지 전달</h5><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">public final void schedule<span class="hljs-constructor">CreateService(IBinder <span class="hljs-params">token</span>, ServiceInfo <span class="hljs-params">info</span>)</span><br>&#123;<br>  CreateServiceData s = <span class="hljs-keyword">new</span> <span class="hljs-constructor">CreateServiceData()</span>;<br>  s.token = token;<br>  s.info = info;<br>  queue<span class="hljs-constructor">OrSendMessage(H.CREATE_SERVICE, <span class="hljs-params">s</span>)</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>scheduleCreateService() 스텁 메서드는 인자를 이용해 CreateServiceData라는 객체를 만든 다음 이를 ActivityThread 메시지 큐에 CREATE_SERVICE 메시지로 전달한다.  </p><p>지금까지의 과정을 살펴보면 다음과 같이 나타낼 수 있다.  </p><p><img src="/images/post/JS10.png" alt="JS10" title="JS10">  </p><p>ApplicationThread는 액티비티 매니저 서비스의 제어 명령을 바인더 RPC로 수신하기 위한 용도로 사용되고,<br>실제 액티비티 매니저 서비스로부터 요청받은 서비스를 실행하거나 생명주기를 관리하는 일은 ActivityThread가 처리하기 때문이다.  </p><h5 id="⑸-ActivityThread-객체-서비스-생성-및-서비스의-onCreate-호출"><a href="#⑸-ActivityThread-객체-서비스-생성-및-서비스의-onCreate-호출" class="headerlink" title="⑸ ActivityThread 객체 - 서비스 생성 및 서비스의 onCreate() 호출"></a>⑸ ActivityThread 객체 - 서비스 생성 및 서비스의 onCreate() 호출</h5><p>ActivityThread의 메시지 핸들러 코드 중 CREATE_SERVICE 메시지를 처리하는 주요 부분이며, 실질적인 처리는 handleCreateService() 메서드에서 이루어진다.</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">public void handle<span class="hljs-constructor">Message(Message <span class="hljs-params">msg</span>)</span><br>&#123;<br>  switch (msg.what) &#123;<br>    :<br>    case CREATE_SERVICE:<br>    handle<span class="hljs-constructor">CreateService((CreateServiceData)</span>msg.obj);<br>    break;<br>    :<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">private</span> final void handle<span class="hljs-constructor">CreateService(CreateServiceData <span class="hljs-params">data</span>)</span><br>&#123;<br>  <span class="hljs-comment">// 서비스 인스턴스 생성</span><br>  PackageInfo packageInfo = get<span class="hljs-constructor">PackageInfoNoCheck(<span class="hljs-params">data</span>.<span class="hljs-params">info</span>.<span class="hljs-params">applicationInfo</span>)</span>;<br>  Service service = null;<br>  java.lang.ClassLoader cl = packageInfo.get<span class="hljs-constructor">ClassLoader()</span>;<br>  service = (Service) cl.load<span class="hljs-constructor">Class(<span class="hljs-params">data</span>.<span class="hljs-params">info</span>.<span class="hljs-params">name</span>)</span>.<span class="hljs-keyword">new</span><span class="hljs-constructor">Instance()</span>;<br><br>  <span class="hljs-comment">// 서비스 생명주기 시작</span><br>  service.on<span class="hljs-constructor">Create()</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="정리"><a href="#정리" class="headerlink" title="정리"></a>정리</h3><p><img src="/images/post/JS11.png" alt="JS11" title="JS11">  </p><p>⑴ Controller 액티비티는 RemoteService 서비스를 실행하기 위해 startService() API를 통해 액티비티 매니저 서비스에 RemoteService 서비스 실행을 요청한다.  </p><p>⑵ 요청받은 서비스가 리모트 서비스인 경우 액티비티 매니저 서비스는 Zygote에게 서비스를 별도의 독립 프로세스로 실행시키기 위해 ActivityThread 생성을 요청한다.  </p><p>⑶ Zygote에 의해 생성된 ActivityThread는 attachApplication() 프록시 메서드를 통해 액티비티 매니저 서비스에게 자신을 등록한다. 이를 통해 액티비티 매니저 서비스는 생성도니 ActivityThread를 제어할 수 있다.  </p><p>⑷ 액티비티 매니저 서비스는 ⑴에서 요청받은 RemoteService 생성을 ActivityThread에 요청한다.  </p><p>⑸ ActivityThread는 요청했던 RemoteService 서비스의 인스턴스를 생성한 다음 이 서비스의 onCreate() 콜백 함수를 호출한다.  </p>]]></content>
    
    
    <categories>
      
      <category>Android</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Android</tag>
      
      <tag>인사이드 안드로이드</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[인사이드 안드로이드] 챕터 10 - 자바 서비스 프레임워크</title>
    <link href="/chapter10/"/>
    <url>/chapter10/</url>
    
    <content type="html"><![CDATA[<h1 id="인사이드-안드로이드"><a href="#인사이드-안드로이드" class="headerlink" title="[인사이드 안드로이드]"></a>[인사이드 안드로이드]</h1><h2 id="Chapter10-자바-서비스-프레임워크"><a href="#Chapter10-자바-서비스-프레임워크" class="headerlink" title="Chapter10 - 자바 서비스 프레임워크"></a>Chapter10 - 자바 서비스 프레임워크</h2><p>안드로이드 서비스 프레임워크는 자바 서비스 프레임워크와 네이티브 서비스 프레임워크로 나뉜다. 자바 서비스 프레임워크는 네이티브 서비스 프레임워크에서 제공하는 4가지 핵심 기능을 동일하게 제공하지만 시스템 내부에서 서비스가 동작하는 매커니즘이나 서비스 작성 방법에 있어서는 차이점이 있다.  </p><h3 id="자바-서비스-프레임워크"><a href="#자바-서비스-프레임워크" class="headerlink" title="자바 서비스 프레임워크"></a>자바 서비스 프레임워크</h3><p>자바 서비스 프레임워크는 자바 기반의 애플리케이션 프레임워크에서 동작하는 자바 시스템 서비스를 개발할 때 이용하는 클래스의 집합이다. 자바 서비스 프레임워크는 JNI를 통해 네이티브 서비스 프레임워크를 재사용함으로써 자바 레이어의 서비스 사용자가 자바로 작성된 서비스뿐만 아니라 C++로 작성된 서비스도 이용할 수 있게 된다.  </p><p><img src="/images/post/sf1.png" alt="sf1" title="sf1">  </p><p>자바 서비스 프레임워크는 네이티브 서비스 프레임워크와 다음과 같은 차이점이 있다.  </p><p>① 서비스 생성 : 자바 서비스 프레임워크에서 자바 서비스를 개발하는 방법은 두 가지다.<br>  첫 번째 방법은 Binder 클래스를 상속받아 개발하는 것으로, 서비스를 정밀하게 제어해야 할 때 적잘한 방식으로 자바 시스템 서비스를 작성할 때도 쓰이는 방법이다.<br>  두 번째 방법은 Service 클래스를 상속받아 개발하는 것인데 일반적으로 특정 작업을 주기적으로 백그라운드에서 수행하는 프로세스를 구현하는 데 사용된다.<br>② 바인더 IPC 처리 : 자바 서비스 프레임워크에서는 바인더 IPC를 지원하기 위해 JNI를 통해 연결된 네이티브 서비스 프레임워크의 구성요소를 재사용한다.  </p><h4 id="자바-서비스-프레임워크의-계층별-요소"><a href="#자바-서비스-프레임워크의-계층별-요소" class="headerlink" title="자바 서비스 프레임워크의 계층별 요소"></a>자바 서비스 프레임워크의 계층별 요소</h4><p>다음 그림은 자바 서비스 프레임워크의 구성요소를 계층별로 표현한 것이다. 각 레이어별로 네이티브 서비스 프레임워크와 차이점은 첫째, 서비스 사용자의 서비스 레이어에 매니저(Manager) 클래스가 위치한다. 둘째, RPC 레이어에 AIDL 도구로 자동 생성된 스텁(Stub)과 프록시(Proxy) 클래스가 위치한다. 셋째, IPC 레이어에 위치한 구성요소가 JNI를 통해 네이티브 서비스 프레임워크의 구성요소와 연결돼 있다.  </p><p><img src="/images/post/sf2.png" alt="sf2" title="sf2">  </p><p><strong>서비스 레이어</strong>  </p><p>FooManager 클래스를 구현하는 이유는 SDK에 serviceManager 클래스가 포함되지 않았기 때문에 애플리케이션에서 serviceManager 클래스를 이용하여 시스템 서비스를 등록하거나 또는 시스템 서비스를 검색 할 수 없기 때문이다.  </p><p><img src="/images/post/sf3.png" alt="sf3" title="sf3">  </p><p>시스템 서비스 개발자는 애플리케이션 개발자가 시스템 서비스를 이용할 수 있게 SDK에 래퍼 클래스를 포함시켜야 한다.  </p><p><strong>RPC 레이어</strong>  </p><p>자바 서비스 프레임워크는 안드로이드 플랫폼에 포함된 AIDL(Android Interface Definition Language) 언어와 컴파일러를 이용해 서비스 프록시와 서비스 스텁을 자동으로 생성한다. AIDL은 안드로이드에서 프로세스 간의 IPC(InterProcess Communication)를 통해 상호작용하는 자바 기반의 코드를 작성하는 데 사용되는 인터페이스 정의 언어다.  </p><p><strong>IPC 레이어</strong>  </p><p>자바 서비스 프레임워크를 이용해 개발한 서비스와 서비스 프록시가 상호작용할 때도 바인더 RPC를 이용한다. 바인더 RPC를 위해 네이티브 서비스 프레임워크에서는 BpBinder와 BBinder 클래스를 제공하지만 자바 서비스 프레임워크에서는 BinderProxy와 Binder 클래스가 이용된다.<br>서비스 프록시에서 서비스에게 바인더 RPC 데이터를 전달하려면 바인더 IPC를 이용해야 하는데, 자바 서비스 프레임워크에서는 JNI를 통해 네이티브 서비스 프레임워크의 바인더 IPC를 재사용한다.  </p><p><img src="/images/post/sf4.png" alt="sf4" title="sf4">  </p><h4 id="자바-서비스-프레임워크의-클래스별-상호작용"><a href="#자바-서비스-프레임워크의-클래스별-상호작용" class="headerlink" title="자바 서비스 프레임워크의 클래스별 상호작용"></a>자바 서비스 프레임워크의 클래스별 상호작용</h4><p>자바 서비스 프레임워크는 바인더 RPC를 지원하기 위해 JNI를 통해 네이티브 서비스 프레임워크의 기능을 재사용하므로 서비스 클라이언트와 서비스 서버 내부의 구성요소 간에 수직 방향으로 이뤄지는 상호작용 역시 두 프레임워크 사이에 차이점이 있다. 먼저 자바 시스템 서비스 사용자가 위치한 서비스 클라이언트부터 살펴보면 다음 그림에서 서비스 사용자가 FooManager의 foo() 메서드를 호출하는 과정과 BinderProxy의 transact() 메서드가 JNI 네이티브 함수인 android_os_BinderProxy_transact() 로 BpBinder의 transact() 함수를 호출하는 과정이 추가돼 있음을 확인할 수 있다.  </p><p><img src="/images/post/sf5.png" alt="sf5" title="sf5">  </p><p>자바 시스템 서비스가 위치한 서비스 서버를 살펴보면 다음 그림에서 BBinder의 transact() 함수가 JavaBBinder 네이티브 서비스 스텁을 이용해 Binder execTransact() 메서드를 호출하는 과정이 추가되었다.  </p><p><img src="/images/post/sf6.png" alt="sf6" title="sf6">  </p><p>다음 그림은 자바 서비스를 시스템에 등록하는 과정에서 자바 서비스 프레임워크 구성요소가 상호작용 하는 과정을 보여준다. 네이티브 서비스 프레임워크와 비슷하게 서비스 등록과 사용에 관한 주체는 서비스를 제공하는 서비스 서버, 서비스를 이용하는 서비스 클라이언트, 서비스 매니저, 참여 주체 사이에 통신을 지원하는 바인더 드라이버로 구성된다.  </p><p><img src="/images/post/sf7.png" alt="sf7" title="sf7">  </p><p>① 서비스 등록 요청(서비스) : 자바 서비스 프레임워크는 자바 서비스 매니저인 ServiceManager 클래스를 이용해서 이 과정을 처리한다. FooManager 서비스는 자신을 시스템에 등록하기 위해 ServiceManager의 addService() 메서드를 호출한다. ServiceManager 내부에는 BinderProxy가 있으며, BinderProxy는 컨텍스트 매니저를 가리키는 BpBinder와 JNI를 통해 연결돼 있다.<br>② 서비스 등록(서비스 매니저) : ServiceManagerProxy 서비스 프록시는 addService() 메서드의 호출 정보를 RPC 데이터로 변환한다. 이때 바인더 RPC 데이터는 Parcel 클래스에 저장되어 BinderProxy에 전달되고, JNI를 통해 BpBinder에 전달된다. 그러고 나서 바인더 IPC를 통해 컨텍스트 매니저에 전달되어 FooService 서비스가 시스템에 등록된다.<br>③ 서비스 검색 요청(서비스 사용자) : FooService 서비스를 사용하기 위해 네이티브 서비스 사용자는 BpServiceManager를 통해 서비스를 검색했지만 자바 서비스 사용자는 SDK에서 제공하는 getSystemService() 메서드를 호출해서 서비스를 검색한다.<br>④ 서비스 검색(서비스 매니저) : getSystemService()는 ServiceManager의 getService() 메서드를 호출해 시스템에서 FooService 서비스를 검색한다. 만약 FooService 서비스가 검색되면 IFooService.Stub.Proxy 서비스 프록시를 참조하는 FooManager를 서비스 사용자에게 반환한다.<br>⑤ foo() 서비스 프록시 메서드 호출(서비스 사용자) : 서비스 사용자는 FooManager의 foo() 메서드를 호출한다. 그러고 나면 IFooService.Stub.Proxy는 foo() 메서드 호출 정보를 RPC 데이터로 변환한 다음 BinderProxy를 통해 BpBinder에 전달한다.<br>⑥ foo() 서비스 스텁 메서드 실행(서비스) : BBinder는 바인더 드라이버로부터 바인더 RPC 데이터를 전달받아 JavaBBinder을 통해서 Binder의 execTransact() 메서드를 호출한다. 그러고 나서 IFooService.Stub 서비스 스텁의 onTransact() 메서드로 RPC 데이터가 전달되고 이 데이터를 분석하여 FooService의 foo() 서비스 스텁 메서드를 호출한다.  </p><p>자바 서비스 프레임워크의 가장 중요한 특징은 JNI를 통해 네이티브 서비스프레임워크의 기능을 재사용한다는 점이다. 특히 IPC 레이어에 위치한 바인더 IPC 처리를 위해 BinderProxy와 Binder 클래스가 JNI를 통해 BpBinder와 BBinder 클래스의 기능을 재사용한다는 점이 주목할만하다.  </p><h3 id="동작-메커니즘"><a href="#동작-메커니즘" class="headerlink" title="동작 메커니즘"></a>동작 메커니즘</h3><p>여기서 주목해서 살펴봐야 할 점은 각 클래스의 생성 과정과 JNI 네이티브 함수 설정 인데 이를 바탕으로 자바 서비스 프레임워크가 네이티브 서비스 프레임워크를 재사용하는 메커니즘을 이해할 수 있다.  </p><h4 id="자바-서비스-프레임워크-초기화"><a href="#자바-서비스-프레임워크-초기화" class="headerlink" title="자바 서비스 프레임워크 초기화"></a>자바 서비스 프레임워크 초기화</h4><p>app_process 프로세스가 실행되면 AndroidRuntime 클래스에서 startReg() 함수를 호출해서 JNI 네이티브 함수를 달빅 가상 머신으로 로딩한다. 이때 register_android_os_Binder() 함수를 호출해서 등록되는 JNI 네이티브 함수가 바로 자바 서비스 프레임워크와 관련이 있는 네이티브 함수들이다.  </p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-built_in">int</span> register<span class="hljs-constructor">_android_os_Binder(JNIEnv<span class="hljs-operator">*</span> <span class="hljs-params">env</span>)</span><br>&#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">int</span><span class="hljs-constructor">_register_android_os_Binder(<span class="hljs-params">env</span>)</span> &lt; <span class="hljs-number">0</span>)<br>        return -<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">int</span><span class="hljs-constructor">_register_android_os_BinderInternal(<span class="hljs-params">env</span>)</span> &lt; <span class="hljs-number">0</span>)<br>        return -<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">int</span><span class="hljs-constructor">_register_android_os_BinderProxy(<span class="hljs-params">env</span>)</span> &lt; <span class="hljs-number">0</span>)<br>        return -<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">int</span><span class="hljs-constructor">_register_android_os_Parcel(<span class="hljs-params">env</span>)</span> &lt; <span class="hljs-number">0</span>)<br>        return -<span class="hljs-number">1</span>;<br>    return <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>위의 코드는 register_android_os_Binder() 함수의 일부로 총 네 종류의 함수를 호출하고 있다. 함수명에서 마지막 단어는 JNI 네이티브 함수를 사용하는 자바 클래스의 이름을 나타낸다.  </p><h4 id="Binder"><a href="#Binder" class="headerlink" title="Binder"></a>Binder</h4><p>Binder 클래스를 사용하려면 달빅 가상 머신에 Binder의 네이티브 메서드를 위한 JNI 네이티브 함수를 등록해줘야 한다. 이전의 코드 int_register_android_os_Binder() 함수가 호출되면 Binder 클래스의 일부 정보를 전역 변수인 gBinderOffsets에 저장하고, Binder 클래스의 네이티브 메서드와 JNI 네이티브 함수를 매핑한다.  </p><figure class="highlight mel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs mel">static <span class="hljs-keyword">int</span> int_register_android_os_Binder(JNIEnv* <span class="hljs-keyword">env</span>)<br>&#123;<br>    jclass clazz;<br><br>    clazz = <span class="hljs-keyword">env</span>-&gt;FindClass(kBinderPathName);    <span class="hljs-comment">// 달빅 가상 머신에서 클래스를 찾아 Binder 클래스의 주요 정보 저장</span><br>    LOG_FATAL_IF(clazz == NULL, <span class="hljs-string">&quot;Unable to find class android.os.Binder&quot;</span>);<br><br>    gBinderOffsets.mClass = (jclass) <span class="hljs-keyword">env</span>-&gt;NewGlobalRef(clazz);    <span class="hljs-comment">// Binder 클래스 정보</span><br>    gBinderOffsets.mExecTransact    <span class="hljs-comment">// execTransact() 메서드 ID</span><br>        = <span class="hljs-keyword">env</span>-&gt;GetMethodID(clazz, <span class="hljs-string">&quot;execTransact&quot;</span>, <span class="hljs-string">&quot;(IIII)Z&quot;</span>);<br>    assert(gBinderOffsets.mExecTransact);<br><br>    gBinderOffsets.mObject    <span class="hljs-comment">// mOject 필드 ID</span><br>        = <span class="hljs-keyword">env</span>-&gt;GetFieldID(clazz, <span class="hljs-string">&quot;mObject&quot;</span>, <span class="hljs-string">&quot;I&quot;</span>);<br>    assert(gBinderOffsets.mObject);<br><br>    <span class="hljs-keyword">return</span> AndroidRuntime::registerNativeMethods(   <span class="hljs-comment">// Binder의 네이티브 메서드와 매핑되는 JNI 네이티브 함수를 달빅 가상 머신에 등록</span><br>        <span class="hljs-keyword">env</span>, kBinderPathName,<br>        gBinderMethods, NELEM(gBinderMethods));<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>Binder 객체 생성</strong>  </p><p>Binder 클래스는 바인더 IPC를 위해 BBinder의 기능을 사용하기 때문에 Binder 객체가 생성될 때 BBinder가 함께 생성돼야 한다. 다음 코드는 Binder 생성자의 소스 코드다. Binder는 생성자에서 init() 네이티브 메서드를 호출한다.  </p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs aspectj"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Binder</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">IBinder</span> </span>&#123;<br>    Private <span class="hljs-keyword">native</span> <span class="hljs-keyword">final</span> <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Binder</span><span class="hljs-params">()</span> </span>&#123;<br>      init();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>다음 코드에서는 JavaBBinderHolder 클래스의 객체를 생성한 후 SetIntField() JNI 함수를 이용해 Binder의 mObject 변수에 생성된 JavaBBinderHolder 인스턴스의 주소를 저장한다.  </p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">static void android<span class="hljs-constructor">_os_Binder_init(JNIEnv<span class="hljs-operator">*</span> <span class="hljs-params">env</span>, <span class="hljs-params">jobject</span> <span class="hljs-params">obj</span>)</span><br>&#123;<br>    JavaBBinderHolder* jbh = <span class="hljs-keyword">new</span> <span class="hljs-constructor">JavaBBinderHolder()</span>;<br>    <span class="hljs-keyword">if</span> (jbh<span class="hljs-operator"> == </span>NULL) &#123;<br>        jni<span class="hljs-constructor">ThrowException(<span class="hljs-params">env</span>, <span class="hljs-string">&quot;java/lang/OutOfMemoryError&quot;</span>, NULL)</span>;<br>        return;<br>    &#125;<br>    <span class="hljs-constructor">ALOGV(<span class="hljs-string">&quot;Java Binder %p: acquiring first ref on holder %p&quot;</span>, <span class="hljs-params">obj</span>, <span class="hljs-params">jbh</span>)</span>;<br>    jbh-&gt;inc<span class="hljs-constructor">Strong((<span class="hljs-params">void</span><span class="hljs-operator">*</span>)</span>android_os_Binder_init);<br>    env-&gt;<span class="hljs-constructor">SetIntField(<span class="hljs-params">obj</span>, <span class="hljs-params">gBinderOffsets</span>.<span class="hljs-params">mObject</span>, (<span class="hljs-params">int</span>)</span>jbh);<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>JavaBBinder 객체 생성</strong>  </p><p>Binder 클래스의 객체가 생성될 때 BBinder 클래스의 객체가 함께 생성돼야 하는데도 Binder 객체 생성 과정에서도 BBinder 객체가 생성되는 곳은 보이지 않는다. 대신 JavaBBinderHolder 클래스의 객체를 생성하는 코드는 확인할 수 있다.<br>JavaBBinderHolder 클래스의 생성자는 단순히 mObject 변수에 Binder 객체의 주소값을 저장할 뿐이다.  </p><p>실제로 JavaBBinder의 인스턴스는 JavaBBinderHolder의 get() 함수에서 생성된다. 다음 코드를 보면 get() 함수에서 직접 JavaBBinder 클래스의 인스턴스를 생성하는 것을 확인할 수 있다. JavaBBinder는 BBinder를 상속받아 구현한 클래스이므로 JavaBBinder 객체를 생성하면 BBinder의 객체도 생성되는 것으로 볼 수 있다.  </p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm"><span class="hljs-built_in">sp</span>&lt;<span class="hljs-keyword">JavaBBinder&gt; </span><span class="hljs-keyword">JavaBBinderHolder::get(JNIEnv* </span>env)<br>&#123;<br>    AutoMutex _l(mLock);<br>    <span class="hljs-built_in">sp</span>&lt;<span class="hljs-keyword">JavaBBinder&gt; </span><span class="hljs-keyword">b </span>= mBinder.promote();<br>    if (<span class="hljs-keyword">b </span>== NULL) &#123;<br>        <span class="hljs-keyword">b </span>= new <span class="hljs-keyword">JavaBBinder(env, </span>mObject);<br>        mBinder = <span class="hljs-keyword">b;</span><br><span class="hljs-keyword"></span>    &#125;<br><br>    return <span class="hljs-keyword">b;</span><br><span class="hljs-keyword"></span>&#125;<br></code></pre></td></tr></table></figure><p>다음 그림은 Binder 객체와 JavaBBinder 객체가 생성되는 과정을 요약해서 나타낸 것이다.  </p><p><img src="/images/post/sf8.png" alt="sf8" title="sf8">  </p><p><strong>Binder 클래스와 JavaBBinder 서비스 스텁 클래스의 상호 작용</strong>  </p><p>BBinder의 transact()가 호출되면 기본적으로 onTransact()가 호출된다. BBinder에서 기본으로 제공하는 바인더 RPC 함수 이외에 새로운 기능을 제공하려면 BBinder를 상속받은 서비스 스텁 클래스에서 onTransact() 메서드를 재정의해야 한다. BBinder 클래스를 상속한 JavaBBinder 서비스 스텁 클래스는 onTransact() 함수에서 Binder의 execTransact() 메서드를 호출한다.  </p><p>다음 코드는 JavaBBinder의 onTransact() 함수다. CallBooleanMethod() JNI 함수를 호출해서 Binder의 execTransact() 메서드를 호출한다.  </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">status_t</span> <span class="hljs-title">JavaBBinder::onTransact</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">       <span class="hljs-type">uint32_t</span> code, <span class="hljs-type">const</span> Parcel&amp; data, Parcel* reply, <span class="hljs-type">uint32_t</span> flags = <span class="hljs-number">0</span>)</span></span><br><span class="hljs-function">   </span>&#123;<br>       JNIEnv* env = <span class="hljs-built_in">javavm_to_jnienv</span>(mVM);<br>       :<br>       jboolean res = env-&gt;<span class="hljs-built_in">CallBooleanMethod</span>(mObject, gBinderOffsets.mExecTransact,<br>           code, <span class="hljs-built_in">reinterpret_cast</span>&lt;jlong&gt;(&amp;data), <span class="hljs-built_in">reinterpret_cast</span>&lt;jlong&gt;(reply), flags);<br>       :<br>       <span class="hljs-keyword">return</span> res != JNI_FALSE ? NO_ERROR : UNKNOWN_TRANSACTION;<br>  &#125;<br></code></pre></td></tr></table></figure><p>Binder 클래스의 execTransact() 메서드가 호출되면 onTransact() 메서드를 호출한다.  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">execTransact</span><span class="hljs-params">(<span class="hljs-type">int</span> code, <span class="hljs-type">int</span> dataObj, <span class="hljs-type">int</span> replyObj,</span><br><span class="hljs-params">        <span class="hljs-type">int</span> flags)</span> &#123;<br>    <span class="hljs-type">Parcel</span> <span class="hljs-variable">data</span> <span class="hljs-operator">=</span> Parcel.obtain(dataObj);<br>    <span class="hljs-type">Parcel</span> <span class="hljs-variable">reply</span> <span class="hljs-operator">=</span> Parcel.obtain(replyObj);<br><br>    <span class="hljs-type">boolean</span> res;<br>    <span class="hljs-keyword">try</span> &#123;<br>        res = onTransact(code, data, reply, flags);<br>    &#125; <span class="hljs-keyword">catch</span> (RemoteException e) &#123;<br>        reply.setDataPosition(<span class="hljs-number">0</span>);<br>        reply.writeException(e);<br>        res = <span class="hljs-literal">true</span>;<br>    &#125; <span class="hljs-keyword">catch</span> (RuntimeException e) &#123;<br>        reply.setDataPosition(<span class="hljs-number">0</span>);<br>        reply.writeException(e);<br>        res = <span class="hljs-literal">true</span>;<br>    &#125; <span class="hljs-keyword">catch</span> (OutOfMemoryError e) &#123;<br>        <span class="hljs-type">RuntimeException</span> <span class="hljs-variable">re</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(<span class="hljs-string">&quot;Out of memory&quot;</span>, e);<br>        reply.setDataPosition(<span class="hljs-number">0</span>);<br>        reply.writeException(re);<br>        res = <span class="hljs-literal">true</span>;<br>    &#125;<br>    reply.recycle();<br>    data.recycle();<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="BinderProxy"><a href="#BinderProxy" class="headerlink" title="BinderProxy"></a>BinderProxy</h4><p><strong>BinderProxy 클래스를 위한 JNI 설정</strong>  </p><p>BinderProxy 클래스를 사용하려면 달빅 가상 머신에 BinderProxy의 네이티브 메서드를 위한 JNI 네이티브 함수를 먼저 등록해줘야 한다.  </p><p><strong>BinderProxy 객체 생성</strong>  </p><p>BinderProxy 클래스도 바인더 IPC를 수행하는데 네이티브 서비스 프레임워크의 BpBinder의 기능을 사용하므로 BinderProxy 객체가 생성될 때 BpBinder 객체가 필요하다. 따라서 BinderProxy 객체도 Parcel의 readStrongBinder() 메서드를 호출할 때 생성된다.  </p><p><img src="/images/post/sf9.png" alt="sf9" title="sf9">  </p><p>javaObjectForIBinder() 함수를 살펴보면 NewObject() JNI 함수를 이용해 BinderProxy 객체를 생성한 다음 BinderProxy의 mObject 변수에 BpBinder 객체를 저장한다.  </p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">jobject java<span class="hljs-constructor">ObjectForIBinder(JNIEnv<span class="hljs-operator">*</span> <span class="hljs-params">env</span>, <span class="hljs-params">const</span> <span class="hljs-params">sp</span>&lt;IBinder&gt;&amp; <span class="hljs-params">val</span>)</span><br>&#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">val</span><span class="hljs-operator"> == </span>NULL) return NULL;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">val</span>-&gt;check<span class="hljs-constructor">Subclass(&amp;<span class="hljs-params">gBinderOffsets</span>)</span>) &#123;<br>        jobject <span class="hljs-keyword">object</span> = static_cast&lt;JavaBBinder*&gt;(<span class="hljs-keyword">val</span>.get<span class="hljs-literal">()</span>)-&gt;<span class="hljs-keyword">object</span><span class="hljs-literal">()</span>;<br>        <span class="hljs-constructor">LOGDEATH(<span class="hljs-string">&quot;objectForBinder %p: it&#x27;s our own %p!\n&quot;</span>, <span class="hljs-params">val</span>.<span class="hljs-params">get</span>()</span>, <span class="hljs-keyword">object</span>);<br>        return <span class="hljs-keyword">object</span>;<br>    &#125;<br>    :<br>    <span class="hljs-keyword">object</span> = env-&gt;<span class="hljs-constructor">NewObject(<span class="hljs-params">gBinderProxyOffsets</span>.<span class="hljs-params">mClass</span>, <span class="hljs-params">gBinderProxyOffsets</span>.<span class="hljs-params">mConstructor</span>)</span>;<br><br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">object</span> != NULL) &#123;<br>        env-&gt;<span class="hljs-constructor">SetIntField(<span class="hljs-params">object</span>, <span class="hljs-params">gBinderProxyOffsets</span>.<span class="hljs-params">mObject</span>, (<span class="hljs-params">int</span>)</span><span class="hljs-keyword">val</span>.get<span class="hljs-literal">()</span>);<br>    &#125;<br><br>    return <span class="hljs-keyword">object</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>BinderProxy 클래스와 BpBinder 클래스의 상호작용</strong>  </p><p>android_os_BinderProxy_transact() 함수를 살펴보면 BinderProxy의 mObject 변수가 참조하고 있는 BpBidner 객체의 주소를 획득하여 transact() 함수를 호출한다.  </p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs haskell"><span class="hljs-title">static</span> jboolean android_os_BinderProxy_transact(<span class="hljs-type">JNIEnv</span>* env, jobject obj,<br>        jint code, jobject dataObj, jobject replyObj, jint flags) // throws <span class="hljs-type">RemoteException</span><br>&#123;<br>    <span class="hljs-type">Parcel</span>* <span class="hljs-class"><span class="hljs-keyword">data</span> = parcelForJavaObject(<span class="hljs-title">env</span>, <span class="hljs-title">dataObj</span>);</span><br>    <span class="hljs-type">Parcel</span>* reply = parcelForJavaObject(env, replyObj);<br>    <span class="hljs-type">IBinder</span>* target = (<span class="hljs-type">IBinder</span>*)<br>        env-&gt;<span class="hljs-type">GetIntField</span>(obj, gBinderProxyOffsets.mObject);<br><br>    status_t err = target-&gt;transact(code, *<span class="hljs-class"><span class="hljs-keyword">data</span>, reply, flags);</span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="Parcel"><a href="#Parcel" class="headerlink" title="Parcel"></a>Parcel</h4><p>Parcel 클래스는 바인더 IPC가 진행되는 동안 송신측에서 수신측으로 전달되는 데이터를 저장하는 데 사용한다. 특히, Parcel은 내부 버퍼 안에 IBinder 객체 레퍼런스를 가지고 있어 프로세스를 가로질러 이동할 때도 레퍼런스 값을 유지해야 한다. 따라서 이런 기능을 자바 서비스 프레임워크에서도 제공하기 위해 JNI를 통해 Parcel 클래스(C++)의 기능을 재사용한다.  </p><p><strong>Parcel 클래스의 JNI 설정</strong>  </p><p>Parcel 클래스의 네이티브 메서드는 JNI 함수를 통해 Parcel(C++) 클래스에 포함된 이름이 동일한 멤버 함수를 대부분 호출한다.  </p><p><strong>Parcel 객체 생성</strong>  </p><p>Parcel 객체를 생성하는 과정은 Binder, BinderProxy 클래스와는 조금 다르다. Parcel의 생성자를 보면 private로 선언돼 있어 인스턴스를 획득하려면 Parcel의 obtain() 메서드를 사용해야 한다.  </p><p>obtain() 메서드에서는 Parcel의 생성자가 호출된다. 생성자 내부에서는 init() 네이티브 메서드가 호출되어 JNI로 매핑된 android_os_Parcel_init() 함수가 실행되면 다음 코드에서 Parcel(C++) 클래스의 인스턴스를 생성하는 것을 확인할 수 있다.  </p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">static void android<span class="hljs-constructor">_os_Parcel_init(JNIEnv<span class="hljs-operator">*</span> <span class="hljs-params">env</span>, <span class="hljs-params">jobject</span> <span class="hljs-params">clazz</span>, <span class="hljs-params">jint</span> <span class="hljs-params">parcelInt</span>)</span><br>&#123;<br>    Parcel* parcel = (Parcel*)parcelInt;<br>    <span class="hljs-built_in">int</span> own = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">if</span> (!parcel) &#123;<br>        own = <span class="hljs-number">1</span>;<br>        parcel = <span class="hljs-keyword">new</span> Parcel;<br>    &#125;<br><br>    env-&gt;<span class="hljs-constructor">SetIntField(<span class="hljs-params">clazz</span>, <span class="hljs-params">gParcelOffsets</span>.<span class="hljs-params">mOwnObject</span>, <span class="hljs-params">own</span>)</span>;<br>    env-&gt;<span class="hljs-constructor">SetIntField(<span class="hljs-params">clazz</span>, <span class="hljs-params">gParcelOffsets</span>.<span class="hljs-params">mObject</span>, (<span class="hljs-params">int</span>)</span>parcel);<br>&#125;<br></code></pre></td></tr></table></figure><p>다음 그림은 Parcel 객체가 생성되는 과정을 그림으로 정리한 것이다.  </p><p><img src="/images/post/sf10.png" alt="sf10" title="sf10">  </p><p><strong>Parcel 클래스(Java)와 Parcel 클래스(C++) 간의 상호작용</strong>  </p><p>일반적으로 Parcel 클래스는 서비스 프록시에서 바인더 RPC 데이터를 저장할 때 사용된다. 다음 그림은 BinderProxy의 transact() 메서드가 호출된 후 Parcel 객체의 이동경로를 보여준다. 서비스 프록시에서 바인더 RPC를 진행하면 달빅 가상 머신에서 생성된 Parcel 객체가 서비스에게 전달돼야 하는데 그러기 위해서는 Parcel(Java) 객체를 Parcel(C++) 객체로 변환해야 한다. 이를 위해 자바 서비스 프레임워크에서는 parcelForJavaObject()라는 함수를 제공한다.  </p><p><img src="/images/post/sf11.png" alt="sf11" title="sf11">  </p><p>반대로 BBinder transact() 함수를 통해 Parcel(c++) 객체를 전달받으면 Parcel(C++) 객체를 Parcel(Java) 객체로 변환해야 한다.  </p><h3 id="자바-시스템-서비스-구현"><a href="#자바-시스템-서비스-구현" class="headerlink" title="자바 시스템 서비스 구현"></a>자바 시스템 서비스 구현</h3><p>개발자가 안드로이드 플랫폼에서 동작하는 자바 시스템 서비스를 개발하려면 기존 자바 시스템 서비스의 프로그램 구조를 파악하는 것이 가장 효과적이다. 여기서는 자바 시스템 서비스 가운데 알람 매니저 서비스를 토대로 시스템 서비스의 구조를 파악해본다.  </p><p><img src="/images/post/sf12.png" alt="sf12" title="sf12">  </p><h4 id="알람-매니저-서비스의-구조-분석"><a href="#알람-매니저-서비스의-구조-분석" class="headerlink" title="알람 매니저 서비스의 구조 분석"></a>알람 매니저 서비스의 구조 분석</h4><p>AlarmManagerService 클래스의 계층 구조를 클래스 다이어그램으로 나타낸 것이다. 먼저 상단에는 자바 서비스 프레임워크의 구성요소인 IInterface 인터페이스와 Binder 클래스가 위치하며, IAlarmManager 서비스 인터페이스와 서비스 스텁에서 이 클래스를 상속하고 있다. 다음으로 AIDL(Android Interface Definition Language)을 통해 자동으로 생성도니 서비스 스텁 클래스와 서비스 프록시 클래스가 위치한다. 마지막으로 그림 하단에는 실질적인 알람 매니저 서비스를 구현하고 있는 AlarmManagerService 클래스와 AlarmManager 래퍼 클래스가 있다.  </p><p><strong>알람 매니저 서비스 구현 방식</strong>  </p><p>알람 매니저 서비스는 AIDL을 이용해 해당 클래스를 자동으로 생성한다. IAlarmManager 인터페이스 내부에는 총 5개의 메서드가 선언돼 있다. 다음의 코드를 AIDL 컴파일러로 컴파일하면 알람 매니저 서비스의 서비스 인터페이스, 서비스 프록시, 서비스 스텁 클래스가 자동으로 생성된다.  </p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">interface IAlarmManager &#123;<br>    void set(<span class="hljs-built_in">int</span> <span class="hljs-keyword">type</span>, long triggerAtTime, <span class="hljs-keyword">in</span> PendingIntent operation);<br>    void set<span class="hljs-constructor">Repeating(<span class="hljs-params">int</span> <span class="hljs-params">type</span>, <span class="hljs-params">long</span> <span class="hljs-params">triggerAtTime</span>, <span class="hljs-params">long</span> <span class="hljs-params">interval</span>, <span class="hljs-params">in</span> PendingIntent <span class="hljs-params">operation</span>)</span>;<br>    void set<span class="hljs-constructor">InexactRepeating(<span class="hljs-params">int</span> <span class="hljs-params">type</span>, <span class="hljs-params">long</span> <span class="hljs-params">triggerAtTime</span>, <span class="hljs-params">long</span> <span class="hljs-params">interval</span>, <span class="hljs-params">in</span> PendingIntent <span class="hljs-params">operation</span>)</span>;<br>    void set<span class="hljs-constructor">Time(<span class="hljs-params">long</span> <span class="hljs-params">millis</span>)</span>;<br>    void set<span class="hljs-constructor">TimeZone(String <span class="hljs-params">zone</span>)</span>;<br>    void remove(<span class="hljs-keyword">in</span> PendingIntent operation);<br>&#125;<br></code></pre></td></tr></table></figure><p>AIDL로부터 자동 생성된 서비스 스텁 클래스는 Binder 클래스의 onTransact() 메서드를 재정의하여 시스템의 바인더 RPC 기능을 추가하므로 알람 매니저 서비스의 서비스 스텁 클래스도 onTransact() 메서드를 재정의하여 IAlarmManager 인터페이스에 정의된 5개의 메서드 관련 코드를 추가했다.  </p><p><strong>알람 매니저 서비스 사용</strong>  </p><p>애플리케이션 개발자가 시스템 서비스를 사용하려면 SDK의 getSystemService() 메서드를 이용해야 한다. 알람 매니저 서비스는 Context 클래스의 getSystemService() 메서드를 호출하면 애플리케이션에서 사용할 수 있으며, ApplicationContext 클래스의 getAlarmManager() 메서드에서 이를 구현하고 있다.  </p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-keyword">private</span> AlarmManager get<span class="hljs-constructor">AlarmManager()</span> &#123;<br>    synchronized (sSync) &#123;<br>        <span class="hljs-keyword">if</span> (sAlarmManager<span class="hljs-operator"> == </span>null) &#123;<br>            IBinder b = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">ServiceManager</span>.</span></span>get<span class="hljs-constructor">Service(ALARM_SERVICE)</span>; <span class="hljs-comment">// BinderProxy 객체를 반환받는다.</span><br>            IAlarmManager service = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">IAlarmManager</span>.</span><span class="hljs-module"><span class="hljs-identifier">Stub</span>.</span></span><span class="hljs-keyword">as</span><span class="hljs-constructor">Interface(<span class="hljs-params">b</span>)</span>; <span class="hljs-comment">//서비스 프록시 클래스의 객체를 획득한다.</span><br>            sAlarmManager = <span class="hljs-keyword">new</span> <span class="hljs-constructor">AlarmManager(<span class="hljs-params">service</span>)</span>; <span class="hljs-comment">// 인스턴스를 생성하여 반환한다.</span><br>        &#125;<br>    &#125;<br>    return sAlarmManager;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="HelloWorldService-시스템-서비스의-구현"><a href="#HelloWorldService-시스템-서비스의-구현" class="headerlink" title="HelloWorldService 시스템 서비스의 구현"></a>HelloWorldService 시스템 서비스의 구현</h4><p><strong>HelloWorldService 설계</strong>  </p><p>AIDL을 이용해 HelloWorldService 서비스 인터페이스, 서비스 프록시, 서비스 스텁 클래스를 자동으로 생성한 후 HelloWorldService와 HelloWorldManager를 구현해보자.  </p><p><strong>HelloWorldService 구현</strong>  </p><p>AIDL을 이용해 IHelloWorld.aidl 소스 파일을 작성한다.  </p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs ada"><span class="hljs-keyword">package</span> <span class="hljs-title">android.app;</span><br><br><span class="hljs-keyword">interface</span> IHelloWorld&#123;<br>  printHello();<br>&#125;<br></code></pre></td></tr></table></figure><p>다음으로 안드로이드 플랫폼을 빌드할 때 IHelloWorld.aidl 파일이 AIDL 컴파일러에 의해 컴파일 될 수 있게 Android.mk 설정 파일을 수정한다.<br>LOCAL_SRC_FILES 항목에서 IHelloWorld.aidl을 추가하면 된다.  </p><p><strong>HelloWorldService 서비스의 구현</strong>  </p><p>서비스는 서비스 스텁 클래스를 상속받아 구현하면 된다.  </p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-keyword">package</span> android.app;<br><br><span class="hljs-keyword">import</span> android.os.<span class="hljs-type">RemoteException</span>;<br><span class="hljs-keyword">import</span> android.content.<span class="hljs-type">Context</span>;<br><span class="hljs-keyword">import</span> android.util.<span class="hljs-type">Log</span>;<br><br>public <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HelloWorldService</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">IHelloWorld</span>.<span class="hljs-title">Stub</span> </span>&#123;<br><br>  <span class="hljs-keyword">private</span> static <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-type">TAG</span> = <span class="hljs-string">&quot;HelloWorldService&quot;</span>;<br>  <span class="hljs-type">Context</span> mContext;<br><br>  public <span class="hljs-type">HelloWorldService</span>(<span class="hljs-type">Context</span> context)&#123;<br><br>    mContext = context;<br>  &#125;<br><br>  public void printHello() <span class="hljs-keyword">throws</span> <span class="hljs-type">RemoteException</span> &#123;<br>    <span class="hljs-type">Log</span>.i(<span class="hljs-type">TAG</span>, <span class="hljs-string">&quot;Hello, World!&quot;</span>);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>HelloWorldService 서비스의 등록</strong>  </p><p>자바 시스템 서비스는 ServerThread 클래스의 run() 메서드에서 생성하여 안드로이드 플랫폼에 등록한다. ServerThread의 run() 메서드에서 HelloWorldService의 인스턴스를 생성하고 자바 서비스 매니저의 addService() 메서드를 통해 시스템에 드록한다.  </p><h4 id="HelloWorldService-시스템-서비스의-이용"><a href="#HelloWorldService-시스템-서비스의-이용" class="headerlink" title="HelloWorldService 시스템 서비스의 이용"></a>HelloWorldService 시스템 서비스의 이용</h4><p>이전까지 서비스를 구현해서 시스템에 등록했다. HelloWorldService 시스템 서비스를 애플리케이션 개발자들이 이용할 수 있게끔 HelloWorldManager 클래스를 구현해보자.  </p><p><strong>HelloWorldManager 구현</strong>  </p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs aspectj"><span class="hljs-keyword">package</span> android.app;<br><br><span class="hljs-keyword">import</span> android.os.RemoteException;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HelloWorldManager</span></span><br><span class="hljs-class"></span>&#123;<br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> IHelloWorld mService;<br><br>  HelloWorldManager(IHelloWorld service) &#123;    <span class="hljs-comment">// IHelloWorld.Stub.Proxy 클래스의 인스턴스를 인자로 전달받는다.</span><br>    mService = service;<br>  &#125;<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">printHello</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">try</span> &#123;   <span class="hljs-comment">// IHelloWorld.Stub.Proxy 객체의 printHello() 메서드가 호출된다.</span><br>      mService.printHello();<br>    &#125; <span class="hljs-keyword">catch</span>(RemoteException) &#123;<br><br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>HelloWorldManager 획득</strong>  </p><p>애플리케이션 개발자는 getSystemService() 메서드를 통해 시스템 서비스를 사용할 수 있다.  </p><p>다음 그림은 HelloWorldService 서비스에서 HelloWorldManager 객체를 획득하는 과정을 정리한 그림이다.  </p><p><img src="/images/post/sf13.png" alt="sf13" title="sf13">  </p><p>① 서비스 사용자는 HelloWorldService 서비스를 이용하기 위해 getSystemService() 메서드를 호출하면 getSystemService() 메서드 내부에서 getHelloWorldManager() 메서드를 호출한다.<br>② getHelloWorldManager() 메서드는 서비스 매니저에게 HelloWorldService 서비스의 검색을 요청한다. 검색에 성공하면 HelloWorldService 서비스를 가리키는 BinderProxy 객체를 반환한다.<br>③ getHelloWorldManager() 메서드는 반환받은 BinderProxy 객체를 HelloWorld.Stub 서비스 스텁의 asInterface() 메서드에 넘겨줘 IHelloWorld.Stub.Proxy 서비스 프록시 객체를 생성한다.<br>④ getHelloWorldManager() 메서드는 생성한 IHelloWorld.Stub.Proxy 서비스 프록시 객체를 HelloWorldManager 생성자의 인자로 넘겨줘 객체를 생성한다. HelloWorldManager는 mService 변수에 넘겨 받은 IHelloWorld.Stub.Proxy 서비스 프록시 객체를 저장한다.<br>⑤ 최종적으로 HelloWorldService 서비스를 사용하기 위해 getSystemService() 메서드를 호출한 곳에서는 HelloWorldManager의 객체를 반환받ㄷ는다. 애플리케이션은 HelloWorldService 서비스를 사용하기 위해 HelloWorldManager의 메서드를 호출하면 IHelloWorld.Stub.Proxy 서비스 프록시의 메서드가 호출되어 HelloWorldService 서비스와 바인더 RPC를 사용하여 상호작용한다.  </p><h4 id="HelloWorldService-시스템-서비스-빌드"><a href="#HelloWorldService-시스템-서비스-빌드" class="headerlink" title="HelloWorldService 시스템 서비스 빌드"></a>HelloWorldService 시스템 서비스 빌드</h4><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">make</span><br></code></pre></td></tr></table></figure><p>명령어를 통해 안드로이드 플랫폼을 컴파일 한다.  </p>]]></content>
    
    
    <categories>
      
      <category>Android</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Android</tag>
      
      <tag>인사이드 안드로이드</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[인사이드 안드로이드] 챕터 7 - 안드로이드 바인더 IPC</title>
    <link href="/chapter7/"/>
    <url>/chapter7/</url>
    
    <content type="html"><![CDATA[<h1 id="인사이드-안드로이드"><a href="#인사이드-안드로이드" class="headerlink" title="[인사이드 안드로이드]"></a>[인사이드 안드로이드]</h1><h2 id="Chapter7-안드로이드-바인더-IPC"><a href="#Chapter7-안드로이드-바인더-IPC" class="headerlink" title="Chapter7 - 안드로이드 바인더 IPC"></a>Chapter7 - 안드로이드 바인더 IPC</h2><h3 id="리눅스-메모리-공간과-바인더-드라이버"><a href="#리눅스-메모리-공간과-바인더-드라이버" class="headerlink" title="리눅스 메모리 공간과 바인더 드라이버"></a>리눅스 메모리 공간과 바인더 드라이버</h3><p>바인더를 이해하려면 먼저 안드로이드의 기반 커널인 리눅스 커널의 메모리 공간을 이해할 필요가 있다. 총 4GB에 달하는 가상 주소 공간은 3GB의 사용자 공간과 1GB의 커널 공간으로 나뉜다. 사용자 코드와 관련 라이브러리는 사용자 공간의 코드 영역, 데이터 영역, 스택 영역에서 동작하고, 커널 공간에서 동작해야 할 코드는 커널 공간의 각 영역에서 동작한다. 그리고 프로세스는 다음과 같이 각자 독립된 주소 공간을 가지고 별개로 동작한다.  </p><p><img src="/images/post/binder1.png" alt="binder1" title="binder1">  </p><p>자신의 독립된 공간을 가진 프로세스가 다른 프로세스에게 <strong>데이터를 전달할 때는 프로세스간 공유가 가능한 커널 공간을 이용한다.</strong> 프로세스는 독립적인 사용자 공간을 가지지만 커널 공간은 공유할 수 있다. 커널 공간을 이용해 두 프로세스 사이의 메시지를 주고 받는 IPC를 수행한다.  </p><p>기존 리눅스에서도 IPC 도구를 제공하지만, 안드로이드에서는 단순히 메시지를 전달하는 IPC 개념이 아니라 상대방 프로세스에 존재하는 함수까지 호출할 수 있는 바인더라는 IPC 도구를 채택해 프로세스 간의 RPC를 지원한다.  </p><p>바인더는 프로세스들이 사용자 공간을 공유하지 않는다는 제약 조건상에서 프로세스간 통신을 제공하기 위해 다음처럼 커널 공간에서 동작하는 Binder(IPC) Driver라는 추상화된 드라이버를 이용한다.  </p><p><img src="/images/post/binder2.png" alt="binder2" title="binder2">  </p><p>안드로이드에서 바인더 드라이버를 추가해서 프로세스 간 통신을 수행하는 이유는 다음과 같다. 바인더는 사용자 공간에서 접근할 수 없는 공간인 커널 공간을 이용해 <strong>데이터의 신뢰성을 확보</strong>할 수 있으며 <strong>IPC 간의 보안 문제도 동시에 해결</strong>할 수 있다.  </p><h3 id="안드로이드-바인더-모델"><a href="#안드로이드-바인더-모델" class="headerlink" title="안드로이드 바인더 모델"></a>안드로이드 바인더 모델</h3><p>IPC 데이터는 함수 호출과 관련된 내용, 즉 사용하고자 하는 서비스에 해당하는 번호와 호출할 함수명, 바인더 프로토콜로 구성된다.<br><em>서비스 번호는 안드로이드에서 동작중인 여러 서비스를 구분하기 위한 것.</em><br><em>함수명은 서비스 서버에서 동작하는 여러 서비스 가운데 서비스 클라이언트가 호출할 함수를 찾기 위한 것.</em><br><em>바인더 프로토콜은 바인더 드라이버와 바인더를 이용하는 프로세스 간의 IPC 데이터를 처리하는 규약.</em>  </p><p><img src="/images/post/binder3.png" alt="binder3" title="binder3">  </p><p><em>핸들은 서비스를 구별하는 번호</em><br><em>RPC 코드와 RPC 데이터는 서비스에서 호출할 함수와 함수의 인자</em><br><em>바인터 프로토콜은 IPC 데이터의 처리 방법</em>  </p><h4 id="바인더-IPC-데이터의-전달"><a href="#바인더-IPC-데이터의-전달" class="headerlink" title="바인더 IPC 데이터의 전달"></a>바인더 IPC 데이터의 전달</h4><p>바인더 드라이버는 문자 디바이스 드라이버처럼 open()이나 ioctl()과 같은 시스템 콜을 통해 접근 가능하다. 다음 그림은 시스템 콜과 바인더 드라이버에 포함된 파일 연산 함수와의 연결 관계를 보여준다.  </p><p><img src="/images/post/binder4.png" alt="binder4" title="binder4">  </p><p>① 바인더를 통해 RPC를 시도하는 응용 프로그램은 open() 시스템 콜을 통해 바인더 드라이버의 파일 디스크립터를 얻는다.<br>② mmap() 시스템콜을 통해 커널 내에서 IPC 데이터를 수신하기 위한 공유 공간을 확보한다.<br>③ ioctl() 함수의 인자로 바인더 드라이버에 IPC 데이터를 전달한다. ioctl(파일 디스크립터, ioctl 명령어, 데이터 타입)  </p><h4 id="바인더-IPC-데이터의-흐름"><a href="#바인더-IPC-데이터의-흐름" class="headerlink" title="바인더 IPC 데이터의 흐름"></a>바인더 IPC 데이터의 흐름</h4><p>바인더 IPC 데이터가 서비스 클라이언트에서 서비스 서버로 전달되기 까지 어떠한 과정을 거치는지 살펴보자.<br>그림은 서비스 클라이언트에서 서비스 서버에 존재하는 서비스의 함수를 호출하는 과정을 보여준다.  </p><p><img src="/images/post/binder5.png" alt="binder5" title="binder5">  </p><ul><li>서비스 계층 : 특정 기능을 수행하는 서비스의 함수가 존재하는 계층이다. 서비스 클라이언트는 이 계층에서 사용하고자 하는 서비스의 함수를 가상으로 호출하고, 서비스 서버는 서비스 클라이언트가 요청한 서비스의 함수를 실제로 호출한다.  </li><li>RPC 계층 : 서비스 클라이언트는 이 계층에서 서비스의 함수를 호출하기 위한 RPC 코드와 RPC 데이터를 생성한다. 서비스 서버는 전달받은 RPC 코드를 토대로 함수를 찾고 RPC 데이터를 전달한다.  </li><li>IPC 계층 : RPC 계층에서 만든 RPC 코드와 RPC 데이터를 바인더 드라이버에 전달하기위한 바인더 IPC 데이터로 캡슐화하는 역할을 한다.  </li><li>바인더 드라이버 계층 : IPC 계층으로부터 전달받은 바인더 IPC 데이터를 통해 서비스를 가진 서비스서버를 찾은 후 IPC 데이터를 전달한다.</li></ul><p>서비스 클라이언트가 바인더 드라이버에게 ioctl() 시스템콜을 통해 바인더 IPC 데이터를 전달하면 바인더 드라이버는 이 데이터를 서비스 서버에게 전달한다. 이때 바인더 드라이버는 IPC 데이터에서 바인더 프로토콜을 파악하여 데이터 전달 여부를 결정한다.  </p><h4 id="바인더-프로토콜"><a href="#바인더-프로토콜" class="headerlink" title="바인더 프로토콜"></a>바인더 프로토콜</h4><p>바인더 프로토콜은 바인더 IPC 데이터에 포함되어 IPC 계층에서 바인더 드라이버로 전달되거나 바인더 드라이버에서 IPC 계층으로 전달된다. 바인더 프로토콜은 전달 방향에 따라 두 가지로 분류된다.  </p><p><img src="/images/post/binder6.png" alt="binder6" title="binder6">  </p><p>바인더 프로토콜은 흔히 네트워크 상에서 쓰는 프로토콜처럼 데이터를 송신하는 측과 수신하는 측에서 모두 알고 있는 규약이다. 따라서 바인더 IPC를 이용하는 프로세스와 바인더 드라이버는 헤더 파일에 바인더 프로토콜을 정의하고 있다.  </p><p>다음 그림은 바인더 프로토콜에 따른 바인더 드라이버와 IPC 데이터 수신 측의 동작을 간략히 나타낸 것이다.  </p><p><img src="/images/post/binder7.png" alt="binder7" title="binder7">  </p><h4 id="RPC-코드와-RPC-데이터"><a href="#RPC-코드와-RPC-데이터" class="headerlink" title="RPC 코드와 RPC 데이터"></a>RPC 코드와 RPC 데이터</h4><p>서비스 클라이언트는 서비스 서버에 존재하는 서비스의 함수를 사용하기 위해 각 함수에 해당하는 식별자를 바인더 IPC 데이터에 담아 전달하는데, 이를 RPC 코드라고 한다. 그리고 함수의 인자 역시 IPC 데이터에 담아 전달하는데, 이것은 RPC 데이터라고 한다.<br>다음은 Audio Flinger 서비스를 사용하는 MP# 애플리케이션의 예이다.  </p><p><img src="/images/post/binder8.png" alt="binder8" title="binder8">  </p><h4 id="바인더-어드레싱"><a href="#바인더-어드레싱" class="headerlink" title="바인더 어드레싱"></a>바인더 어드레싱</h4><p>안드로이드에는 다양한 서비스를 모두 목록화해서 관리하는 컨텍스트 매니저(Context Manager)라는 특별한 프로세스가 있다. 컨텍스트 매니저는 서비스마다 핸들(바인더 IPC의 목적지 주소로 사용)이라는 번호 값을 할당하고, 서비스의 추가&#x2F;검색 등의 관리 기능을 수행한다.  </p><p>바인더 드라이버는 IPC 데이터의 핸들을 가지고 서비스 서버를 찾는데, 이러한 과정을 바인더 어드레싱(Binder Addressing) 이라고 정의한다. 바인더 어드레싱을 위해 서비스 서버는 자신이 가진 서비스에 대한 접근 정보를 컨텍스트 매니저에 등록해야 한다. 이러한 서비스 등록 과정에서 서비스 서버는 ADD_SERVICE라는 RPC 코드와 등록할 서비스 이름(RPC 데이터), 그리고 핸들을 0으로 지정하고 IPC 데이터에 실어 바인더 드라이버에 전달한다.  </p><p>다음 그림은 서비스 서버가 자신의 서비스를 컨텍스트 매니저에게 등록 할 때의 바인더 어드레싱을 나타낸다.  </p><p><img src="/images/post/binder9.png" alt="binder9" title="binder9">  </p><p>다음으로 서비스 클라이언트가 서비스를 검색 할 때의 바인더 어드레싱을 나타낸다.  </p><p><img src="/images/post/binder10.png" alt="binder10" title="binder10">  </p><p>마지막으로 서비스 클라이언트는 이전 단계에서 전달받은 참조 데이터의 번호를 핸들에 저장하고, 사용할 서비스의 함수에 해당하는 RPC 코드와 RPC 데이터를 IPC 데이터에 담아 서비스 서버로 전달하여 서비스A가 가진 함수를 호출한다.<br>다음 그림은 바인더 어드레싱을 통해 서비스를 사용하는 과정을 보여준다.  </p><p><img src="/images/post/binder11.png" alt="binder11" title="binder11">  </p>]]></content>
    
    
    <categories>
      
      <category>Android</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Android</tag>
      
      <tag>인사이드 안드로이드</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[인사이드 안드로이드] 챕터 6 - 안드로이드 서비스 개요(2)</title>
    <link href="/chapter6_2/"/>
    <url>/chapter6_2/</url>
    
    <content type="html"><![CDATA[<h1 id="인사이드-안드로이드"><a href="#인사이드-안드로이드" class="headerlink" title="[인사이드 안드로이드]"></a>[인사이드 안드로이드]</h1><h2 id="Chapter6-안드로이드-서비스-개요-2"><a href="#Chapter6-안드로이드-서비스-개요-2" class="headerlink" title="Chapter6 - 안드로이드 서비스 개요(2)"></a>Chapter6 - 안드로이드 서비스 개요(2)</h2><h3 id="안드로이드-시스템-서비스"><a href="#안드로이드-시스템-서비스" class="headerlink" title="안드로이드 시스템 서비스"></a>안드로이드 시스템 서비스</h3><p>안드로이드의 시스템 서비스는 디바이스 제어, 위치 정보 제공, 알람 설정 및 통지 메시지 표시 등과 같이 시스템의 가장 기본적인 핵심 기능들을 제공한다. 이러한 시스템 서비스는 애플리케이션 프레임워크 레이어와 라이브러리 레이어에 각각 존재한다.  </p><p><img src="/images/post/service4.png" alt="service4" title="service4">  </p><h4 id="시스템-서비스의-분류"><a href="#시스템-서비스의-분류" class="headerlink" title="시스템 서비스의 분류"></a>시스템 서비스의 분류</h4><h5 id="네이티브-시스템-서비스"><a href="#네이티브-시스템-서비스" class="headerlink" title="네이티브 시스템 서비스"></a>네이티브 시스템 서비스</h5><p>네이티브 시스템 서비스는 C++로 작성돼 있으며 라이브러리 레이어에서 동작한다.<br>주요 서비스로는 ① Audio Flinger와 ② Surface Flinger 등이 있다.  </p><p><strong>① Audio Flinger 서비스</strong>  </p><p>Audio Flinger 서비스는 여러 안드로이드 애플리케이션의 오디오 데이터를 믹싱해서 헤드폰이나 스피커처럼 <strong>다양한 오디오 출력 장치로 내보내는 역할</strong>을 한다. <strong>안드로이드장치에서 모든 오디오 데이터는 Audio Flinger를 거쳐 출력된다.</strong>  </p><p><img src="/images/post/service5.png" alt="service5" title="service5">  </p><p><strong>② Surface Flinger 서비스</strong>  </p><p>Surface Flinger는 다양한 애플리케이션에서 사용중인 <strong>Surface를 조합해 프레임 버퍼 장치로 렌더링</strong>해주는 서비스다.  </p><p><img src="/images/post/service6.png" alt="service6" title="service6">  </p><h5 id="자바-시스템-서비스"><a href="#자바-시스템-서비스" class="headerlink" title="자바 시스템 서비스"></a>자바 시스템 서비스</h5><p>자바 시스템 서비스는 안드로이드 부팅 시 SystemServer라는 시스템 프로세스에 의해 일괄적으로 실행되며, ① 코어 플랫폼 서비스와 ② 하드웨어 서비스로 나뉜다.  </p><p><strong>① 코어 플랫폼 서비스</strong>  </p><p>코어 플랫폼 서비스는 일반적으로 안드로이드 애플리케이션과 직접 상호작용은 하지 않지만 <strong>안드로이드 프레임워크가 동작하는 데 필수적인 서비스</strong>를 말한다.  </p><table><thead><tr><th align="center">코어 플랫폼 서비스</th><th align="center">기능</th></tr></thead><tbody><tr><td align="center"><code>Activity Manager Service</code></td><td align="center">모든 액티비티에 대한 라이프 사이클 및 액티비티 스택 관리</td></tr><tr><td align="center"><code>Window Manager Service</code></td><td align="center">Surface Flinger 위에 위치하며, 기기 화면에 그릴 내용을 Surface Flinger로 전달</td></tr><tr><td align="center"><code>Package Manager Service</code></td><td align="center">apk파일의 정보를 로딩, 시스템에 어떤 패키지가 설치되고 로딩돼 있는지에 대한 정보 제공</td></tr></tbody></table><p><strong>② 하드웨어 서비스</strong>  </p><p>저수준 하드웨어 제어를 위한 API를 제공하는 서비스를 말한다.  </p><table><thead><tr><th align="center">하드웨어 서비스</th><th align="center">기능</th></tr></thead><tbody><tr><td align="center"><code>Alarm Manager Service</code></td><td align="center">타이머처럼 특정 시간 후에 애플리케이션을 실행하는 등의 동작을 수행</td></tr><tr><td align="center"><code>Connectivity Service</code></td><td align="center">네트워크의 현재 상태에 대한 정보를 제공</td></tr><tr><td align="center"><code>Location Service</code></td><td align="center">단말의 현재 위치 정보를 제공</td></tr><tr><td align="center"><code>Power Service</code></td><td align="center">장치의 전원 관리를 제어</td></tr><tr><td align="center"><code>Sensor Service</code></td><td align="center">안드로이드에 설치된 각종 센서(마그네틱 센서, 가속도 센서 등)의 센싱 값을 제공</td></tr><tr><td align="center"><code>Telephony Service</code></td><td align="center">전화기의 상태나 전화 서비스에 대한 정보를 제공</td></tr><tr><td align="center"><code>Wifi Service</code></td><td align="center">AP 검색이나 연결 리스트 관리 등 무선랜 연결을 제어</td></tr></tbody></table><p><strong>자바 시스템 서비스 이용</strong>  </p><p>프레임워크 내부에서나 안드로이드 애플리케이션에서 이러한 자바 시스템 서비스를 이용하려면 <strong>각 서비스와 통신 가능한 Local Manager 객체</strong>를 이용해야 한다.  </p><h3 id="시스템-서비스의-실행"><a href="#시스템-서비스의-실행" class="headerlink" title="시스템 서비스의 실행"></a>시스템 서비스의 실행</h3><p>안드로이드 애플리케이션에서 애플리케이션 서비스를 실행할 경우 일반적으로 startService() API함수를 사용한다. 그러나 시스템 서비스는 애플리케이션 서비스와 달리 서비스를 직접 실행할 필요가 없이 getSystemService()를 이용해서 바로 이용할 수 있다. <strong>시스템 서비스는 init 프로세스에 의해 안드로이드 부팅 과정에서 미리 실행되기 때문이다.</strong>  </p><p><img src="/images/post/service7.png" alt="service7" title="service7">  </p><h4 id="미디어-서버의-실행-코드-분석"><a href="#미디어-서버의-실행-코드-분석" class="headerlink" title="미디어 서버의 실행 코드 분석"></a>미디어 서버의 실행 코드 분석</h4><h5 id="init-프로세스로부터-실행"><a href="#init-프로세스로부터-실행" class="headerlink" title="init 프로세스로부터 실행"></a>init 프로세스로부터 실행</h5><p>미디어 서버(Media Server)는 Audio Flinger, Media Player Service, Camera Service, Audio Policy Service 등의 네이티브 시스템 서비스를 실행하는 시스템 프로세스로서 init 프로세스에 의해 실행된다.  </p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">service media /system/bin/mediaserver<br>    <span class="hljs-keyword">user</span> <span class="hljs-title">media</span><br>    <span class="hljs-keyword">group</span> <span class="hljs-title">system</span> audio camera graphics inet net_bt net_bt_admin<br></code></pre></td></tr></table></figure><h5 id="네이티브-서비스-인스턴스-생성-및-초기화"><a href="#네이티브-서비스-인스턴스-생성-및-초기화" class="headerlink" title="네이티브 서비스 인스턴스 생성 및 초기화"></a>네이티브 서비스 인스턴스 생성 및 초기화</h5><p>다음은 미디어 서버에 포함된 main() 함수의 주요 부분이다. 여기서는 각 네이티브 서비스에 대한 인스턴스를 생성하고 초기화하는 작업을 수행한다.  </p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs css">int <span class="hljs-selector-tag">main</span>(int argc, char** argv)<br>&#123;<br>  :<br>  AudioFlinger::<span class="hljs-built_in">instantiate</span>();<br>  MediaPlayerService::<span class="hljs-built_in">instantiate</span>();<br>  CameraService::<span class="hljs-built_in">instantiate</span>();<br>  AudioPolicyService::<span class="hljs-built_in">instantiate</span>();<br>  :<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="각-시스템-서비스별-초기화-코드-살펴보기"><a href="#각-시스템-서비스별-초기화-코드-살펴보기" class="headerlink" title="각 시스템 서비스별 초기화 코드 살펴보기"></a>각 시스템 서비스별 초기화 코드 살펴보기</h5><p>시스템 서비스는 프레임워크 내에서 다른 모듈과 통신할 때 바인더 IPC를 사용한다.<br><em>(다음장, 애플리케이션과 같은 서비스 이용자가 시스템 서비스를 이용할 수 있게 서비스 제공자의 정보를 컨텍스트 매니저에 등록)</em>  </p><p>다음은 네이티브 서비스의 초기화 코드를 모아놓은 것이다. new 연산자를 통해 서비스 인스턴스를 생성한 다음 addService() 함수를 이용해서 컨텍스트 매니저에게 각 서비스를 등록한다.<br>여기서 defaultServiceManager() 함수는 컨텍스트 매니저와 바인더 통신을 하는 일종의 프록시 객체인 서비스 매니저를 반환한다. (자세한 내용은 8장)  </p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-comment">// Audio Flinger 초기화 코드</span><br>void AudioFlinger::<span class="hljs-built_in">instantiate</span>() &#123;<br>    <span class="hljs-built_in">defaultServiceManager</span>()-&gt;<span class="hljs-built_in">addService</span>(<br>            String16(&quot;media.audio_flinger&quot;), new <span class="hljs-built_in">AudioFlinger</span>());<br>&#125;<br><br><span class="hljs-comment">// Media Player Service 초기화 코드</span><br>void MediaPlayerService::<span class="hljs-built_in">instantiate</span>() &#123;<br>    <span class="hljs-built_in">defaultServiceManager</span>()-&gt;<span class="hljs-built_in">addService</span>(<br>            String16(&quot;media.player&quot;), new <span class="hljs-built_in">MediaPlayerService</span>());<br>&#125;<br><br><span class="hljs-comment">// Camera Service 초기화 코드</span><br>void CameraService::<span class="hljs-built_in">instantiate</span>() &#123;<br>    <span class="hljs-built_in">defaultServiceManager</span>()-&gt;<span class="hljs-built_in">addService</span>(<br>            String16(&quot;media.camera&quot;), new <span class="hljs-built_in">CameraService</span>());<br>&#125;<br><br><span class="hljs-comment">// Audio Policy Service 초기화 코드</span><br>void AudioPolicyService::<span class="hljs-built_in">instantiate</span>() &#123;<br>    <span class="hljs-built_in">defaultServiceManager</span>()-&gt;<span class="hljs-built_in">addService</span>(<br>            String16(&quot;media.audio_policy&quot;), new <span class="hljs-built_in">AudioPolicyService</span>());<br>&#125;<br></code></pre></td></tr></table></figure><p>미디어 서버는 각 서비스의 인스턴스를 생성한 다음, 생성된 서비스를 컨텍스트 매니저에 등록하는 것이 전부다.  </p><p><img src="/images/post/service8.png" alt="service8" title="service8">  </p><h4 id="시스템-서버의-실행-코드-분석"><a href="#시스템-서버의-실행-코드-분석" class="headerlink" title="시스템 서버의 실행 코드 분석"></a>시스템 서버의 실행 코드 분석</h4><p>시스템 서버는 자바 프로세스이므로 Zygote로부터 생성된다. 시스템 서버가 어떻게 시스템 서비스를 생성하는지 코드를 바탕으로 알아보자.  </p><h5 id="Zygote-프로세스로부터-생성"><a href="#Zygote-프로세스로부터-생성" class="headerlink" title="Zygote 프로세스로부터 생성"></a>Zygote 프로세스로부터 생성</h5><p>Zygote는 맨 처음 생성되는 달빅 가성 머신 기반의 자바 프로세스로서 네이티브 시스템 서비스인 Surface Flinger를 비롯해 다양한 자바 시스템 서비스를 실행하는 역할을 한다.  </p><p>Zygote 실행 시에 -start-system-server라는 옵션이 정의된 것을 확인할 수 있다. 이 옵션은 Zygote에서 시스템 서버를 생성하라고 요청하는 역할을 한다.  </p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs angelscript">service zygote /system/bin/app_process -Xzygote /system/bin --zygote --start-system-server<br>    <span class="hljs-keyword">class</span> <span class="hljs-symbol">main</span><br>    <span class="hljs-symbol">socket</span> <span class="hljs-symbol">zygote</span> <span class="hljs-symbol">stream</span> <span class="hljs-symbol">660</span> <span class="hljs-symbol">root</span> <span class="hljs-symbol">system</span><br>    <span class="hljs-symbol">onrestart</span> <span class="hljs-symbol">write</span> /<span class="hljs-symbol">sys</span>/<span class="hljs-symbol">android_power</span>/<span class="hljs-symbol">request_state</span> <span class="hljs-symbol">wake</span><br>    <span class="hljs-symbol">onrestart</span> <span class="hljs-symbol">write</span> /<span class="hljs-symbol">sys</span>/<span class="hljs-symbol">power</span>/<span class="hljs-symbol">state</span> <span class="hljs-symbol">on</span><br>    <span class="hljs-symbol">onrestart</span> <span class="hljs-symbol">restart</span> <span class="hljs-symbol">media</span><br>    <span class="hljs-symbol">onrestart</span> <span class="hljs-symbol">restart</span> <span class="hljs-symbol">netd</span><br></code></pre></td></tr></table></figure><h5 id="android-servers-라이브러리-로드"><a href="#android-servers-라이브러리-로드" class="headerlink" title="android_servers 라이브러리 로드"></a>android_servers 라이브러리 로드</h5><p>다음은 SystemServer의 main() 메서드를 나타내는 코드다.<br>android_servers 라이브러리를 로드하고 init1()메서드를 호출한다. init1() 메서드는 JNI를 통해 다음 system_init() 네이티브 함수를 호출한다.</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SystemServer</span> &#123;<br>  <span class="hljs-function">native <span class="hljs-keyword">public</span> <span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">init1</span><span class="hljs-params">(<span class="hljs-type">String</span>[] args)</span></span>;<br><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">String</span>[] args)</span> </span>&#123;<br>    System.<span class="hljs-built_in">loadLibrary</span>(<span class="hljs-string">&quot;android_servers&quot;</span>);<br>    <span class="hljs-built_in">init1</span>(args);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>system_init() 함수의 주된 기능은 Surface Flinger 네이티브 시스템 서비스를 초기화하는 것이다.  </p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">extern</span> <span class="hljs-string">&quot;C&quot;</span> status_t <span class="hljs-title function_ invoke__">system_init</span>()<br>&#123;<br>    SurfaceFlinger::<span class="hljs-title function_ invoke__">instantiate</span>(); <span class="hljs-comment">// JNI를 이용해 Surface Flinger 서비스 실행</span><br><br>    AndroidRuntime* runtime = AndroidRuntime::<span class="hljs-title function_ invoke__">getRuntime</span>();<br>    JNIEnv* env = runtime<span class="hljs-punctuation">-&gt;</span><span class="hljs-title function_ invoke__">getJNIEnv</span>();<br><br>    jclass clazz = env<span class="hljs-punctuation">-&gt;</span><span class="hljs-title function_ invoke__">FindClass</span>(<span class="hljs-string">&quot;com/android/server/SystemServer&quot;</span>);<br>    jmethodID methodId = env<span class="hljs-punctuation">-&gt;</span><span class="hljs-title function_ invoke__">GetStaticMethodID</span>(clazz, <span class="hljs-string">&quot;init2&quot;</span>, <span class="hljs-string">&quot;()V&quot;</span>); <span class="hljs-comment">// SystemServer 클래스의 init2() 메서드를 호출한다.</span><br><br>    <span class="hljs-keyword">return</span> NO_ERROR;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="자바-시스템-서비스-초기화-및-등록"><a href="#자바-시스템-서비스-초기화-및-등록" class="headerlink" title="자바 시스템 서비스 초기화 및 등록"></a>자바 시스템 서비스 초기화 및 등록</h5><p>SystemServer에서 Surface Flinger를 초기화하고 나면 init2() 메서드가 호출된다. 이 메서드는 Entropy 서비스부터 AppWidget 서비스까지 <strong>안드로이드의 모든 자바 시스템 서비스를 생성하고 초기화하는 역할</strong>을 한다.<br>init2() 메서드에서는 ServerThread를 생성한 다음 실행한다.<br>이렇게 실행된 자바 시스템 서비스 역시 네이티브 시스템 서비스처럼 다른 모듈이 서비스를 활용할 수 있게끔 해당 서비스를 컨텍스트 매니저에 등록해야 한다. 자바 시스템 서비스는 ServiceManager 클래스의 <strong>addService() 정적 메서드를 이용해서 컨텍스트 매니저에 자신을 등록</strong>한다.  </p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">public static final void init2<span class="hljs-literal">()</span> &#123;<br>    Thread thr = <span class="hljs-keyword">new</span> <span class="hljs-constructor">ServerThread()</span>;<br>    thr.set<span class="hljs-constructor">Name(<span class="hljs-string">&quot;android.server.ServerThread&quot;</span>)</span>;<br>    thr.start<span class="hljs-literal">()</span>;<br>&#125;<br><br><span class="hljs-keyword">class</span> ServerThread extends Thread &#123;<br>  :<br>  <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Slog</span>.</span></span>i(TAG, <span class="hljs-string">&quot;Entropy Mixer&quot;</span>);<br>  <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">ServiceManager</span>.</span></span>add<span class="hljs-constructor">Service(<span class="hljs-string">&quot;entropy&quot;</span>, <span class="hljs-params">new</span> EntropyMixer()</span>);<br><br>  <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Slog</span>.</span></span>i(TAG, <span class="hljs-string">&quot;Power Manager&quot;</span>);<br>  power = <span class="hljs-keyword">new</span> <span class="hljs-constructor">PowerManagerService()</span>;<br>  <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">ServiceManager</span>.</span></span>add<span class="hljs-constructor">Service(Context.POWER_SERVICE, <span class="hljs-params">power</span>)</span>;<br><br>  <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Slog</span>.</span></span>i(TAG, <span class="hljs-string">&quot;Activity Manager&quot;</span>);<br>  context = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">ActivityManagerService</span>.</span></span>main(factoryTest);<br><br>  <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Slog</span>.</span></span>i(TAG, <span class="hljs-string">&quot;Telephony Registry&quot;</span>);<br>  <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">ServiceManager</span>.</span></span>add<span class="hljs-constructor">Service(<span class="hljs-string">&quot;telephony.registry&quot;</span>, <span class="hljs-params">new</span> TelephonyRegistry(<span class="hljs-params">context</span>)</span>);<br><br>  :<br>  :<br><br>  <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Slog</span>.</span></span>i(TAG, <span class="hljs-string">&quot;Backup Service&quot;</span>);<br>  <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">ServiceManager</span>.</span></span>add<span class="hljs-constructor">Service(Context.BACKUP_SERVICE, <span class="hljs-params">new</span> BackupManagerService(<span class="hljs-params">context</span>)</span>);<br><br>  <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Slog</span>.</span></span>i(TAG, <span class="hljs-string">&quot;AppWidget Service&quot;</span>);<br>  appWidget = <span class="hljs-keyword">new</span> <span class="hljs-constructor">AppWidgetService(<span class="hljs-params">context</span>)</span>;<br>  <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">ServiceManager</span>.</span></span>add<span class="hljs-constructor">Service(Context.APPWIDGET_SERVICE, <span class="hljs-params">appWidget</span>)</span>;<br><br>  :<br>  :<br>&#125;<br><br></code></pre></td></tr></table></figure><p><img src="/images/post/service9.png" alt="service9" title="service9">  </p><h3 id="안드로이드-서비스-프레임워크와-바인더-드라이버-개요-및-용어-정리"><a href="#안드로이드-서비스-프레임워크와-바인더-드라이버-개요-및-용어-정리" class="headerlink" title="안드로이드 서비스 프레임워크와 바인더 드라이버 개요 및 용어 정리"></a>안드로이드 서비스 프레임워크와 바인더 드라이버 개요 및 용어 정리</h3><h4 id="주요-용어-정리"><a href="#주요-용어-정리" class="headerlink" title="주요 용어 정리"></a>주요 용어 정리</h4><p><strong>서비스 서버</strong> : 시스템 서비스를 실행하는 프로세스로서 앞에서 설명한 시스템 서버나 미디어 서버가 여기에 해당한다.<br><strong>서비스 클라이언트</strong> : 시스템 서비스를 사용하는 프로세스를 일컫는다.<br><strong>컨텍스트 매니저</strong> : 시스템 서비스를 관리하는 안드로이드 시스템 프로세스로서 시스템에 설치돼 있는 각종 시스템 서비스의 위치 정보인 핸들을 관리한다. 이러한 핸들은 바인더 IPC의 목적지 주소를 지정하는 데 사용된다.<br><strong>서비스 프레임워크</strong> : 서비스 매니저를 포함해서 서비스 사용자와 시스템 서비스간의 RPC 동작에 필요한 공통적인 클래스가 정의돼 있다.<br><strong>서비스 인터페이스</strong> : 서비스 사용자와 시스템 서비스 간에 미리 정해진 인터페이스로서 시스템 서비스는 해당 인터페이스에 맞게 스텁 함수를 구현해서 해당 서비스를 제공해야 하고, 반대로 서비스 사용자 역시 해당 인터페이스에 맞게 서비스를 호출해야 한다.<br><strong>서비스 사용자</strong> : 서비스 클라이언트 프로세스 내에서 실제 서비스를 이용하는 모듈이다.<br><strong>서비스</strong> : 서비스 인터페이스에 정의된 기능을 서비스 스텁 함수로 구현해서 실제 서비스의 기능을 제공하는 모듈을 의미한다.<br><strong>서비스 프록시</strong> : RPC 수행 시 데이터 마샬링을 수행하는 객체이며 서비스 인터페이스별로 존재한다. 서비스 인터페이스에 정의된 함수별로 각각 데이터 마샬링을 수행하는 서비스 프록시 함수를 제공한다.<br><strong>서비스 스텁</strong> : RPC 수행 시 데이터 언마샬링을 수행하는 객체이며, 이 객체 역시 서비스 인터페이스별로 존재한다. 수신된 데이터를 언마샬링해서 연관된 서비스 스텁 함수를 호출한다.<br><strong>바인더 드라이버</strong> : 바인더는 안드로이드에서 IPC를 지원하는 데 사용되는 메커니즘으로 안드로이드 리눅스 커널의 디바이스 드라이버 형태로 포함돼 있다.<br><strong>바인더 IPC</strong> : 안드로이드에서 바인더 드라이버를 통한 프로세스간의 데이터 전달 방식을 말한다.<br><strong>바인더 IPC 데이터</strong> : 서비스 프레임워크와 바인더 드라이버 사이에 사용되는 데이터 포맷<br><strong>바인더 RPC</strong> : 서비스 사용자가 서비스에서 제공하는 특정 서비스 인터페이스 기반의 함수를 마치 자신의 로컬 함수 호출하듯이 원격으로 처리하는 동작을 말한다. 바인더 RPC는 내부적으로는 바인더 IPC 메커니즘 기반으로 동작한다.<br><strong>바인더 RPC 데이터</strong> : 서비스 사용자와 서비스 간의 바인더 RPC를 수행하는 데 사용되는 데이터</p><p>다음 그림은 서비스 동작 원리를 일반화한 것으로서 Foo라는 시스템 서비스에서 제공하는 foo() 메서드를 서비스 사용자가 RPC 형태로 호출하는 모습을 보여준다.  </p><p><img src="/images/post/service10.png" alt="service10" title="service10">  </p><p>서비스 사용자는 foo() 프록시 함수를 호출해서 Foo 서비스를 이용하기 위한 인자로 구성된 바인더 RPC 데이터를 전달한다. 바인더 PRC 데이터는 마샬링을 거쳐 서비스 프레임워크를 통해 바인더 IPC 데이터로 생성된 다음 바인더 드라이버를 통해 서비스 서버 측에 전송된다.  </p><p>서비스 서버 측에서 수신된 바인더 IPC 데이터는 서비스 프레임워크를 거치면서 언마샬링된 다음, 서비스 스텁의 onTransact() 함수에 전송된다. 서비스 스텁은 해당 바인더 IPC 데이터 안에 포함된 RPC 코드를 통해 Foo 서비스의 foo() 서비스 스텁 함수에 대한 바인더 RPC임을 판단한다. 수신된 바인더 IPC 데이터에 포함된 바인더 RPC 데이터를 인자로 해서 foo() 서비스 스텁 함수를 호출한다.  </p>]]></content>
    
    
    <categories>
      
      <category>Android</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Android</tag>
      
      <tag>인사이드 안드로이드</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[인사이드 안드로이드] 챕터 6 - 안드로이드 서비스 개요</title>
    <link href="/chapter6/"/>
    <url>/chapter6/</url>
    
    <content type="html"><![CDATA[<h1 id="인사이드-안드로이드"><a href="#인사이드-안드로이드" class="headerlink" title="[인사이드 안드로이드]"></a>[인사이드 안드로이드]</h1><h2 id="Chapter6-안드로이드-서비스-개요"><a href="#Chapter6-안드로이드-서비스-개요" class="headerlink" title="Chapter6 - 안드로이드 서비스 개요"></a>Chapter6 - 안드로이드 서비스 개요</h2><h3 id="예제-프로그램-안드로이드-서비스-동작-이해"><a href="#예제-프로그램-안드로이드-서비스-동작-이해" class="headerlink" title="예제 프로그램 : 안드로이드 서비스 동작 이해"></a>예제 프로그램 : 안드로이드 서비스 동작 이해</h3><p>안드로이드에서 서비스는 UI 없이 주기적으로 특정한 일을 수행하는 백그라운드 프로세스를 가리킨다. 따라서 안드로이드 프로그램을 작성할 때 개발자가 적절한 애플리케이션 서비스를 직접 구현해서 적용한다면 더 반응성이 좋은 애플리케이션을 개발할 수 있다.  </p><p>간단한 예제를 통해 안드로이드 서비스의 동작 방식을 알아보기 위해 ApiDemo 샘플 예제의 Alarm Service 코드를 본다.  </p><p>이 프로그램은 크게 메인 액티비티와 두개의 시스템 서비스, AlarmService_Service라는 애플리케이션 서비스로 구성돼 있다.<br>(1) 메인 액티비티 상에서 Start 버튼을 누르면 시스템 서비스인 Alarm Service에 30초마다 사용자가 작성한 애플리케이션 서비스인 AlarmService_Service를 실행해 달라고 요청한다.<br>(2) Alarm Service는 사용자의 요청에 따라 30초마다 AlarmService_Service라는 애플리케이션 서비스를 실행한다.  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-type">OnClickListener</span> <span class="hljs-variable">mStartAlarmListener</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">OnClickListener</span>() &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onClick</span><span class="hljs-params">(View v)</span> &#123;<br>        <span class="hljs-type">long</span> <span class="hljs-variable">firstTime</span> <span class="hljs-operator">=</span> SystemClock.elapsedRealtime();<br><br>        <span class="hljs-type">AlarmManager</span> <span class="hljs-variable">am</span> <span class="hljs-operator">=</span> (AlarmManager)getSystemService(ALARM_SERVICE);<br>        am.setRepeating(AlarmManager.ELAPSED_REALTIME_WAKEUP,<br>                        firstTime, <span class="hljs-number">30</span>*<span class="hljs-number">1000</span>, mAlarmSender); <span class="hljs-comment">// (1, 2)</span><br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>(3) AlarmService_Service는 실행되자마자 시스템 서비스인 Notification Service에 AlarmService_Service 서비스가 시작됐음을 알리는 문자열 출력을 요청한다.<br>(4) Notification Service는 AlarmService_Service에게서 전달받은 문자열을 화면 상단의 상태 표시줄에 출력한다.  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onCreate</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">NotificationManager</span> <span class="hljs-variable">mNM</span> <span class="hljs-operator">=</span> (NotificationManager)getSystemService(NOTIFICATION_SERVICE);<br><br>    showNotification(); <span class="hljs-comment">// (3, 4)</span><br><br>    <span class="hljs-type">Thread</span> <span class="hljs-variable">thr</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<span class="hljs-literal">null</span>, mTask, <span class="hljs-string">&quot;AlarmService_Service&quot;</span>);<br>    thr.start();<br>&#125;<br></code></pre></td></tr></table></figure><p>(5) AlarmService_Service는 시작된 후 15초 후에 종료되며, 종료된 사실을 메인 액티비티에 알리기 위해 토스트(Toast) 메시지를 출력한다.  </p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">Runnable mTask = <span class="hljs-keyword">new</span> <span class="hljs-constructor">Runnable()</span> &#123; <span class="hljs-comment">// (5)</span><br>    public void run<span class="hljs-literal">()</span> &#123;<br>        long endTime = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>current<span class="hljs-constructor">TimeMillis()</span> + <span class="hljs-number">15</span>*<span class="hljs-number">1000</span>;<br>        <span class="hljs-keyword">while</span> (<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>current<span class="hljs-constructor">TimeMillis()</span> &lt; endTime) &#123;<br>            synchronized (mBinder) &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    mBinder.wait(endTime - <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>current<span class="hljs-constructor">TimeMillis()</span>);<br>                &#125; catch (Exception e) &#123;<br>                &#125;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">AlarmService_Service</span>.</span></span>this.stop<span class="hljs-constructor">Self()</span>;<br>    &#125;<br>&#125;;<br><br><br>public void on<span class="hljs-constructor">Destroy()</span> &#123;<br>    mNM.cancel(<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">R</span>.</span></span><span class="hljs-built_in">string</span>.alarm_service_started);<br><br>    <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Toast</span>.</span></span>make<span class="hljs-constructor">Text(<span class="hljs-params">this</span>, R.<span class="hljs-params">string</span>.<span class="hljs-params">alarm_service_finished</span>, Toast.LENGTH_SHORT)</span>.show<span class="hljs-literal">()</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="안드로이드-서비스-분류"><a href="#안드로이드-서비스-분류" class="headerlink" title="안드로이드 서비스 분류"></a>안드로이드 서비스 분류</h3><p>안드로이드 서비스는 다음과 같이 크게 프레임워크에서 기본적으로 제공하는 <strong>시스템 서비스</strong>와 애플리케이션 개발자가 Service 클래스를 상속해서 구현한 <strong>애플리케이션 서비스</strong>로 구분할 수 있다.  </p><p><img src="/images/post/service1.png" alt="service1" title="service1">  </p><h3 id="안드로이드-애플리케이션-서비스"><a href="#안드로이드-애플리케이션-서비스" class="headerlink" title="안드로이드 애플리케이션 서비스"></a>안드로이드 애플리케이션 서비스</h3><p>애플리케이션 서비스는 안드로이드 SDK의 Service 클래스를 확장한 클래스의 인스턴스로 UI 없이 주기적으로 특정한 일을 수행하는 백그라운드 프로세스를 가리킨다.</p><p>애플리케이션 개발자는 서비스를 두 가지 방법으로 이용할 수 있다.  </p><ul><li>서비스 시작, 종료  </li><li>바인딩을 통한 서비스 원격 제어(서비스를 원격 제어할 수 있게 서비스에 연결하는 것)</li></ul><p>애플리케이션이 서비스를 생성하려면 startService(), bindService()같은 API를 상황에 맞게 이용하면 된다. 백그라운드에서 특정 동작을 하는 서비스를 실행할 때는 <strong>startService()</strong>, 서비스에 바인딩해서 서비스가 제공하는 인터페이스를 통해 서비스를 제어하고 싶다면 **bindService()**를 통해 서비스를 생성한다. 두 서비스의 생명 주기는 약간 다른 것을 확인할 수 있다.  </p><p><img src="/images/post/service2.png" alt="service2" title="service2">  </p><p>startService()나 bindService()로 시작된 서비스 모두 onCreate()와 onDestroy() 콜백 메서드가 호출된다. onCreate() 메서드는 서비스가 처음 생성될 때 호출되며 일반적으로 서비스를 초기화하는 코드가 포함된다. onDestroy()는 서비스가 종료되기 직전에 호출되는데, 이때 서비스가 사용한 리소스를 모두 해제해야 한다.  </p><h5 id="startService"><a href="#startService" class="headerlink" title="startService()"></a>startService()</h5><p>onStartCommand()는 그림에서 볼 수 있듯이 오직 startService()에 의해 시작된 서비스에서 onCreate() 메서드 다음으로 호출된다. startService() 메서드의 첫 번째 인자로 넘어온 인텐트가 onStartCommand()의 첫 번째 인자로 그대로 전달되는데, 이때 인텐트에는 주로 실행할 서비스에 대한 정보가 포함된다. 이후 onStartCommand()에서는 일반적으로 인텐트에서 넘어온 인자가 있다면 이를 처리하거나 실질적인 백그라운드 작업을 처리하는 스레드를 실행한다.  </p><h5 id="bindService"><a href="#bindService" class="headerlink" title="bindService()"></a>bindService()</h5><p>bindService()에 의해 시작된 서비스에서 onBind()는 클라이언트가 서비스에 바인딩하려고 할 떄 호출된다.(아직 서비스가 생성되지 않았다면 그 전에 onCreate()를 먼저 호출한다) 서비스의 onBind() 콜백에서는 바인딩할 클라이언트를 위해 해당 서비스와 연결 가능한 객체를 제공한다. 따라서 바인딩이 끝나면 클라이언트는 이 객체를 통해 서비스를 원격 제어할 수 있다.  </p><h4 id="애플리케이션-서비스의-분류"><a href="#애플리케이션-서비스의-분류" class="headerlink" title="애플리케이션 서비스의 분류"></a>애플리케이션 서비스의 분류</h4><p>애플리케이션 서비스를 로컬 서비스와 리모트 서비스로 구분한다. 이를 구분하는 기준은 서비스와 이를 생선한 서비스 클라이언트(보통 액티비티)가 동일한 프로세스에서 동작하고 있는지 여부다.  </p><p><img src="/images/post/service3.png" alt="service3" title="service3">  </p><p>위의 그림과 같이 생성된 서비스가 자신과 동일한 프로세스에서 실행되는 경우 <strong>로컬 서비스</strong>라 부른다. 로컬 서비스는 자신을 생성한 애플리케이션 내에서만 사용될 수 있으며 애플리케이션이 종료하면 함께 종료한다.<br><strong>리모트 서비스</strong>는 자신을 생성한 액티비티와는 별개의 독립적인 프로세스 위에서 동작하기 때문에 메인 애플리케이션이 종료하더라도 계속 동작한다. **잘못 구현된 리모트 서비스는 프로그램이 종료하더라도 시스템 자원(배터리 등)을 비효율적으로 소모할 수 있기 때문에 설계에 신중을 기해야 한다.  </p><p>로컬 서비스와 리모트 서비스와의 가장 큰 차이는 서비스 제어를 위한 바인딩 방법이다.<br>로컬 서비스의 경우는 서비스와 서비스를 이용하는 클라이언트 프로그램이 동일 프로세스에서 동작하기 때문에 로컬 서비스 바인딩은 클라이언트 프로그램이 로컬 서비스의 레퍼런스만 얻으면 된다.<br>리모트 서비스의 경우는 액티비티와 자신이 모두 별개의 프로세스에서 동작하므로 (다음 장에서 배울)IPC 메커니즘을 이용해야 한다.  </p><p>로컬 서비스와 리모트 서비스의 바인딩 과정이 어떻게 다른지를 예제를 분석하며 알아보겠다.  </p><h5 id="로컬-서비스"><a href="#로컬-서비스" class="headerlink" title="로컬 서비스"></a>로컬 서비스</h5><p>Local Service Binding 예제는 크게 서비스를 나타내는 LocalService.java와 서비스를 이용하는 액티비티인 LocalServiceActivities.java로 구성돼 있다.<br>Bind Service 버튼을 누르면 doBindService()가 호출된다.  </p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-keyword">private</span> OnClickListener mBindListener = <span class="hljs-keyword">new</span> <span class="hljs-constructor">OnClickListener()</span> &#123;<br>    public void on<span class="hljs-constructor">Click(View <span class="hljs-params">v</span>)</span> &#123;<br>        <span class="hljs-keyword">do</span><span class="hljs-constructor">BindService()</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>이 메서드에서 내부적으로 bindService() API를 사용해서 LocalService 바인딩을 시도한다.<br><em>bindService(LocalService 실행하기 위한 인텐트, 서비스와의 바인딩 연결을 처리할 객체, 바인딩할 서비스가 없는 경우 자동 서비스 생성 플래그)</em>  </p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">void <span class="hljs-keyword">do</span><span class="hljs-constructor">BindService()</span> &#123;<br>    <span class="hljs-keyword">if</span> (bind<span class="hljs-constructor">Service(<span class="hljs-params">new</span> Intent(Binding.<span class="hljs-params">this</span>, LocalService.<span class="hljs-params">class</span>)</span>,<br>        mConnection, Context.BIND_AUTO_CREATE)) &#123;<br>        mShouldUnbind = <span class="hljs-literal">true</span>;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Log</span>.</span></span>e(<span class="hljs-string">&quot;MY_APP_TAG&quot;</span>, <span class="hljs-string">&quot;Error: The requested service doesn&#x27;t &quot;</span> +<br>                <span class="hljs-string">&quot;exist, or this client isn&#x27;t allowed access to it.&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>바인딩할 서비스가 생성됐으므로 안드로이드는 바인딩 처리를 위해 서비스의 onBind() 콜백 메서드를 호출한다.<br>onBind 메서드는 액티비티가 LocalService 자신과 연결할 수 있게 LocalBinder 객체를 반환한다.  </p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs scala">public <span class="hljs-type">IBinder</span> onBind(<span class="hljs-type">Intent</span> intent) &#123;<br>    <span class="hljs-keyword">return</span> mBinder;<br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">IBinder</span> mBinder = <span class="hljs-keyword">new</span> <span class="hljs-type">LocalBinder</span>();<br><br>public <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LocalBinder</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Binder</span> </span>&#123;<br>    <span class="hljs-type">LocalService</span> getService() &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-type">LocalService</span>.<span class="hljs-keyword">this</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>바인딩을 처리할 객체를 제대로 생성했다면(LocalBinder), 안드로이드 프레임워크는 서비스 클라이언트 측 메서드를 호출한다.<br>이 때 LocalBinder 객체의 getService() 메서드를 호출해서 바인딩하려고 했던 LocalService 객체의 레퍼런스 값을 구한다.<br>이렇게 구한 LocalBinder 객체의 레퍼런스 값을 mBoundService 멤버 필드에 저장하면 서비스 바인딩이 마무리된다.  </p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">private</span> ServiceConnection mConnection = <span class="hljs-keyword">new</span> ServiceConnection() &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onServiceConnected</span>(<span class="hljs-params">ComponentName className, IBinder service</span>)</span> &#123;<br>        mBoundService = ((LocalService.LocalBinder)service).getService();<br>        Toast.makeText(Binding.<span class="hljs-keyword">this</span>, R.<span class="hljs-built_in">string</span>.local_service_connected,<br>            Toast.LENGTH_SHORT).show();<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onServiceDisconnected</span>(<span class="hljs-params">ComponentName className</span>)</span> &#123;<br>        mBoundService = <span class="hljs-literal">null</span>;<br>        Toast.makeText(Binding.<span class="hljs-keyword">this</span>, R.<span class="hljs-built_in">string</span>.local_service_disconnected,<br>            Toast.LENGTH_SHORT).show();<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>서비스가 바인딩 되고 나면 액티비티는 해당 서비스가 가진 모든 메서드와 멤버 필드 값을 mBoundService 멤버 필드를 통해 접근할 수 있게 된다.  </p><h5 id="리모트-서비스"><a href="#리모트-서비스" class="headerlink" title="리모트 서비스"></a>리모트 서비스</h5><p>Remote Service Binding 예제는 Local Service Binding 과는 다르게 액티비티나 서비스 파일 이외에 ISecondary.aidl이라는 AIDL 파일과 이 파일에 의해 자동 생성된 ISecondary.java 파일이 추가된 것을 알 수 있다.  </p><p><em>ISecondary.aidl은 액티비티와 서비스의 통신을 위한 인터페이스 정의</em><br><em>ISecondary.java는 안드로이드가 자동 생성하며 인터페이스를 기반으로 액티비티와 서비스가 서로 통신할 수 있게 마샬링&#x2F;언마샬링을 수행</em><br><em>마샬링 - 객체의 메모리 구조를 저장이나 전송을 위해서 적당한 자료형태로 변형</em>  </p><p>ISecondary.aidl을 통해 자동으로 생성된 ISecondary.java는 서비스 클라이언트와 리모트 서비스 간의 ISecondary 인터페이스에 기반한 바인더 IPC 연결을 설정한다. 즉, 이 코드를 통해서 RemoteServiceBinding 액티비티는 RemoteService 서비스가 제공하는 ISecondary 인터페이스에 포함된 getPid() 메서드를 마치 해당 클래스에 포함된 매서드를 호출하듯 호출할 수 있다.  </p><p>Bind Service 버튼을 눌렀을 때 로컬 서비스와 비슷하게 bindService()에서 첫 번째 인자에 리모트 서비스를 실행하기 위한 인텐트가 전달된다.  </p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-keyword">private</span> OnClickListener mBindListener = <span class="hljs-keyword">new</span> <span class="hljs-constructor">OnClickListener()</span> &#123;<br>    public void on<span class="hljs-constructor">Click(View <span class="hljs-params">v</span>)</span> &#123;<br>        Intent intent = <span class="hljs-keyword">new</span> <span class="hljs-constructor">Intent(Binding.<span class="hljs-params">this</span>, RemoteService.<span class="hljs-params">class</span>)</span>;<br>        intent.set<span class="hljs-constructor">Action(ISecondary.<span class="hljs-params">class</span>.<span class="hljs-params">getName</span>()</span>);<br>        bind<span class="hljs-constructor">Service(<span class="hljs-params">intent</span>, <span class="hljs-params">mSecondaryConnection</span>, Context.BIND_AUTO_CREATE)</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>서비스가 생성되고 나면 서비스 생명주기에 따라 onCreate() 메서드와 onBind() 메서드가 차례대로 호출된다. onCreate() 메서드는 앞의 LocalService와 같이 서비스의 생성을 알림 메시지를 통해 알린다. onBind() 메서드의 주된 역할은 바인더 IPC를 처리할 서비스 바인더 객체(여기서는 mSecondaryBinder)를 생성한 후 이를 시스템에 반환하는 것이다.  </p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">private</span> final ISecondary.Stub mSecondaryBinder = <span class="hljs-keyword">new</span> ISecondary.Stub() &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> <span class="hljs-title">getPid</span>()</span> &#123;<br>        <span class="hljs-keyword">return</span> Process.myPid();<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">basicTypes</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> anInt, <span class="hljs-built_in">long</span> aLong, boolean aBoolean,</span></span><br><span class="hljs-params"><span class="hljs-function">        <span class="hljs-built_in">float</span> aFloat, <span class="hljs-built_in">double</span> aDouble, String aString</span>)</span> &#123;<br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> IBinder <span class="hljs-title">onBind</span>(<span class="hljs-params">Intent intent</span>)</span> &#123;<br>    <span class="hljs-keyword">if</span> (IRemoteService.<span class="hljs-keyword">class</span>.getName().<span class="hljs-keyword">equals</span>(intent.getAction())) &#123;<br>        <span class="hljs-keyword">return</span> mBinder;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (ISecondary.<span class="hljs-keyword">class</span>.getName().<span class="hljs-keyword">equals</span>(intent.getAction())) &#123;<br>        <span class="hljs-keyword">return</span> mSecondaryBinder;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>바인딩 준비가 끝나면 안드로이드 프레임워크는 bindService()의 두 번째 인자로 넘긴 연결 객체의 onServiceConnected()콜백 메서드를 호출한다.<br>바인딩이 끝나면 mSecondaryService 멤버 변수에 저장된 서비스 프록시 객체를 통해 RemoteService 서비스의 getPid() 메서드를 마치 자신의 메서드인 것처럼 호출할 수 있게 된다.  </p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-keyword">private</span> ServiceConnection mSecondaryConnection = <span class="hljs-keyword">new</span> <span class="hljs-constructor">ServiceConnection()</span> &#123;<br>    public void on<span class="hljs-constructor">ServiceConnected(ComponentName <span class="hljs-params">className</span>, IBinder <span class="hljs-params">service</span>)</span> &#123;<br>        mSecondaryService = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">ISecondary</span>.</span><span class="hljs-module"><span class="hljs-identifier">Stub</span>.</span></span><span class="hljs-keyword">as</span><span class="hljs-constructor">Interface(<span class="hljs-params">service</span>)</span>; <span class="hljs-comment">// 서비스 프록시 객체가 생성되어 저장</span><br>        mKillButton.set<span class="hljs-constructor">Enabled(<span class="hljs-params">true</span>)</span>;<br>    &#125;<br>    public void on<span class="hljs-constructor">ServiceDisconnected(ComponentName <span class="hljs-params">className</span>)</span> &#123;<br>        mSecondaryService = null;<br>        mKillButton.set<span class="hljs-constructor">Enabled(<span class="hljs-params">false</span>)</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>바인딩한 서비스를 이용하기 위해서 ‘Kill Process’버튼을 누르면 서비스 프록시 객체의 getPid() 서비스 프록시 메서드가 호출된다. 액티비티는 이렇게 구한 서비스 프로세스를 Process.killProcess() 메서드를 통해 강제 종료한다.  </p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">private</span> OnClickListener mKillListener = <span class="hljs-keyword">new</span> OnClickListener() &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onClick</span>(<span class="hljs-params">View v</span>)</span> &#123;<br>        <span class="hljs-keyword">if</span> (mSecondaryService != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-built_in">int</span> pid = mSecondaryService.getPid();<br>                Process.killProcess(pid);<br>                mCallbackText.setText(<span class="hljs-string">&quot;Killed service process.&quot;</span>);<br>            &#125; <span class="hljs-keyword">catch</span> (RemoteException ex) &#123;<br>                Toast.makeText(Binding.<span class="hljs-keyword">this</span>,<br>                        R.<span class="hljs-built_in">string</span>.remote_call_failed,<br>                        Toast.LENGTH_SHORT).show();<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Android</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Android</tag>
      
      <tag>인사이드 안드로이드</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[인사이드 안드로이드] 챕터 5 - Zygote</title>
    <link href="/chapter5/"/>
    <url>/chapter5/</url>
    
    <content type="html"><![CDATA[<h1 id="인사이드-안드로이드"><a href="#인사이드-안드로이드" class="headerlink" title="[인사이드 안드로이드]"></a>[인사이드 안드로이드]</h1><h2 id="Chapter5-Zygote"><a href="#Chapter5-Zygote" class="headerlink" title="Chapter5 - Zygote"></a>Chapter5 - Zygote</h2><h3 id="Zygote란-무엇인가"><a href="#Zygote란-무엇인가" class="headerlink" title="Zygote란 무엇인가?"></a>Zygote란 무엇인가?</h3><p>Zygote의 사전적 의미는 ‘분할 전의 세포나 수정란’이다. 쉽게 말하면 개체가 생성되기 이전의 불완전한 상태.<br><strong>안드로이드 시스템에서 새로운 애플리케이션을 실행하면 실행에 필요한 요소들을 미리 준비해 둔 Zygote 프로세스와 새로운 애플리케이션이 결합되서 실행된다.</strong>  </p><p>Zygote 프로세스는 실행되면서 달빅(Dalvik) 가상 머신을 초기화하고 구동시킨다. 안드로이드 애플리케이션은 자바로 작성돼 있어 리눅스 상에서 네이티브 프로세스로 실행될 수 없으며 달빅 가상 머신에서 동작한다. 각 안드로이드 애플리케이션은 독립적인 가상 머신 위에서 동작하는데, 실행될 때 마다 자신이 동작할 가상 머신을 초기화하고 실행하는 과정에는 많은 시간이 소요되며 애플리케이션의 실행을 느리게 하는 요인이 된다. 때문에 안드로이드에서 Zygote 프로세스는 애플리케이션이 실행되기 전에 실행된 가상 머신의 코드 및 메모리 정보를 공유함으로써 <strong>애플리케이션이 실행되는 시간을 단축시킬 수 있다.</strong> 여기에 더해 안드로이드 프레임워크에서 동작하는 <strong>애플리케이션이 사용할 클래스와 자원을 미리 메모리에 로딩해 두고 이러한 자원에 대한 연결 정보를 구성한다.</strong><br>Zygote 프로세스를 사용하는 목적으로는 애플리케이션의 생성 속도를 빠르게 해서 한정된 자원을 효율적으로 사용해 사용 시간을 늘리기 위함이다.  </p><h4 id="Zygote를-통한-프로세스의-생성"><a href="#Zygote를-통한-프로세스의-생성" class="headerlink" title="Zygote를 통한 프로세스의 생성"></a>Zygote를 통한 프로세스의 생성</h4><p><img src="/images/post/zygote1.png" alt="zygote1" title="zygote1">  </p><p>Zygote 프로세스는 init 프로세스가 시스템 구동에 필요한 각종 데몬을 실행하고 난 뒤 실행된다. Zygote 프로세스가 실행된 이후에는 안드로이드 서비스 및 애플리케이션은 Zygote 프로세스를 통해 실행된다.  </p><p><img src="/images/post/zygote2.png" alt="zygote2" title="zygote2">  </p><p>일반적인 리눅스 시스템에서 새로운 애플리케이션을 실행하는 과정은 위와 같다.<br>부모 프로세스 A는 fork() 시스템 콜을 호출하여 새로운 자식 프로세스 A’를 생성한다. 새로 생성된 프로세스 A’는 부모 프로세스인 프로세스 A의 메모리 구성 정보 및 공유 라이브러리에 대한 링크 정보를 공유한 상태이다. 다음으로 자식 프로세스 A’는 exec(‘B’) 시스템 콜을 호출해 새로운 프로세스 B의 코드를 메모리로 로딩한다. 이때 부모 프로세스 A의 메모리 정보는 지워지고 로딩된 B를 실행하는 데 필요한 메모리를 새롭게 구성한 후 프로세스 B가 사용한 공유 라이브러리에 대한 링크 정보를 새로 구성한다.  </p><p><strong>안드로이드에서</strong>는 COW(Copy On Write)를 통해 기존에 이미 메모리 상에서 동작중인 프로세스의 재사용성을 극대화하고 공유 라이브러리를 통해 메모리 사용량(foot print)을 최소화한다.  </p><blockquote><p>COW(Copy On Write)란 프로세스를 생성할 때 새로 생성된 자식 프로세스는 부모 프로세스와 메모리 공간을 공유하는데, 메모리 복사를 하는 것은 오버헤드가 매우 크기 때문에 생성된 자식 프로세스가 부모의 메모리 공간을 참조만 할 경우에는 이를 복사하지 않고 부모의 메모리 공간을 공유하게 된다. 공유하는 메모리 정보를 자식 프로세스가 수정하는 시점에서 부모 프로세스의 메모리 정보를 자신의 메모리 공간으로 복사하는 것이 바로 COW 기법이다.   </p></blockquote><p><img src="/images/post/zygote3.png" alt="zygote3" title="zygote3">  </p><p>Zygote 프로세스는 fork() 시스템 콜을 호출해 자식 프로세스인 Zygote’ 프로세스를 생성한다. 생성된 Zygote’ 프로세스는 부모인 Zygote 프로세스의 코드 영역과 링크 정보를 공유한다. 새로운 안드로이드 애플리케이션 A는 fork()를 통해 생성도니 프로세스의 코드 영역을 새롭게 로딩하는 것이 아니라, 복제된 달빅 가상 머신 위에 동적으로 로딩된다. 이후에 zygote’ 프로세스는 애플리케이션 A 클래스의 메서드로 실행 흐름을 넘겨 안드로이드 애플리케이션이 동작하게 된다. <strong>새로 생성된 애플리케이션 A는 기존의 Zygote 프로세스가 구성해 놓은 라이브러리 및 리소스에 대한 링크정보를 그대로 사용하기에 빠르게 실행된다.</strong><br>다음은 Zygote가 실행되고 나서 새로운 안드로이드 애플리케이션 A가 실행되기까지의 과정을 나타낸다.  </p><p><img src="/images/post/zygote4.png" alt="zygote4" title="zygote4">  </p><p>Zygote는 달빅 가상 머신을 초기화하고, 필요한 클래스와 자원을 메모리에 로딩한다. fork()를 통해 새로 생성된 Zygote’ 프로세스는 마지막 단계에서 새로 실행되는 안드로이드 애플리케이션 A를 동적으로 로딩하고 실행한다. 실행되는 애플리케이션 A는 Zygote가 미리 초기화하고 실행한 달빅 가상 머신의 코드를 그대로 사용하며, 미리 메모리에 로딩해둔 클래스와 자원을 사용함으로써 빠르게 실행된다.  </p><h4 id="app-process로부터-ZygoteInit-class-실행"><a href="#app-process로부터-ZygoteInit-class-실행" class="headerlink" title="app_process로부터 ZygoteInit class 실행"></a>app_process로부터 ZygoteInit class 실행</h4><p>Zygote는 자바로 작성돼 있으므로 다른 네이티브 서비스나 데몬과 같이 init 프로세스에서 바로 실행할 수 없다. 자바로 작성돼 있는 Zygote 클래스가 동작하려면 달빅 가상 머신이 생성돼야 하고, 생성된 가상 머신 위에서 Zygoteinit 클래스를 로딩하고 실행해야 한다. 이러한 작업을 수행하는 프로세스가 바로 <strong>app_process</strong>다.  </p><p><img src="/images/post/zygote5.png" alt="zygote5" title="zygote5">  </p><p>&#x2F;System&#x2F;bin&#x2F;app_process의 소스 코드에 있는 main() 함수에서 AppRuntime 객체를 생성한 후 main() 함수에 전달된 인자 값을 분석해서 AppRuntime 객체에 전달한다. 그러고 나서 달빅 가상 머신을 초기화하고 생성한 다음 마지막으로 ZygoteInit 클래스의 main() 메서드를 호출한다.  </p><h4 id="ZygoteInit-클래스의-기능"><a href="#ZygoteInit-클래스의-기능" class="headerlink" title="ZygoteInit 클래스의 기능"></a>ZygoteInit 클래스의 기능</h4><p><img src="/images/post/zygote6.png" alt="zygote6" title="zygote6">  </p><p>그림은 ZygoteInit::main() 메서드의 기능을 요약했다.<br>main() 메서드에서는 새로운 안드로이드 애플리케이션을 실행하기 위한 요청을 수신하는 데 쓸 소켓을 바인딩한다. 안드로이드 애플리케이션 프레임워크에서 사용할 클래스와 리소스를 로딩하고 <strong>SystemServer</strong>를 실행한다. 시스템 서버는 안드로이드 플랫폼에 필요한 주요 네이티브 서비스들을 실행하게 된다. 이후에 등록된 UDS를 모니터링하고 있다가 새로운 안드로이드 애플리케이션의 생성 요청을 받으면 이를 처리하는 루프로 진입한다.  </p><p>ZygoteInit 클래스는 &#x2F;dev&#x2F;socket&#x2F;zygote에 생성된 유닉스 도메인 소켓을 사용해서 ActivityManager로부터 전달되는 새 안드로이드 애플리케이션의 생성 요청 메시지를 수신한다. 이 소켓은 init 부팅 과정에서 프로세스에 의해 생성되며, init.rc에 기술돼 있다.<br>또한 ZygoteInit 클래스는 preloadClasses()와 preloadResources() 메서드를 호출한다. 각 메서드는 안드로이드 애플리케이션 프레임워크에 포함되는 클래스와 아이콘, 이미지, 문자열 등의 자원을 미리 메모리에 로딩하고 로딩한 클래스와 자원에 대한 연결 정보를 생성한다. 이후 새로 생성되는 안드로이드 애플리케이션에서는 미리 로딩한 클래스나 자원을 이용할 때 새로 연결정보를 생성하지 않고 그대로 이용한다.  </p><p>그렇다면 사용할 클래스를 메모리에 미리 로딩하는 것이 얼마만큼의 효과가 있을까? logcat 명령어를 통해 확인하면 1942개의 클래스를 로딩하는 데 18202ms가 걸렸다. 만약 미리 로딩하는 과정이 없을 경우, 18202ms의 추가시간이 걸리게 된다.  </p><p>Zygote에서 달빅 가상 머신을 구동한 이후, 시스템 서버(SystemServer)라는 자바 서비스를 실행하기 위해 새로운 달빅 가상 머신 인스턴스를 생성한다. 시스템 서버는 필요한 네이티브 서비스를 실행하고, 안드로이드 프레임워크의 서비스들을 시작한다. 이때 시작되는 서비스로는 안드로이드 애플리케이션의 액티비티를 관리하는 액티비티 매니저(ActivityManager), 애플리케이션을 설치, 관리하는 패키지 매니저(PackageManager)등이 있다.  </p><p>다음 그림은 ZygoteInit 클래스가 새로운 프로세스를 생성하는 과정을 나타낸다.  </p><p><img src="/images/post/zygote7.png" alt="zygote7" title="zygote7">  </p>]]></content>
    
    
    <categories>
      
      <category>Android</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Android</tag>
      
      <tag>인사이드 안드로이드</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[인사이드 안드로이드] 챕터 4 - JNI와 NDK(3)</title>
    <link href="/chapter4_3/"/>
    <url>/chapter4_3/</url>
    
    <content type="html"><![CDATA[<h1 id="인사이드-안드로이드"><a href="#인사이드-안드로이드" class="headerlink" title="[인사이드 안드로이드]"></a>[인사이드 안드로이드]</h1><h2 id="Chapter4-JNI와-NDK-3"><a href="#Chapter4-JNI와-NDK-3" class="headerlink" title="Chapter4 - JNI와 NDK(3)"></a>Chapter4 - JNI와 NDK(3)</h2><h3 id="안드로이드-NDK로-개발하기"><a href="#안드로이드-NDK로-개발하기" class="headerlink" title="안드로이드 NDK로 개발하기"></a>안드로이드 NDK로 개발하기</h3><p>안드로이드 NDK(Native Development Kit)는 애플리케이션 개발자가 JNI를 활용한 작업을 쉽게 할 수 있도록 구글에서 제공하는 개발 도구다.  </p><h4 id="안드로이드-NDK환경-설정"><a href="#안드로이드-NDK환경-설정" class="headerlink" title="안드로이드 NDK환경 설정"></a>안드로이드 NDK환경 설정</h4><p>1.NDK 다운로드  </p><p><a href="http://developer.android.com/intl/ko/ndk/downloads/index.html">http://developer.android.com/intl/ko/ndk/downloads/index.html</a>  </p><p>2.압축 해제  </p><p>적절한 경로에 압축을 해제한다.  </p><figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs llvm">unzip android-ndk-r<span class="hljs-number">19</span><span class="hljs-keyword">c</span>-linux-<span class="hljs-keyword">x</span><span class="hljs-number">86</span>_<span class="hljs-number">64</span>.zip<br></code></pre></td></tr></table></figure><p>3.NDK 경로설정  </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo nano ~/.bashrc<br></code></pre></td></tr></table></figure><p>맨 아래부분에 다음을 추가합니다.  </p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-built_in">export</span> <span class="hljs-attribute">PATH</span>=<span class="hljs-variable">$&#123;PATH&#125;</span>:(압축푼 경로)/android-ndk-r19c<br></code></pre></td></tr></table></figure><p>저와같은 경우에는 다음과 같이 입력했습니다.  </p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs elixir">export <span class="hljs-title class_">PATH</span>=<span class="hljs-variable">$&#123;</span><span class="hljs-title class_">PATH</span>&#125;<span class="hljs-symbol">:/home/kyungsoo/android-ndk-r19c</span><br></code></pre></td></tr></table></figure><p>다음과 같이 입력해 적용완료.  </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">source</span> /.bashrc<br></code></pre></td></tr></table></figure><p>ndk-build 명령을 실행했을 때 아래와 같이 실행되면 NDK 설정이 제대로 된 것이다.  </p><p><img src="/images/post/ndk1.png" alt="ndk1" title="ndk1">  </p><h4 id="안드로이드-NDK개발-따라하기"><a href="#안드로이드-NDK개발-따라하기" class="headerlink" title="안드로이드 NDK개발 따라하기"></a>안드로이드 NDK개발 따라하기</h4><p>프로젝트를 먼저 생성하고 Activity의 내용을 다음과 같이 수정한다.  </p><p><img src="/images/post/ndk2.png" alt="ndk2" title="ndk2">  </p><p>javah 유틸을 실행하여 헤더 파일을 생성한다.  </p><p><img src="/images/post/ndk3.png" alt="ndk3" title="ndk3">  </p><p>프로젝트 밑에 jni폴더를 생성하고 JNI 네이티브 함수를 구현한다.    </p><p><img src="/images/post/ndk4.png" alt="ndk4" title="ndk4"><br><img src="/images/post/ndk5.png" alt="ndk5" title="ndk5"><br><img src="/images/post/ndk6.png" alt="ndk6" title="ndk6">  </p><p>동일하게 jni폴더에 Android.mk 파일을 작성한다.  </p><p><img src="/images/post/ndk7.png" alt="ndk7" title="ndk7">  </p><p>프로젝트 홈 디렉터리에서 ndk-build를 실행한다.  </p><p><img src="/images/post/ndk8.png" alt="ndk8" title="ndk8">  </p><p>이제 프로젝트를 빌드해서 실행하면 다음과 같이 1000과 42의 합인 1042가 출력된다.  </p><p><img src="/images/post/ndk9.png" alt="ndk9" title="ndk9">  </p>]]></content>
    
    
    <categories>
      
      <category>Android</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Android</tag>
      
      <tag>인사이드 안드로이드</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[인사이드 안드로이드] 챕터 4 - JNI와 NDK(2)</title>
    <link href="/chapter4_2/"/>
    <url>/chapter4_2/</url>
    
    <content type="html"><![CDATA[<h1 id="인사이드-안드로이드"><a href="#인사이드-안드로이드" class="headerlink" title="[인사이드 안드로이드]"></a>[인사이드 안드로이드]</h1><h2 id="Chapter4-JNI와-NDK-2"><a href="#Chapter4-JNI와-NDK-2" class="headerlink" title="Chapter4 - JNI와 NDK(2)"></a>Chapter4 - JNI와 NDK(2)</h2><h3 id="JNI-함수-이용하기"><a href="#JNI-함수-이용하기" class="headerlink" title="JNI 함수 이용하기"></a>JNI 함수 이용하기</h3><h4 id="JNI-함수를-활용하는-예제-프로그램의-구조"><a href="#JNI-함수를-활용하는-예제-프로그램의-구조" class="headerlink" title="JNI 함수를 활용하는 예제 프로그램의 구조"></a>JNI 함수를 활용하는 예제 프로그램의 구조</h4><p>예제 프로그램의 전체적인 구조는 다음과 같다.<br>① 네이티브 메서드가 선언된 JniFuncMain 클래스<br>② JniTest 객체<br>③ 네이티브 메서드가 실제 구현이 포함된 jnitest.so  </p><h4 id="자바측-코드-살펴보기-JniFuncMain-java"><a href="#자바측-코드-살펴보기-JniFuncMain-java" class="headerlink" title="자바측 코드 살펴보기(JniFuncMain.java)"></a>자바측 코드 살펴보기(JniFuncMain.java)</h4><p>JniFuncMain 클래스는 다음과 같다.  </p><p><img src="/images/post/jni5.png" alt="jni5" title="jni5">  </p><p>JniTest 클래스는 다음과 같다.</p><p><img src="/images/post/jni6.png" alt="jni6" title="jni6">  </p><h4 id="JNI-네이티브-함수의-코드-살펴보기"><a href="#JNI-네이티브-함수의-코드-살펴보기" class="headerlink" title="JNI 네이티브 함수의 코드 살펴보기"></a>JNI 네이티브 함수의 코드 살펴보기</h4><p>JniFuncMain.h 헤더 파일은 javah명령어를 통해 생성한다.</p><p><img src="/images/post/jni7.png" alt="jni7" title="jni7">  </p><p>실제 함수 코드인 jnifunc.cpp는 다음과 같다.  </p><p><img src="/images/post/jni8.png" alt="jni8" title="jni8">  </p><p>cpp파일 까지 작성을 완료한 후 이전 포스트 처럼 .so파일을 생성한다.<br>여기서는 c가 아닌 cpp이기때문에 gcc가 아닌 g++로 컴파일을 한다.  </p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs awk">g++ -I<span class="hljs-regexp">/(jdk경로)/i</span>nclude<span class="hljs-regexp">/ -I/</span>(jdk경로)<span class="hljs-regexp">/include/</span>linux -shared -fPIC jnifunc.cpp -o libjnifunc.so<br><br>sudo mv libjnifunc.so <span class="hljs-regexp">/usr/</span>lib/<br><br>java JniFuncMain<br></code></pre></td></tr></table></figure><p>JniFuncMain의 결과는 다음과 같다.  </p><p><img src="/images/post/jni9.png" alt="jni9" title="jni9">  </p><h4 id="안드로이드에서의-활용-예"><a href="#안드로이드에서의-활용-예" class="headerlink" title="안드로이드에서의 활용 예"></a>안드로이드에서의 활용 예</h4><ul><li>frameworks&#x2F;base&#x2F;core&#x2F;jni</li><li>frameworks&#x2F;base&#x2F;services&#x2F;jni</li><li>frameworks&#x2F;base&#x2F;media&#x2F;jni</li></ul><h3 id="C프로그램에서-자바-클래스-실행하기"><a href="#C프로그램에서-자바-클래스-실행하기" class="headerlink" title="C프로그램에서 자바 클래스 실행하기"></a>C프로그램에서 자바 클래스 실행하기</h3><p>지금까지는 자바 코드가 메인 프로그램이고 자바 쪽 코드에서 네이티브 메서드를 통해 C 함수를 호출해서 JNI를 이용하는 방식이었다.<br>지금부터는 C&#x2F;C++로 구현된 메인 애플리케이션에서 자바 클래스를 실행하는 JNI이용 방식이다.  </p><h4 id="C-코드-invocationApi-c-살펴보기"><a href="#C-코드-invocationApi-c-살펴보기" class="headerlink" title="C 코드(invocationApi.c) 살펴보기"></a>C 코드(invocationApi.c) 살펴보기</h4><p>자바 가상 머신을 생성하고 실행할 클래스 및 메서드를 받아와 호출하는 코드이다.  </p><p><img src="/images/post/jni10.png" alt="jni10" title="jni10">  </p><h4 id="자바-코드-InvocationApiTest-java-살펴보기"><a href="#자바-코드-InvocationApiTest-java-살펴보기" class="headerlink" title="자바 코드(InvocationApiTest.java) 살펴보기"></a>자바 코드(InvocationApiTest.java) 살펴보기</h4><p>main() 메서드 하나만 포함한 간단한 클래스이다.  </p><p><img src="/images/post/jni11.png" alt="jni11" title="jni11">  </p><h4 id="컴파일-및-실행"><a href="#컴파일-및-실행" class="headerlink" title="컴파일 및 실행"></a>컴파일 및 실행</h4><p>자바 코드 컴파일은 다음과같이 javac를 이용하여 진행한다.  </p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm"><span class="hljs-keyword">javac </span>InvocationApiTest.<span class="hljs-keyword">java</span><br></code></pre></td></tr></table></figure><p>책에서와 달리 우분투에서 진행했기 때문에 C 코드는 .exe 파일이 아닌 .out 파일을 생성한다.<br>컴파일시 libjvm.so를 포함해야 하므로 &#x2F;etc&#x2F;profile의 LD_LIBRARY_PATH를 수정해준다.  </p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">sudo nano <span class="hljs-regexp">/etc/</span>profile<br></code></pre></td></tr></table></figure><p>export LD_LIBRARY_PATH 부분이 존재한다면 libjvm.so 파일이 존재하는 위치를 추가해준다.<br>나는 &#x2F;usr&#x2F;lib&#x2F;jvm&#x2F;java5&#x2F;jdk1.5.0_22&#x2F;jre&#x2F;lib&#x2F;amd64&#x2F;server 위치에 있었기 때문에 다음과 같이 입력했다.  </p><p>export LD_LIBRARY_PATH&#x3D;&#x2F;usr&#x2F;lib:&#x2F;usr&#x2F;local&#x2F;lib:&#x2F;usr&#x2F;lib&#x2F;jvm&#x2F;java5&#x2F;jdk1.5.0_22&#x2F;jre&#x2F;lib&#x2F;amd64&#x2F;server  </p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gradle"><span class="hljs-keyword">source</span> <span class="hljs-regexp">/etc/</span>profile<br></code></pre></td></tr></table></figure><p>이제 C파일을 다음과 같은 명령어를 통해 컴파일한다.  </p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">gcc -I<span class="hljs-regexp">/(JAVA_HOME)/i</span>nclude<span class="hljs-regexp">/ -I/</span>(JAVA_HOME)<span class="hljs-regexp">/include/</span>linux -L/(libjvm.so 위치) -fPIC invocationApi.c -o invocationApi.out -ljvm<br></code></pre></td></tr></table></figure><p>나와 같은 경우에는 다음과 같이 입력했다.</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">gcc -I<span class="hljs-regexp">/usr/</span>lib<span class="hljs-regexp">/jvm/</span>java5<span class="hljs-regexp">/jdk1.5.0_22/i</span>nclude<span class="hljs-regexp">/ -I/u</span>sr<span class="hljs-regexp">/lib/</span>jvm<span class="hljs-regexp">/java5/</span>jdk1.<span class="hljs-number">5.0</span>_22<span class="hljs-regexp">/include/</span>linux -L<span class="hljs-regexp">/usr/</span>lib<span class="hljs-regexp">/jvm/</span>java5<span class="hljs-regexp">/jdk1.5.0_22/</span>jre<span class="hljs-regexp">/lib/</span>amd64/server -fPIC invocationApi.c -o invocationApi.out -ljvm<br></code></pre></td></tr></table></figure><p>이제 실행 파일인 invocationApit.out을 실행한다.  </p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ada">./invocationApi.<span class="hljs-keyword">out</span><br></code></pre></td></tr></table></figure><p><img src="/images/post/jni12.png" alt="jni12" title="jni12">  </p><h4 id="안드로이드에서-활용-예-Zygote-프로세스"><a href="#안드로이드에서-활용-예-Zygote-프로세스" class="headerlink" title="안드로이드에서 활용 예: Zygote 프로세스"></a>안드로이드에서 활용 예: Zygote 프로세스</h4><p>5장에서 알아볼 자바 기반의 <strong>Zygote 프로세스</strong>도 <strong>app_process</strong>라는 C++ 기반의 네이티브 애플리케이션에서 JNI 호출 API를 통해 실행된다.  </p><p>app_process는 안드로이드 프레임워크가 부팅될 때 안드로이드 런타임을 초기화하고 Zygote 프로세스를 실행하는 역할을 하는 프로세스다. 또한 Zygote는 안드로이드 프레임워크의 성능을 향상 시키기 위한 특별한 프로세스로서 모든 안드로이드 애플리케이션의 프로세스는 Zygote에서 fork된다. 이러한 <strong>Zygote 프로세스는 안드로이드 zygoteInit 클래스라는 자바 프로그램으로 구성돼있다.</strong> 따라서 app_process는 안드로이드가 부팅할 때 JNI 호출 API를 이용해서 자신의 프로그램 영역에 달빅 가상 머신을 로드하고, ZygoteInit 클래스의 main() 메서드를 호출해서 Zygote를 실행한다.  </p><h3 id="JNI-네이티브-함수-직접-등록하기"><a href="#JNI-네이티브-함수-직접-등록하기" class="headerlink" title="JNI 네이티브 함수 직접 등록하기"></a>JNI 네이티브 함수 직접 등록하기</h3><p>이전 포스트의 ‘JNI 기본 원리 이해하기’에서 설명했듯이 자바 가상 머신은 네이티브 메서드를 포함하는 자바 애플리케이션을 실행할 때 아래의 두 단계를 거친다.  </p><ol><li>System.loadLibrary() 메서드를 이용해서 네이티브 메서드의 실제 구현이 포함된 C&#x2F;C++ 라이브러리를 메모리 상에 로드한다.  </li><li>자바 가상 머신은 위에서 로드된 라이브러리의 함수 심볼을 검색해서 자바에서 선언된 네이티브 메서드의 시그너처와 일치하는 JNI 네이티브 함수 심볼을 찾은 다음 네이티브 메서드와 실제 구현인 JNI 네이티브 함수를 매핑한다.</li></ol><p>JNI는 C&#x2F;C++ 개발자가 JNI 네이티브 함수를 직접 자바 클래스의 네이티브 메서드에 매핑할 수 있게 해주는 RegisterNatives()라는 JNI 함수를 제공한다. RegisterNatives() 함수를 이용하면 자바 가상 머신이 자동으로 심볼을 검색해서 적장할 JNI 네이티브 함수를 연결하는 작업을 대신해 별도의 매핑 과정을 생략할 수 있어 로딩 속도를 향상시킬 수 있다.  </p><h4 id="네이티브-라이브러리-로드-시에-JNI네이티브-함수-등록하기"><a href="#네이티브-라이브러리-로드-시에-JNI네이티브-함수-등록하기" class="headerlink" title="네이티브 라이브러리 로드 시에 JNI네이티브 함수 등록하기"></a>네이티브 라이브러리 로드 시에 JNI네이티브 함수 등록하기</h4><p>이전 포스트에서의 hellojni.c 코드를 자바 가상 머신 대신에 직접 네이티브 메서드와 C 함수를 매핑한 hellojnimap.cpp 코드로 수정해본다.  </p><p>우선 System.loadLibrary() 메서드의 동작 방식을 알아보자.  </p><ol><li>자바 코드에서 System.loadLibrary() 메서드를 호출하면 자바 가상 머신은 주어진 이름을 가진 공유 라이브러리를 로드한다.  </li><li>자바 가상 머신은 로드한 라이브러리 내의 함수 심볼을 검색해서 JNI_OnLoad()라는 함수가 구현돼 있는지 확인하고 라이브러리에 해당 함수가 포함돼 있으면 자동으로 JNI_OnLoad() 함수를 호출한다.  </li><li>만약 JNI_OnLoad() 함수가 구현돼 있지 않다면 자바 가상 머신은 자동으로 네이티브 메서드와 라이브러리 내의 JNI 네이티브 함수의 심볼을 비교해서 매핑 작업을 수행한다.</li></ol><p>다음은 hellojnimap.cpp 소스 코드이다.  </p><p><img src="/images/post/jni13.png" alt="jni13" title="jni13">  </p><p>컴파일 화면은 다음과 같다.  </p><p><img src="/images/post/jni14.png" alt="jni14" title="jni14">  </p>]]></content>
    
    
    <categories>
      
      <category>Android</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Android</tag>
      
      <tag>인사이드 안드로이드</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[인사이드 안드로이드] 챕터 4 - JNI와 NDK(1)</title>
    <link href="/chapter4/"/>
    <url>/chapter4/</url>
    
    <content type="html"><![CDATA[<h1 id="인사이드-안드로이드"><a href="#인사이드-안드로이드" class="headerlink" title="[인사이드 안드로이드]"></a>[인사이드 안드로이드]</h1><h2 id="Chapter4-JNI와-NDK-1"><a href="#Chapter4-JNI와-NDK-1" class="headerlink" title="Chapter4 - JNI와 NDK(1)"></a>Chapter4 - JNI와 NDK(1)</h2><h3 id="안드로이드와-JNI"><a href="#안드로이드와-JNI" class="headerlink" title="안드로이드와 JNI"></a>안드로이드와 JNI</h3><p>안드로이드 프레임워크는 자바와 C&#x2F;C++ 기반 모듈이 계층별로 구성돼 있다. C&#x2F;C++ 레이어와 자바 레이어가 서로 상호 작용하면서 동작하고 있다.<br>이처럼 프레임워크에서 유기적으로 동작하게 만들려면 자바레이어(상위)와 C&#x2F;C++ 레이어(하위)를 상호 연결해 주는 매개체가 필요하다.<br>자바와 C&#x2F;C++ 모듈 간의 인터페이스를 가능하게 해주는 것이 바로 **JNI(Java Native Interface)**다.  </p><p>JNI는 일반적으로 다음과 같은 경우에 주로 활용한다.  </p><ul><li>빠른 처리 속도를 요구하는 루틴 작성(자바는 C&#x2F;C++보다 느리기 때문에 C&#x2F;C++로 작성하고 JNI를 통해 자바에서 호출하는 방법)  </li><li>하드웨어 제어(하드웨어 제어 코드를 C로 작성하면 JNI를 통해 자바에서도 하드웨어 제어 가능)  </li><li>기존 C&#x2F;C++ 프로그램의 재사용</li></ul><p><strong>JNI에 대해 알아야 하는 이유</strong><br>안드로이드에서는 JNI를 이용하여 자바와 C&#x2F;C++의 장점을 동시에 활용하고 있다.<br>안드로이드 SDK를 토대로 만든 안드로이드 애플리케이션은 달빅 가상 머신(Dalvik Virtual Machine) 위에서 동작하는 자바 기반의 프로그램이다. 때문에 C&#x2F;C++로 생성한 애플리케이션에 비해 느린 실행속도 등의 한계를 가진다. 프로그램의 주요 모듈은 자바 개발자가, 성능에 민감한 모듈은 C&#x2F;C++ 개발자가 작성한다.<br>안드로이드를 탑재할 장치에 안드로이드 프레임워크에서 지원하지 않는 하드웨어가 설치돼 있다면 디바이스 드라이버를 C언어로 구현하고 JNI로 매핑시켜야 한다.  </p><h3 id="JNI의-기본-원리-이해"><a href="#JNI의-기본-원리-이해" class="headerlink" title="JNI의 기본 원리 이해"></a>JNI의 기본 원리 이해</h3><h4 id="자바에서-C-라이브러리-함수-호출하기"><a href="#자바에서-C-라이브러리-함수-호출하기" class="headerlink" title="자바에서 C 라이브러리 함수 호출하기"></a>자바에서 C 라이브러리 함수 호출하기</h4><h5 id="자바-코드-작성"><a href="#자바-코드-작성" class="headerlink" title="자바 코드 작성"></a>자바 코드 작성</h5><p><img src="/images/post/jni1.png" alt="jni1" title="jni1">  </p><p>JNI 네이티브 함수와 연결할 메서드를 <strong>native 키워드</strong>를 이용해서 선언한다.<br>네이티브 메서드가 실제로 구현돼 있는 C 라이브러리를 <strong>System.loadLibraray() 메서드</strong>를 호출해서 로딩한다.  </p><h5 id="자바-코드-컴파일"><a href="#자바-코드-컴파일" class="headerlink" title="자바 코드 컴파일"></a>자바 코드 컴파일</h5><p>작성한 소스 코드를 javac(자바 컴파일러)로 컴파일한다. 컴파일 후에 .class파일이 생성되지만 자바 가상 머신이 로딩할 C라이브러리를 찾지 못하여 실행 시 아래와 같이 오류가 출력된다.  </p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs stylus">Exception <span class="hljs-keyword">in</span> thread <span class="hljs-string">&quot;main&quot;</span> java<span class="hljs-selector-class">.lang</span><span class="hljs-selector-class">.UnsatisfiedLinkError</span>: no hellojni <span class="hljs-keyword">in</span> java<span class="hljs-selector-class">.library</span><span class="hljs-selector-class">.path</span><br>    at java<span class="hljs-selector-class">.lang</span><span class="hljs-selector-class">.ClassLoader</span><span class="hljs-selector-class">.loadLibrary</span>(ClassLoader<span class="hljs-selector-class">.java</span>:<span class="hljs-number">1684</span>)<br>    at java<span class="hljs-selector-class">.lang</span><span class="hljs-selector-class">.Runtime</span><span class="hljs-selector-class">.loadLibrary0</span>(Runtime<span class="hljs-selector-class">.java</span>:<span class="hljs-number">822</span>)<br>    at java<span class="hljs-selector-class">.lang</span><span class="hljs-selector-class">.System</span><span class="hljs-selector-class">.loadLibrary</span>(System<span class="hljs-selector-class">.java</span>:<span class="hljs-number">993</span>)<br>    at HelloJNI.&lt;clinit&gt;(HelloJNI<span class="hljs-selector-class">.java</span>:<span class="hljs-number">6</span>)<br></code></pre></td></tr></table></figure><h5 id="C-헤더-파일-생성"><a href="#C-헤더-파일-생성" class="headerlink" title="C 헤더 파일 생성"></a>C 헤더 파일 생성</h5><p>javah툴을 이용하여 헤더파일을 생성한다.<br>생성된 .h파일의 내용은 다음과 같다.<br><img src="/images/post/jni2.png" alt="jni2" title="jni2">  </p><h5 id="C-x2F-C-코드-구현"><a href="#C-x2F-C-코드-구현" class="headerlink" title="C&#x2F;C++ 코드 구현"></a>C&#x2F;C++ 코드 구현</h5><p>헤더파일에 정의된 함수 원형을 .c파일에 복사하여 구현을 완료한다. 이 때 <strong>매개변수의 이름을 지정</strong>해 주어야한다.<br><img src="/images/post/jni3.png" alt="jni3" title="jni3">  </p><h5 id="C-공유-라이브러리-생성"><a href="#C-공유-라이브러리-생성" class="headerlink" title="C 공유 라이브러리 생성"></a>C 공유 라이브러리 생성</h5><p>헤더 파일과 소스 파일을 가지고 공유 라이브러리를 만든다. 윈도우에서는 .dll파일을 생성한다.<br>나는 우분투에서 진행했기 때문에 아래와 같은 명령어로 .so파일을 생성한다.  </p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">gcc -I<span class="hljs-regexp">/(JAVA_HOME)/i</span>nclude<span class="hljs-regexp">/ -I/</span>(JAVA_HOME)<span class="hljs-regexp">/include/</span>linux -shared -fPIC hellojni.c -o libhellojni.so<br></code></pre></td></tr></table></figure><p><strong>(JAVA_HOME)부분에는 JDK가 설치된 경로를 입력한다.</strong><br>나와 같은 경우에는 다음과 같이 입력했다.  </p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">gcc -I<span class="hljs-regexp">/usr/</span>lib<span class="hljs-regexp">/jvm/</span>java5<span class="hljs-regexp">/jdk1.5.0_22/i</span>nclude<span class="hljs-regexp">/ -I/u</span>sr<span class="hljs-regexp">/lib/</span>jvm<span class="hljs-regexp">/java5/</span>jdk1.<span class="hljs-number">5.0</span>_22<span class="hljs-regexp">/include/</span>linux -shared -fPIC hellojni.c -o libhellojni.so<br></code></pre></td></tr></table></figure><p><strong>-shared &#x3D; .so파일을 생성하기 위해 붙여준다.</strong><br><strong>-fPIC &#x3D; 우분투가 64bit 일 때 붙여준다.</strong><br><strong>.so 파일을 만들때 파일이름 앞에 lib를 붙여줘야 한다!</strong>  </p><h5 id="lib-path-추가"><a href="#lib-path-추가" class="headerlink" title="lib path 추가"></a>lib path 추가</h5><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">sudo nano <span class="hljs-regexp">/etc/</span>profile<br></code></pre></td></tr></table></figure><p>nano 에디터에서 맨 아랫줄에 삽입<br>export LD_LIBRARY_PATH&#x3D;&#x2F;usr&#x2F;lib:&#x2F;usr&#x2F;local&#x2F;lib  </p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs gradle"><span class="hljs-keyword">source</span> <span class="hljs-regexp">/etc/</span>profile<br>sudo mv libhellojni.so <span class="hljs-regexp">/usr/</span>lib/<br></code></pre></td></tr></table></figure><h5 id="자바-프로그램-실행"><a href="#자바-프로그램-실행" class="headerlink" title="자바 프로그램 실행"></a>자바 프로그램 실행</h5><p>자바 클래스를 실행하면 앞서 작업한 내용이 제대로 실행되는 것을 볼 수 있다.  </p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">java HelloJNI</span><br></code></pre></td></tr></table></figure><p><img src="/images/post/jni4.png" alt="jni4" title="jni4">  </p>]]></content>
    
    
    <categories>
      
      <category>Android</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Android</tag>
      
      <tag>인사이드 안드로이드</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[인사이드 안드로이드] 챕터 3 - init 프로세스(2)</title>
    <link href="/chapter3_2/"/>
    <url>/chapter3_2/</url>
    
    <content type="html"><![CDATA[<h1 id="인사이드-안드로이드"><a href="#인사이드-안드로이드" class="headerlink" title="[인사이드 안드로이드]"></a>[인사이드 안드로이드]</h1><h2 id="Chapter3-init-프로세스-2"><a href="#Chapter3-init-프로세스-2" class="headerlink" title="Chapter3 - init 프로세스(2)"></a>Chapter3 - init 프로세스(2)</h2><h3 id="디바이스-노드-파일-생성"><a href="#디바이스-노드-파일-생성" class="headerlink" title="디바이스 노드 파일 생성"></a>디바이스 노드 파일 생성</h3><p>안드로이드에서 애플리케이션이 하드웨어에 접근할 때 <strong>디바이스 드라이버</strong>를 통해서 접근한다.<br>애플리케이션은 디바이스 드라이버에 접근하기 위해 <strong>디바이스 노드</strong>를 사용한다.<br>리눅스에서는 ‘mknod’유틸리티를 지원하지만 <strong>안드로이드에서는 보안문제로 제공하지 않는다.</strong>  </p><h4 id="정적-디바이스-노드-생성"><a href="#정적-디바이스-노드-생성" class="headerlink" title="정적 디바이스 노드 생성"></a>정적 디바이스 노드 생성</h4><p>리눅스에서는 디바이스 노드파일을 “&#x2F;dev” 디렉터리에 정의하고, 이 노드파일을 통해 디바이스 드라이버에 접근한다.<br>하지만 안드로이드의 루트 파일 시스템은 “&#x2F;dev” 디렉터리가 존재하지 않고, <strong>init 프로세스가 두 가지 방법으로 디바이스 노드 파일을 생성</strong>한다.</p><p>① 미리 정의된 디바이스 정보를 바탕으로 init 프로세스가 실행될 때 일괄적으로 디바이스 노드 파일 생성 - <strong>콜드 플러그(Cold Plug)</strong><br>② 시스템 동작 중 USB와 같은 장치가 삽입될 때 이벤트 처리로 디바이스 노드 파일을 동적으로 생성 - <strong>핫 플러그(Hot Plug)</strong>  </p><h5 id="콜드-플러그-방식"><a href="#콜드-플러그-방식" class="headerlink" title="콜드 플러그 방식"></a>콜드 플러그 방식</h5><p>콜드 플러그는 이미 삽입된 장치에 대한 처리를 담당하는 메커니즘.<br>리눅스에서는 부팅 후에 udev 데몬이 실행되면서 “&#x2F;sys” 디렉터리에서 미리 등록된 디바이스 정보를 읽고, 디바이드에 대해 uevent를 발생시켜 디바이스 노드 파일을 생성하는 방식이다.<br><em>udev &#x3D; “&#x2F;dev” 디렉터리에 자동으로 디바이스 노드 파일을 생성하는 역할</em><br><em>uevent &#x3D; 커널에서 사용자 공간의 프로세스로 메시지를 전달하기 위한 신호 체계</em>  </p><p>이를 안드로이드에서는 udev 데몬의 역할을 <strong>init 프로세스가 수행</strong>한다.  </p><p>책에서는 콜드 플러그 방식으로 디바이스 노드를 생성하는 예로 7장의 ‘안드로이드 바인더 IPC’를 통해 설명한다.<br>먼저 바인더 드라이버는 가상의 장치이며 프로세스간의 RPC(Remote Procedure Call)를 제공하는 데 쓰인다.<br>바인더를 이용하려는 응용프로그램은 “&#x2F;dev&#x2F;binder”라는 디바이스 노드를 사용해서 바인더 디바이스에 접근해야 한다.  </p><p><strong>커널 부팅 시</strong><br>커널 부팅 시 바인더 드라이버는 misc_register() 함수를 통해서 디바이스 노드 파일을 생성하는 데 필요한 정보를 “&#x2F;sys” 파일 시스템에 저장한다.<br>이제 init 프로세스를 통해 디바이스 노드 파일을 생성해야 하는데, <strong>아직 커널 부팅 단계이므로 uevent를 발생시킬 수 없다.</strong>  </p><p><strong>커널 부팅 완료</strong><br>init 프로세스가 실행되면 위의 바인더 드라이버처럼 디바이스 노드 파일을 생성하지 못한 드라이버에 대해 콜드플러그 처리를 한다.<br>콜드 플러그 처리될 드라이버들은 아래처럼 <strong>devices.c 파일에 미리 정의</strong>되어있다.  </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">static</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">perms_</span> devperms[] = &#123;  <br>    &#123; <span class="hljs-string">&quot;/dev/null&quot;</span>,          <span class="hljs-number">0666</span>,   AID_ROOT,       AID_ROOT,       <span class="hljs-number">0</span> &#125;,  <br>    &#123; <span class="hljs-string">&quot;/dev/zero&quot;</span>,          <span class="hljs-number">0666</span>,   AID_ROOT,       AID_ROOT,       <span class="hljs-number">0</span> &#125;,  <br>    &#123; <span class="hljs-string">&quot;/dev/full&quot;</span>,          <span class="hljs-number">0666</span>,   AID_ROOT,       AID_ROOT,       <span class="hljs-number">0</span> &#125;,  <br>    &#123; <span class="hljs-string">&quot;/dev/ptmx&quot;</span>,          <span class="hljs-number">0666</span>,   AID_ROOT,       AID_ROOT,       <span class="hljs-number">0</span> &#125;,  <br>    &#123; <span class="hljs-string">&quot;/dev/tty&quot;</span>,           <span class="hljs-number">0666</span>,   AID_ROOT,       AID_ROOT,       <span class="hljs-number">0</span> &#125;,  <br>    &#123; <span class="hljs-string">&quot;/dev/random&quot;</span>,        <span class="hljs-number">0666</span>,   AID_ROOT,       AID_ROOT,       <span class="hljs-number">0</span> &#125;,  <br>    &#123; <span class="hljs-string">&quot;/dev/urandom&quot;</span>,       <span class="hljs-number">0666</span>,   AID_ROOT,       AID_ROOT,       <span class="hljs-number">0</span> &#125;,  <br>    &#123; <span class="hljs-string">&quot;/dev/ashmem&quot;</span>,        <span class="hljs-number">0666</span>,   AID_ROOT,       AID_ROOT,       <span class="hljs-number">0</span> &#125;,  <br>    &#123; <span class="hljs-string">&quot;/dev/binder&quot;</span>,        <span class="hljs-number">0666</span>,   AID_ROOT,       AID_ROOT,       <span class="hljs-number">0</span> &#125;,  <br>    :  <br>    :  <br></code></pre></td></tr></table></figure><p>devperms 구조체를 참고하여 <strong>“&#x2F;dev” 디렉터리에 디바이스 노드 파일들을 생성</strong>한다.<br>구조체는 파일 이름, 접근권한, 사용자 ID, 그룹 ID를 나타낸다.  </p><p><strong>콜드 플러그 처리 절차</strong><br>device_init() 함수는 uevent를 수신하기 위한 소켓을 생성하고, coldboot()를 통해 내부적으로 do_coldboot() 함수를 호출하여 “&#x2F;sys” 디렉터리에 등록된 드라이버에 대해 콜드플러그 처리를 한다.  </p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-built_in">int</span> device<span class="hljs-constructor">_init(<span class="hljs-params">void</span>)</span>  <br>&#123;  <br>    fd = <span class="hljs-keyword">open</span><span class="hljs-constructor">_uevent_socket()</span>; <span class="hljs-comment">// 소켓 생성  </span><br>    t0 = get<span class="hljs-constructor">_usecs()</span>; <span class="hljs-comment">// 시간측정  </span><br>    coldboot(fd, <span class="hljs-string">&quot;/sys/class&quot;</span>);  <br>    coldboot(fd, <span class="hljs-string">&quot;/sys/block&quot;</span>);  <br>    coldboot(fd, <span class="hljs-string">&quot;/sys/devices&quot;</span>);  <br>    t1 = get<span class="hljs-constructor">_usecs()</span>; <span class="hljs-comment">// 시간측정  </span><br>    log<span class="hljs-constructor">_event_print(<span class="hljs-string">&quot;coldboot %ld uS\n&quot;</span>, ((<span class="hljs-params">long</span>)</span> (t1 - t0))); <span class="hljs-comment">// 시간 로그 출력  </span><br>&#125;  <br></code></pre></td></tr></table></figure><p>do_coldboot() 함수에서는 디렉터리 경로를 받아 해당 경로를 이용해 저장된 uevent 파일을 찾은 후, add메시지를 써넣어 uevent를 발생시킨다.<br><em>파일에 add를 넣는다고 uevent가 바로 발생되는가??</em>  </p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">static void <span class="hljs-keyword">do</span><span class="hljs-constructor">_coldboot(<span class="hljs-params">int</span> <span class="hljs-params">event_fd</span>, DIR <span class="hljs-operator">*</span><span class="hljs-params">d</span>)</span>  <br>&#123;  <br>    fd = openat(dfd, <span class="hljs-string">&quot;uevent&quot;</span>, O_WRONLY); <span class="hljs-comment">// uevent 파일을 찾아서  </span><br>    <span class="hljs-keyword">if</span>(fd &gt;= <span class="hljs-number">0</span>) &#123;  <br>        write(fd, <span class="hljs-string">&quot;add\n&quot;</span>, <span class="hljs-number">4</span>); <span class="hljs-comment">// &quot;add&quot; 메시지 추가로 uevent 발생  </span><br>        close(fd);  <br>        handle<span class="hljs-constructor">_device_fd(<span class="hljs-params">event_fd</span>)</span>; <span class="hljs-comment">// uevent 수신하여 처리  </span><br>    &#125;  <br>&#125;  <br></code></pre></td></tr></table></figure><p>그리고 handle_device_fd() 함수에서 uevent를 수신하여 메시지를 수신해서 uevent구조체에 할당한다.<br>uevent 구조체를 완성하면 handle_device_event() 함수를 호출하여 실제 노드 파일을 생성한다.<br><strong>&#x2F;dev 디렉터리 아래에 하위 디렉터리를 생성</strong>한다.  </p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">handle_device_event</span>(<span class="hljs-params"><span class="hljs-keyword">struct</span> uevent *uevent</span>) <span class="hljs-comment">// uevent 구조체를 받아서  </span></span><br>&#123;  <br>  <span class="hljs-keyword">if</span>(!strncmp(uevent-&gt;subsystem, <span class="hljs-string">&quot;block&quot;</span>, <span class="hljs-number">5</span>)) &#123;  <br>          block = <span class="hljs-number">1</span>;  <br>          <span class="hljs-keyword">base</span> = <span class="hljs-string">&quot;/dev/block/&quot;</span>;  <br>          mkdir(<span class="hljs-keyword">base</span>, <span class="hljs-number">0755</span>); <span class="hljs-comment">// 하위 디렉터리를 생성.  </span><br>      &#125;  <br>&#125;  <br></code></pre></td></tr></table></figure><p>하위 디렉터리를 모두 생성하면 <strong>make_device() 함수를 통해 디바이스 노드 파일을 생성</strong>한다.  </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">make_device</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *path, <span class="hljs-type">int</span> block, <span class="hljs-type">int</span> major, <span class="hljs-type">int</span> minor)</span>  </span><br><span class="hljs-function"></span>&#123;  <br>    <span class="hljs-type">mode_t</span> mode;  <br>    <span class="hljs-type">dev_t</span> dev;  <br>    <span class="hljs-built_in">mknod</span>(path, mode, dev); <span class="hljs-comment">// 디바이스 노드 파일 생성  </span><br>    <span class="hljs-built_in">chown</span>(path, uid, <span class="hljs-number">-1</span>);  <br>&#125;  <br></code></pre></td></tr></table></figure><h4 id="동적-디바이스-감지"><a href="#동적-디바이스-감지" class="headerlink" title="동적 디바이스 감지"></a>동적 디바이스 감지</h4><p>init 프로세스는 시스템 동작 중 추가되는 장치의 디바이스 노드 파일 생성을 위해 핫플러그 처리를 지원한다.  </p><h5 id="핫-플러그-방식"><a href="#핫-플러그-방식" class="headerlink" title="핫 플러그 방식"></a>핫 플러그 방식</h5><p>다음과 같이 init 프로세스의 이벤트 처리 루프에서 처리된다.  </p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-built_in">int</span> main(<span class="hljs-built_in">int</span> argc, <span class="hljs-built_in">char</span> **argv)  <br>&#123;  <br>  <span class="hljs-keyword">for</span>(;;) &#123;  <br>        nr = poll(ufds, fd_count, timeout); <span class="hljs-comment">// poll 함수를 통해서 uevent를 감지  </span><br>        :  <br>        :  <br>        <span class="hljs-keyword">if</span> (ufds<span class="hljs-literal">[<span class="hljs-number">0</span>]</span>.revents<span class="hljs-operator"> == </span>POLLIN)  <br>            handle<span class="hljs-constructor">_device_fd(<span class="hljs-params">device_fd</span>)</span>; <span class="hljs-comment">// 콜드 플러그와 같이 handle_device_fd() 함수를 호출  </span><br>  &#125;  <br>&#125;  <br></code></pre></td></tr></table></figure><h3 id="프로세스-종료와-재시작"><a href="#프로세스-종료와-재시작" class="headerlink" title="프로세스 종료와 재시작"></a>프로세스 종료와 재시작</h3><p>다양한 프로세스들이 init 프로세스에 의해 실행되고, 종료되면 시스템 동작에 영향을 미치는 것들이 존재한다.<br>따라서 init 프로세스가 실행하는 프로세스는 일부를 제외하고 <strong>대부분은 재시작된다.</strong><br>프로세스 옵션에 <strong>onshot이 정의돼 있다면 재시작하지 않는다.</strong>  </p><h4 id="프로세스-재시작-코드-분석"><a href="#프로세스-재시작-코드-분석" class="headerlink" title="프로세스 재시작 코드 분석"></a>프로세스 재시작 코드 분석</h4><p>자식 프로세스가 종료되면 다음과 같이 SIGCHLD 시그널에 대한 핸들러를 수행한다.  </p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs scss">static void <span class="hljs-built_in">sigchld_handler</span>(int s) <span class="hljs-comment">// SIGCHLD 시그널 번호를 받는다.  </span><br>&#123;  <br>    <span class="hljs-built_in">write</span>(signal_fd, &amp;s, <span class="hljs-number">1</span>); <span class="hljs-comment">// 소켓 디스크립터에 기록한다.  </span><br>&#125;  <br></code></pre></td></tr></table></figure><p>signal_fd는 이전에 소켓쌍으로 생성됐기 떄문에 수신측 소켓 디스크립터인 <strong>signal_recv_fd</strong>로 시그널 번호를 전송한다.<br>시그널 번호를 받은 signal_recv_fd는 main에서 이미 POLL로 등록돼 있기 때문에 <strong>wait_for_one_process() 함수를 실행</strong>하게 된다.<br><em>poll()함수는 이벤트 처리 루프에서 이벤트를 감시했었음.</em>  </p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-function"><span class="hljs-built_in">int</span> <span class="hljs-title">main</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> argc, <span class="hljs-built_in">char</span> **argv</span>)</span>  <br>&#123;  <br>  <span class="hljs-keyword">for</span>(;;) &#123;  <br>    nr = poll(ufds, fd_count, timeout); <span class="hljs-comment">// poll() 함수는 이벤트를 감시하다가 빠져나옴.  </span><br>    <span class="hljs-keyword">if</span> (nr &lt;= <span class="hljs-number">0</span>)  <br>        <span class="hljs-keyword">continue</span>;  <br><br>    <span class="hljs-keyword">if</span> (ufds[<span class="hljs-number">2</span>].revents == POLLIN) &#123;  <br>        <span class="hljs-comment">/* we got a SIGCHLD - reap and restart as needed */</span>  <br>        read(signal_recv_fd, tmp, <span class="hljs-keyword">sizeof</span>(tmp));  <br>        <span class="hljs-keyword">while</span> (!wait_for_one_process(<span class="hljs-number">0</span>)); <span class="hljs-comment">// wait_for_one_process() 함수를 수행.  </span><br>        <span class="hljs-keyword">continue</span>;  <br>    &#125;  <br>  &#125;  <br>&#125;  <br></code></pre></td></tr></table></figure><p>다음은 <strong>wait_for_one_process() 함수</strong>를 보여준다.  </p><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs xl">static int wait_for_one_process(int <span class="hljs-keyword">block</span>)  <br>&#123;  <br>    :  <br>    :  <br>    <span class="hljs-keyword">while</span> ( (pid = waitpid(-<span class="hljs-number">1</span>, &amp;status, <span class="hljs-keyword">block</span> ? <span class="hljs-number">0</span> : WNOHANG)) == -<span class="hljs-number">1</span> &amp;&amp; errno == EINTR ); <span class="hljs-comment">// 프로세스가 종료되면 할당된 자원을 회수.  </span><br><br>    svc = service_find_by_pid(pid); <span class="hljs-comment">// 종료된 프로세스에 해당하는 서비스 항목을 가져옴.  </span><br><br>    <span class="hljs-function"><span class="hljs-title">if</span> (!(svc-&gt;</span>flags &amp; SVC_ONESHOT)) &#123; <span class="hljs-comment">// 가져온 서비스 항목의 옵션에 SVC_ONESHOT이 설정 되어있는지 체크.  </span><br>        kill(-pid, SIGKILL); <span class="hljs-comment">// SVC_ONESHOT이 설정 되어있으면 종료  </span><br>        NOTICE(<span class="hljs-string">&quot;process &#x27;%s&#x27; killing any children in process group\n&quot;</span>, <span class="hljs-function"><span class="hljs-title">svc</span>-&gt;</span><span class="hljs-keyword">name</span>);  <br>    &#125;  <br><br>    <span class="hljs-comment">/* remove any sockets we may have created */</span>  <br>    <span class="hljs-function"><span class="hljs-title">for</span> (si = svc-&gt;</span><span class="hljs-function"><span class="hljs-title">sockets</span>; si; si = si-&gt;</span>next) &#123; <span class="hljs-comment">// 프로세스가 가진 소켓 디스크립터를 모두 삭제.  </span><br>        char tmp[<span class="hljs-number">128</span>];  <br>        <span class="hljs-function"><span class="hljs-title">snprintf</span>(tmp, sizeof(tmp), ANDROID_SOCKET_DIR&quot;/%s&quot;, si-&gt;</span><span class="hljs-keyword">name</span>);  <br>        unlink(tmp);  <br>    &#125;  <br><br>    <span class="hljs-function"><span class="hljs-title">svc</span>-&gt;</span>pid = <span class="hljs-number">0</span>;  <br>    <span class="hljs-function"><span class="hljs-title">svc</span>-&gt;</span>flags &amp;= (~SVC_RUNNING); <span class="hljs-comment">// 프로세스가 구동중임을 나타내는 pid 값, SVC_RUNNING을 제거.  </span><br><br>        <span class="hljs-comment">/* oneshot processes go into the disabled state on exit */</span>  <br>    <span class="hljs-function"><span class="hljs-title">if</span> (svc-&gt;</span>flags &amp; SVC_ONESHOT) &#123; <span class="hljs-comment">// SVC_ONESHOT 옵션이 설정된 프로세스의 플래그를  </span><br>        <span class="hljs-function"><span class="hljs-title">svc</span>-&gt;</span>flags |= SVC_DISABLED; <span class="hljs-comment">// disabled 설정하고  </span><br>    &#125;  <br><br>        <span class="hljs-comment">/* disabled processes do not get restarted automatically */</span>  <br>    <span class="hljs-function"><span class="hljs-title">if</span> (svc-&gt;</span>flags &amp; SVC_DISABLED) &#123; <span class="hljs-comment">// disabled 설정된 프로세스는  </span><br>        <span class="hljs-function"><span class="hljs-title">notify_service_state</span>(svc-&gt;</span><span class="hljs-keyword">name</span>, <span class="hljs-string">&quot;stopped&quot;</span>);  <br>        return <span class="hljs-number">0</span>; <span class="hljs-comment">// 함수를 빠져나가서 재시작되지 않는다.  </span><br>    &#125;  <br><br>    <span class="hljs-comment">/* Execute all onrestart commands for this service. */</span>  <br>    <span class="hljs-function"><span class="hljs-title">list_for_each</span>(node, &amp;svc-&gt;</span>onrestart.commands) &#123; <span class="hljs-comment">// 재시작할 프로세스가 onrestart 옵션을 가지는지 체크.  </span><br>        cmd = node_to_item(node, struct command, clist);  <br>        <span class="hljs-function"><span class="hljs-title">cmd</span>-&gt;</span><span class="hljs-function"><span class="hljs-title">func</span>(cmd-&gt;</span><span class="hljs-function"><span class="hljs-title">nargs</span>, cmd-&gt;</span>args);  <br>    &#125;  <br><br>    <span class="hljs-function"><span class="hljs-title">svc</span>-&gt;</span>flags |= SVC_RESTARTING; <span class="hljs-comment">// 프로세스의 플래그에 SVC_RESTARTING를 추가한다.  </span><br>&#125;  <br></code></pre></td></tr></table></figure><p>wait_for_one_process() 함수의 실행이 완료되면 <strong>restart_processes() 함수를 실행</strong>한다.  </p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">restart_processes</span>()</span>  <br>&#123;  <br>    process_needs_restart = <span class="hljs-number">0</span>;  <br>    service_for_each_flags(SVC_RESTARTING, restart_service_if_needed); <span class="hljs-comment">// SVC_RESTARTING 플래그를 가진 프로세스를 실행한다.  </span><br>&#125;  <br></code></pre></td></tr></table></figure><p>따라서 자식프로세스가 종료되어 SIGCHLD 시그널을 발생시키더라도 이 함수를 통해 재시작하게 된다.  </p><h3 id="프로퍼티-서비스"><a href="#프로퍼티-서비스" class="headerlink" title="프로퍼티 서비스"></a>프로퍼티 서비스</h3><p>init 프로세스의 이벤트 처리 루프에서는 프로퍼티의 변경 요청 이벤트도 있다.  </p><ul><li>프로퍼티는 안드로이드 시스템이 동작하는 데 필요한 <strong>각종 설정 값을 동작 중인 모든 프로세스에서 공유하기 위해 프로퍼티라는 저장 공간을 사용</strong>한다.  </li><li>프로퍼티는 키(key)와 값(value)로 구성되며, ‘키 &#x3D; 값’ 형태로 사용된다.  </li><li>안드로이드에서는 이 값을 변경할 때는 권한을 확인하는 과정이 있다.  </li><li>모든 동작중인 프로세스는 프로퍼티의 값을 조회할 수 있다.  </li><li>프로퍼티 값을 <strong>변경하는 것은 init 프로세스만이 가능</strong>, 다른 프로세스는 변경 요청.  </li><li>프로퍼티의 값이 변경되면 init.rc에 정의된 특정 조건을 만족하는 경우 조건에 해당하는 동작 실행, **이를 트리거(trigger)**라 한다.</li></ul><h4 id="프로퍼티-초기화"><a href="#프로퍼티-초기화" class="headerlink" title="프로퍼티 초기화"></a>프로퍼티 초기화</h4><p>init 프로세스의 main() 함수 초기에 <strong>property_init() 함수</strong>를 통해서 프로퍼티 영역을 초기화한다.<br>property_init() 함수는 프로퍼티의 값을 저장하기 위한 공유 메모리를 생성하는데, 이를 위해 ashmem(Android Shared Memory)을 사용한다.<br><em>프로퍼티 값을 저장하거나 조회할때는 get(), set() 함수를 이용한다.</em>  </p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs scss">void <span class="hljs-built_in">property_init</span>(void)  <br>&#123;  <br>    <span class="hljs-built_in">init_property_area</span>(); <span class="hljs-comment">// 공유 메모리 영역 구성.  </span><br>    <span class="hljs-built_in">load_properties_from_file</span>(PROP_PATH_RAMDISK_DEFAULT); <span class="hljs-comment">// 파일로 부터 초기값을 읽어 프로퍼티 값을 설정.  </span><br>&#125;  <br></code></pre></td></tr></table></figure><p>init 프로세스는 start_property_service() 함수를 호출하여 프로퍼티 서비스를 시작한다.  </p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">property_set_fd</span> = start_property_service()<span class="hljs-comment">; // 프로퍼티 서비스 시작.  </span><br></code></pre></td></tr></table></figure><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-built_in">int</span> start<span class="hljs-constructor">_property_service(<span class="hljs-params">void</span>)</span>  <br>&#123;  <br>    <span class="hljs-built_in">int</span> fd;  <br>    load<span class="hljs-constructor">_properties_from_file(PROP_PATH_SYSTEM_BUILD)</span>; <span class="hljs-comment">// 프로퍼티의 기본값을 읽어 프로퍼티 값을 설정.  </span><br>    load<span class="hljs-constructor">_properties_from_file(PROP_PATH_SYSTEM_DEFAULT)</span>;  <br>    load<span class="hljs-constructor">_properties_from_file(PROP_PATH_LOCAL_OVERRIDE)</span>;  <br><br>    <span class="hljs-comment">/* Read persistent properties after all default values have been loaded. */</span>  <br>    load<span class="hljs-constructor">_persistent_properties()</span>; <span class="hljs-comment">// /data/property 디렉터리에 저장돼 있는 프로퍼티 값을 읽는다. (동작 중에 다른 프로세스에 의해 생성된 프로퍼티 값이나 변경된 값들)  </span><br>    fd = create<span class="hljs-constructor">_socket(PROP_SERVICE_NAME, SOCK_STREAM, 0666, 0, 0)</span>; <span class="hljs-comment">// property_service라는 이름의 도메인 소켓 생성.  </span><br>&#125;  <br></code></pre></td></tr></table></figure><h4 id="프로퍼티-변경-요청-처리"><a href="#프로퍼티-변경-요청-처리" class="headerlink" title="프로퍼티 변경 요청 처리"></a>프로퍼티 변경 요청 처리</h4><p>앞에서 생성한 소켓으로 프로퍼티 값의 변경 요청 메시지가 수신되면 <strong>handle_property_set_fd() 함수가 호출</strong>된다.  </p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">void handle<span class="hljs-constructor">_property_set_fd(<span class="hljs-params">int</span> <span class="hljs-params">fd</span>)</span>  <br>&#123;  <br>    <span class="hljs-comment">/* Check socket options here */</span>  <br>    <span class="hljs-keyword">if</span> (getsockopt(s, SOL_SOCKET, SO_PEERCRED, &amp;cr, &amp;cr_size) &lt; <span class="hljs-number">0</span>) &#123; <span class="hljs-comment">// 소켓으로 부터 값을 얻어온다.  </span><br>        close(s);  <br>        <span class="hljs-constructor">ERROR(<span class="hljs-string">&quot;Unable to recieve socket options\n&quot;</span>)</span>;  <br>        return;  <br>    &#125;  <br>    :  <br>    :  <br>    switch(msg.cmd) &#123;  <br>    case PROP_MSG_SETPROP:  <br>        <span class="hljs-keyword">if</span>(memcmp(msg.name,<span class="hljs-string">&quot;ctl.&quot;</span>,<span class="hljs-number">4</span>)<span class="hljs-operator"> == </span><span class="hljs-number">0</span>) &#123; <span class="hljs-comment">// &quot;ctl&quot;은 시스템 프로퍼티 값을 변경하는 것이 아니라, 프로세스의 시작, 종료를 요청하는 메시지.  </span><br>            <span class="hljs-keyword">if</span> (check<span class="hljs-constructor">_control_perms(<span class="hljs-params">msg</span>.<span class="hljs-params">value</span>, <span class="hljs-params">cr</span>.<span class="hljs-params">uid</span>, <span class="hljs-params">cr</span>.<span class="hljs-params">gid</span>)</span>) &#123; <span class="hljs-comment">// check_control_perms() 함수를 이용하여 접근 권한 검사. (system server, root, 해당 프로세스만 종료하거나 시작할 수 있음)  </span><br>                handle<span class="hljs-constructor">_control_message((<span class="hljs-params">char</span><span class="hljs-operator">*</span>)</span> msg.name + <span class="hljs-number">4</span>, (<span class="hljs-built_in">char</span>*) msg.value);  <br>            &#125; <span class="hljs-keyword">else</span> &#123;  <br>                <span class="hljs-constructor">ERROR(<span class="hljs-string">&quot;sys_prop: Unable to %s service ctl [%s] uid: %d pid:%d\n&quot;</span>, <span class="hljs-params">msg</span>.<span class="hljs-params">name</span> + 4, <span class="hljs-params">msg</span>.<span class="hljs-params">value</span>, <span class="hljs-params">cr</span>.<span class="hljs-params">uid</span>, <span class="hljs-params">cr</span>.<span class="hljs-params">pid</span>)</span>;  <br>            &#125;  <br>        &#125; <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">// 시스템의 프로퍼티를 변경하는 데 사용.  </span><br>            <span class="hljs-keyword">if</span> (check<span class="hljs-constructor">_perms(<span class="hljs-params">msg</span>.<span class="hljs-params">name</span>, <span class="hljs-params">cr</span>.<span class="hljs-params">uid</span>, <span class="hljs-params">cr</span>.<span class="hljs-params">gid</span>)</span>) &#123; <span class="hljs-comment">// 접근 권한은 check_perms() 함수를 호출하여 검사한다.  </span><br>                property<span class="hljs-constructor">_set((<span class="hljs-params">char</span><span class="hljs-operator">*</span>)</span> msg.name, (<span class="hljs-built_in">char</span>*) msg.value); <span class="hljs-comment">// 프로퍼티 값을 변경한다.  </span><br>            &#125;  <br>        &#125;  <br>    &#125;  <br>&#125;  <br></code></pre></td></tr></table></figure><p>프로퍼티 값을 변경하고, 문제가 없다면 <strong>property_changed() 함수가 호출</strong>된다.  </p>]]></content>
    
    
    <categories>
      
      <category>Android</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Android</tag>
      
      <tag>인사이드 안드로이드</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[인사이드 안드로이드] 챕터 3 - init 프로세스(1)</title>
    <link href="/chapter3/"/>
    <url>/chapter3/</url>
    
    <content type="html"><![CDATA[<h1 id="인사이드-안드로이드"><a href="#인사이드-안드로이드" class="headerlink" title="[인사이드 안드로이드]"></a>[인사이드 안드로이드]</h1><h2 id="Chapter3-init-프로세스-1"><a href="#Chapter3-init-프로세스-1" class="headerlink" title="Chapter3 - init 프로세스(1)"></a>Chapter3 - init 프로세스(1)</h2><h3 id="init-프로세스의-실행-과정"><a href="#init-프로세스의-실행-과정" class="headerlink" title="init 프로세스의 실행 과정"></a>init 프로세스의 실행 과정</h3><p>먼저 커널소스를 받기위해 깃을 사용했다.  </p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs awk">sudo apt-get install git  <br>git clone https:<span class="hljs-regexp">//</span>android.googlesource.com<span class="hljs-regexp">/kernel/</span>common.git kernel  <br>cd kernel  <br>git branch -r  <br></code></pre></td></tr></table></figure><p>위의 명령어로 브랜치 정보를 확인해서, 나는 3.18버전을 체크아웃 받았다.  </p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">git</span> checkout origin/android-<span class="hljs-number">3</span>.<span class="hljs-number">18</span>  <br></code></pre></td></tr></table></figure><h4 id="init-post-함수"><a href="#init-post-함수" class="headerlink" title="init_post()함수"></a>init_post()함수</h4><p>책에서는 init_post()함수에 대해서 설명했는데, 내가 3.18버전을 받아서 그런지 비슷한 코드의 함수명이 달랐다.<br>3.18에서는 __ref형을 반환하는 kernel_init() 함수.  </p><p><img src="/images/post/ch3.PNG" alt="Alt text" title="ch3">                                                </p><p>책과 다른 점이 있었는데, run_init_process의 리턴값을 받아서 false일 경우에 바로 종료시키는 구문이 추가되었다.<br>또한 &#x2F;sbin, &#x2F;etc, &#x2F;bin 디렉터리에서 init파일을 못찾았을 경우 커널 패닉이 일어날 경우에 대한 메시지가 있었다.<br>이 과정을 정상적으로 수행하면 init 프로세스를 실행한다.  </p><h3 id="init-프로세스의-소스-코드-분석"><a href="#init-프로세스의-소스-코드-분석" class="headerlink" title="init 프로세스의 소스 코드 분석"></a>init 프로세스의 소스 코드 분석</h3><p>main()에서 모든 프로세스의 부모인 init 프로세스는 자신이 생성한 프로세스가 종료됐을 때 발생하는 SIGCHLD 시그널을 처리할 핸들러를 등록한다.<br><em>리눅스의 프로세스들은 정보 교환으로 메시지를 주고 받는데 이를 시그널이라 하고, 처리하기 위한 루틴을 시그널 핸들러라고 한다.</em>  </p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs lisp">(<span class="hljs-name">sigaction</span> 구조체인 act에 값을 넣음.)  <br>sigaction(<span class="hljs-name">SIGCHLD</span>, <span class="hljs-symbol">&amp;act</span>, <span class="hljs-number">0</span>)<span class="hljs-comment">;  </span><br></code></pre></td></tr></table></figure><p>init 프로세스는 시그널 핸들러를 등록하고 부팅에 필요한 디렉터리를 생성하고 마운트한다.<br>이렇게 생성된 &#x2F;dev, &#x2F;proc, &#x2F;sys와 같은 디렉터리는 init 프로세스가 동작 중에 생성하고 시스템이 종료되면 다시 사라진다.  </p><p>디렉터리가 생성된 이후에 <strong>open_devnull_stdio()</strong> 함수를 통해 실행 로그를 출력하기 위한 장치를 생성한다. 입출력에 관련된 파일이 모두 <strong><strong>null</strong></strong> 장치로 변경되어 open_devnull_stdio() 함수를 수행한 init 프로세스는 표준 입출력을 통해 메시지를 출력할 수 없다. 해당 프로세스들은 <strong>log_init()</strong> 함수를 통해 로그 메시지를 출력하기 위한 새로운 출력 장치를 제공한다. log_init() 함수는 <strong><strong>kmsg</strong></strong> 디바이스 노드 파일을 생성한다. 이는 커널의 메시지 출력 함수인 printk() 함수를 사용하게 하고 이 장치를 통해 로그 메시지를 출력한다.  </p><p>안드로이드는 init.rc와 init.{hardware}.rc 파일을 이용해 실행 파일과 환경 변수를 정의한다.<br><strong>init.rc</strong> 파일은 안드로이드의 공통적인 환경설정 및 프로세스<br><strong>init.{hardware}.rc</strong> 파일은 플랫폼에 따라 특화된 프로세스나 환경 설정 등을 정의한다.<br>출력 장치를 생성한 이후 init.rc 파일을 파싱하게된다.<br>파싱한 후 서비스 리스트와 액션 리스트를 연결리스트 형태로 구성한다.  </p><p><strong>QEMU</strong>는 PC를 위한 오픈소스 에뮬레이터이다. init.rc을 파싱한 후 에뮬레이터 환경을 위해 QEMU 초기화를 한다.  </p><p>다음은 init.rc 파일을 분석했던 것 처럼 init.{hardware}.rc 파일을 파싱한다.<br>서비스 리스트와 액션리스트를 생성하여 init.rc 파일에서 생성했던 서비스 리스트와 액션리스트에 각각 추가된다.  </p><p>init 프로세스는 <strong>‘early-init, init, early-boot, boot’</strong> 섹션에 포함된 명령어들을 순서대로 실행한다.<br>action_for_each_trigger()함수를 이용해 early-init 섹션의 명령어들을 실행 큐인 action_add_queue_tail 큐에 저장하고 drain_action_queue()를 이용해 명령어를 실행한다.  </p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">action<span class="hljs-constructor">_for_each_trigger(<span class="hljs-string">&quot;early-init&quot;</span>, <span class="hljs-params">action_add_queue_tail</span>)</span>;  <br>drain<span class="hljs-constructor">_action_queue()</span>;  <br></code></pre></td></tr></table></figure><p>다음으로 init 프로세스는 <strong>device_init()</strong> 함수를 통해 정적 디바이스 노드를 생성하고 <strong>property_init()</strong> 함수를 통해 프로퍼티 서비스를 초기화 한다.<br><em>프로퍼티 영역은 모든 프로세스에서 시스템의 설정 값을 공유하기 위해 제공된다</em>  </p><p>다음 단계에서 안드로이드 부팅 로고를 출력한다.  </p><p><strong>property_set()</strong> 함수를 이용하여 앞서 생성한 프로퍼티 영역에 시스템 운용에 필요한 초기 값을 설정한다.<br>다음은 init 프로세스의 주요 기능 중 하나인 프로퍼티 서비스를 시작한다.  </p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">property_set_fd</span> = start_property_service()<span class="hljs-comment">;  </span><br></code></pre></td></tr></table></figure><p>init 프로세스는 자식 프로세스의 종료 처리를 위한 핸들러를 따로 정의했다.<br><strong>socketpair()</strong> 함수를 통해 서로 연결된 소켓 쌍 <strong>signal_fd, signal_recv_fd</strong>을 생성하고<br>signal_fd와 signal_recv_fd의 값을 1로 설정한다.<br>이벤트 처리 핸들러에서 signal_recv_fd의 값을 감시하다가 1로 설정되면서 자식 프로세스 종료 처리 핸들러를 호출한다.  </p><p>다음으로 <strong>early-boot, boot, property</strong> 섹션에 해당하는 명령어를 실행한다.</p><p>다음으로 이벤트 처리 루프에 들어가기 전 감시할 이벤트 설정을 한다.<br>poll()함수에서 이벤트를 기다리고 이벤트가 발생하면 poll() 함수를 빠져나와 이벤트를 처리한다.<br><strong>① 디바이스 노드 생성 ② 프로퍼티 서비스 요청 ③ SIGCHLD 시그널 처리</strong><br>이 세가지를 위한 파일 디스크립터를 등록하고, 아래와 같은 <strong>이벤트 처리 루프</strong>에서 poll() 함수의 인자로 넘겨져 이벤트를 감시한다.  </p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-keyword">for</span>(;;) &#123;  <br>    drain<span class="hljs-constructor">_action_queue()</span>;  <span class="hljs-comment">// 이벤트 처리 루프를 한번 수행 한 이후 액션 리스트, 서비스 리스트에서 실행되지 않은 명령들을 확인하고 실행.  </span><br>    restart<span class="hljs-constructor">_processes()</span>;  <span class="hljs-comment">// 자식 프로세스가 종료됐을 때 자식 프로세스 재시작 or 종료.  </span><br><br>    nr = poll(ufds, fd_count, timeout);  <span class="hljs-comment">// 등록한 파일 디스크립터에 발생한 이벤트를 기다린다. 이벤트가 발생하면 ufds에 이벤트 정보가 담김.  </span><br><br>     <span class="hljs-keyword">if</span> (ufds<span class="hljs-literal">[<span class="hljs-number">2</span>]</span>.revents<span class="hljs-operator"> == </span>POLLIN) &#123;  <span class="hljs-comment">//  자식 프로세스가 종료되어 SIGCHLD 시그널이 발생하면 POLLIN 이벤트 등록.  </span><br>         <span class="hljs-comment">/* we got a SIGCHLD - reap and restart as needed */</span>  <br>         read(signal_recv_fd, tmp, sizeof(tmp));  <br>         <span class="hljs-keyword">while</span> (!wait<span class="hljs-constructor">_for_one_process(0)</span>);  <br>         continue;  <br>     &#125;  <br><br>     <span class="hljs-keyword">if</span> (ufds<span class="hljs-literal">[<span class="hljs-number">0</span>]</span>.revents<span class="hljs-operator"> == </span>POLLIN)  <br>         handle<span class="hljs-constructor">_device_fd(<span class="hljs-params">device_fd</span>)</span>; <span class="hljs-comment">// 핫플러그 장치가 삽입됐을 때 디바이스 노드 파일 생성.  </span><br>     <span class="hljs-keyword">if</span> (ufds<span class="hljs-literal">[<span class="hljs-number">1</span>]</span>.revents<span class="hljs-operator"> == </span>POLLIN)  <br>         handle<span class="hljs-constructor">_property_set_fd(<span class="hljs-params">property_set_fd</span>)</span>;  <br>     <span class="hljs-keyword">if</span> (ufds<span class="hljs-literal">[<span class="hljs-number">3</span>]</span>.revents<span class="hljs-operator"> == </span>POLLIN)  <br>         handle<span class="hljs-constructor">_keychord(<span class="hljs-params">keychord_fd</span>)</span>;  <br> &#125;  <br></code></pre></td></tr></table></figure><h3 id="init-rc-파일-분석-및-실행"><a href="#init-rc-파일-분석-및-실행" class="headerlink" title="init.rc 파일 분석 및 실행"></a>init.rc 파일 분석 및 실행</h3><p>init.{hardware}.rc와 init.rc가 동일하게 처리하기 때문에 init.rc에 대해서만 분석한다.<br><strong>init 프로세스는 안드로이드를 빌드해야 생성되지만, init.rc 파일은 안드로이드 플랫폼의 소스코드에서 살펴볼 수 있다.</strong><br><strong>&#x2F;rootdir&#x2F;init.rc</strong>  </p><p>init.rc 파일의 내용은 크게 ‘on’ 키워드의 액션 리스트, ‘service’ 키워드의 서비스 리스트로 나뉜다.<br><strong>액션 리스트 &#x3D; 시스템 환경 변수, 부팅 시 필요한 디렉터리 생성, 퍼미션 지정</strong><br><strong>서비스 리스트 &#x3D; 부팅시 실행하는 프로세스 기술</strong>  </p><h4 id="액션-리스트"><a href="#액션-리스트" class="headerlink" title="액션 리스트"></a>액션 리스트</h4><p>액션 리스트는 <strong>‘on init’</strong> 섹션에서 환경변수를 등록하고, 디렉터리 생성 및 마운트한다.<br>안드로이드의 루트 파일 시스템 구조는 크게 <strong>shell 유틸리티</strong>, 라이브러리, 기본 애플리케이션을 제공하는 <strong>system 디렉터리</strong>, 개발자가 탑재한 사용자 애들리케이션이나 사용자 데이터를 저장하는 <strong>data 디렉터리로</strong> 나뉜다.<br>마운트 부분에서는 &#x2F;system과 &#x2F;data 디렉터리를 마운트한다.  </p><p><strong>‘on boot’</strong> 섹션에서는 애플리케이션 종료 조건 설정, 애플리케이션 구동에 필요한 디렉터리 및 파일 퍼미션 설정 등을 한다.<br>애플리케이션 종료 조건 설정부분에서 애플리케이션 별 <strong>OOM(Out Of Memory)</strong> 조정 값(Adjustment Value)을 지정한다.<br>OOM은 커널 상에서 메모리를 모니터링하면서 메모리가 부족할 때 애플리케이션을 종료시키는 역할을 한다.<br><em>ADJ값이 높을수록 종료 우선순위가 높다.</em>  </p><p><strong>‘on property’</strong> 섹션에서는 프로퍼티 값이 변경될 경우 실행되는 명령이 기술돼 있다.</p><h4 id="서비스-리스트"><a href="#서비스-리스트" class="headerlink" title="서비스 리스트"></a>서비스 리스트</h4><p>**’service’**섹션은 앞서 말한듯이 init 프로세스가 실행시키는 프로세스를 기술한다.<br><em>해당 프로세스에는 부팅음을 출력하는 일회성 프로그램 또는 백그라운드의 애플리케이션이나 시스템 운용에 관여하는 데몬 프로세스가 있다.</em>  </p><p>‘service’ 섹션의 프로세스는 모드 서비스 리스트에 등록되며, init 프로세스가 실행되면서 서비스 리스트에 등록된 프로세스를 순차적으로 실행한다.  </p><h4 id="init-rc-파싱-코드-분석"><a href="#init-rc-파싱-코드-분석" class="headerlink" title="init.rc 파싱 코드 분석"></a>init.rc 파싱 코드 분석</h4><p>parse_config_file() 함수는 인자로 전달되는 파일을 읽고(read_file()), 각 문자열을 파싱한다.(parse_config())<br><em>&#x2F;init&#x2F;parser.c 파일의 parse_config_file() 함수</em>  </p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-built_in">int</span> parse<span class="hljs-constructor">_config_file(<span class="hljs-params">const</span> <span class="hljs-params">char</span> <span class="hljs-operator">*</span><span class="hljs-params">fn</span>)</span>  <br>&#123;  <br>    <span class="hljs-built_in">char</span> *data;  <br>    data = read<span class="hljs-constructor">_file(<span class="hljs-params">fn</span>, 0)</span>;  <span class="hljs-comment">// 파일을 읽고  </span><br>    <span class="hljs-keyword">if</span> (!data) return -<span class="hljs-number">1</span>;  <br>    parse<span class="hljs-constructor">_config(<span class="hljs-params">fn</span>, <span class="hljs-params">data</span>)</span>;  <span class="hljs-comment">// 문자열 파싱  </span><br>    <span class="hljs-constructor">DUMP()</span>;  <br>    return <span class="hljs-number">0</span>;  <br>&#125;  <br></code></pre></td></tr></table></figure><p><strong>parse_config()</strong> 함수는 아래 코드와 같이 인자로 전달된 파일의 끝까지 각 라인을 파싱한다.<br><strong>next_token()</strong> 함수로 문자열을 라인 단위로 나눈 후 <strong>lookup_keyword()</strong> 함수를 호출한다.<br>lookup_keyword() 함수는 init.rc 파일의 각 라인에서 첫 단어에 해당하는 <strong>keyword_list 구조체 배열</strong>에서 번호를 반환한다.<br>이후에 배열 내 flag가 SECTION인지 판단하는데, SECTION flag는 “on”, “service” 키워드만 존재하기 때문에 서비스 리스트만 <strong>parse_new_section()</strong> 함수를 수행한다.<br>parse_new_section() 함수를 수행하고 나면 액션 리스트와 서비스 리스트가 완성된다.  </p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">static void parse<span class="hljs-constructor">_config(<span class="hljs-params">const</span> <span class="hljs-params">char</span> <span class="hljs-operator">*</span><span class="hljs-params">fn</span>, <span class="hljs-params">char</span> <span class="hljs-operator">*</span><span class="hljs-params">s</span>)</span>  <br>&#123;  <br>    <span class="hljs-keyword">for</span> (;;) &#123;  <br>        switch (next<span class="hljs-constructor">_token(&amp;<span class="hljs-params">state</span>)</span>) &#123; <span class="hljs-comment">// 문자열을 라인 단위로 나눈다.  </span><br>        case T_NEWLINE:  <br>            <span class="hljs-keyword">if</span> (nargs) &#123;  <br>                <span class="hljs-built_in">int</span> kw = lookup<span class="hljs-constructor">_keyword(<span class="hljs-params">args</span>[0])</span>; <span class="hljs-comment">// 구조체 배열에서 번호를 반환한다.  </span><br>                <span class="hljs-keyword">if</span> (kw<span class="hljs-constructor">_is(<span class="hljs-params">kw</span>, SECTION)</span>) &#123; <span class="hljs-comment">// flag가 SECTION인지 확인한다.  </span><br>                    state.parse<span class="hljs-constructor">_line(&amp;<span class="hljs-params">state</span>, 0, 0)</span>; <span class="hljs-comment">// 서비스 리스트만  </span><br>                    parse<span class="hljs-constructor">_new_section(&amp;<span class="hljs-params">state</span>, <span class="hljs-params">kw</span>, <span class="hljs-params">nargs</span>, <span class="hljs-params">args</span>)</span>; <span class="hljs-comment">// parse_new_section() 함수를 수행한다.  </span><br>                &#125;  <br>            &#125;  <br>        &#125;  <br>    &#125;  <br>&#125;  <br></code></pre></td></tr></table></figure><p>각 리스트는 <strong>KEYWORD 매크로</strong>를 사용해 생성된다.<br>KEYWORD 매크로는 parse.c와 keyword.h에 정의돼 있다.<br><strong>parse.c에 정의된 KEYWORD 매크로 &#x3D; KEYWORD 리스트를 keyword_list 구조체 배열로 변환</strong><br><strong>keyword.h에 정의된 KEYWORD 매크로 &#x3D; KEYWORD 리스트들을 1번부터 순서대로 번호 할당</strong>  </p><p><em>parse.c에 정의된 KEYWORD 매크로</em><br>COMMAND 그룹은 init 프로세스가 실행하는 명령어들을 의미, 해당 명령어의 실행 함수와 매핑.<br>SECTION 그룹은 액션 리스트, 서비스 리스트를 구분.<br>OPTION 그룹은 명령어, 프로세스를 실행할 때 실행 조건을 부여.<br>KEYWORD 리스트들은 KEYWORD 매크로를 통해 keyword_info 구조체 배열의 리스트로 변경.  </p><p><em>keyword.h에 정의된 KEYWORD 매크로</em><br>“K_키워드” 심볼로 정의된 열거형 데이터로 변환되어 1부터 차례대로 번호가 부여된다.  </p><h3 id="액션-리스트-및-서비스-리스트의-실행"><a href="#액션-리스트-및-서비스-리스트의-실행" class="headerlink" title="액션 리스트 및 서비스 리스트의 실행"></a>액션 리스트 및 서비스 리스트의 실행</h3><h4 id="액션-리스트-1"><a href="#액션-리스트-1" class="headerlink" title="액션 리스트"></a>액션 리스트</h4><p>액션 리스트 내의 명령어가 실행되는 과정을 먼저 살펴본다.<br>action_remove_queue_head() 함수를 통해서 전역으로 선언된 액션 리스트 헤더를 얻어온다.<br>액션 리스트를 command 구조체로 변환하고, 각 명령어에 매핑된 함수를 가져온다.  </p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">void drain<span class="hljs-constructor">_action_queue(<span class="hljs-params">void</span>)</span>  <br>&#123;  <br>    <span class="hljs-keyword">struct</span> listnode *node;  <br>    <span class="hljs-keyword">struct</span> command *cmd;  <br>    <span class="hljs-keyword">struct</span> action *act;  <br>    <span class="hljs-built_in">int</span> ret;  <br><br>    <span class="hljs-keyword">while</span> ((act = action<span class="hljs-constructor">_remove_queue_head()</span>)) &#123; <span class="hljs-comment">// action_queue 연결리스트 헤더를 얻어온다.  </span><br>        <span class="hljs-constructor">INFO(<span class="hljs-string">&quot;processing action %p (%s)\n&quot;</span>, <span class="hljs-params">act</span>, <span class="hljs-params">act</span>-&gt;<span class="hljs-params">name</span>)</span>;  <br>        <span class="hljs-built_in">list</span><span class="hljs-constructor">_for_each(<span class="hljs-params">node</span>, &amp;<span class="hljs-params">act</span>-&gt;<span class="hljs-params">commands</span>)</span> &#123;  <br>            cmd = node<span class="hljs-constructor">_to_item(<span class="hljs-params">node</span>, <span class="hljs-params">struct</span> <span class="hljs-params">command</span>, <span class="hljs-params">clist</span>)</span>; <span class="hljs-comment">// 리스트를 command 구초체로 변환한다.  </span><br>            ret = cmd-&gt;func(cmd-&gt;nargs, cmd-&gt;args); <span class="hljs-comment">// 각 명령어에 매핑된 함수  </span><br>            <span class="hljs-constructor">INFO(<span class="hljs-string">&quot;command &#x27;%s&#x27; r=%d\n&quot;</span>, <span class="hljs-params">cmd</span>-&gt;<span class="hljs-params">args</span>[0], <span class="hljs-params">ret</span>)</span>;  <br>        &#125;  <br>    &#125;  <br>&#125;  <br></code></pre></td></tr></table></figure><h4 id="서비스-리스트-1"><a href="#서비스-리스트-1" class="headerlink" title="서비스 리스트"></a>서비스 리스트</h4><p>‘on boot’ 섹선의 마지막 명령어인 class_start 명령어를 통해 service 섹션의 모든 프로세스를 실행하게 된다.</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">service<span class="hljs-constructor">_for_each_class(<span class="hljs-params">args</span>[1], <span class="hljs-params">service_start_if_not_disabled</span>)</span>;  <br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Android</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Android</tag>
      
      <tag>인사이드 안드로이드</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[인사이드 안드로이드] 챕터 2 - 안드로이드 개발 환경 구축</title>
    <link href="/chapter2/"/>
    <url>/chapter2/</url>
    
    <content type="html"><![CDATA[<h1 id="인사이드-안드로이드"><a href="#인사이드-안드로이드" class="headerlink" title="[인사이드 안드로이드]"></a>[인사이드 안드로이드]</h1><h2 id="Chapter2-안드로이드-개발-환경-구축"><a href="#Chapter2-안드로이드-개발-환경-구축" class="headerlink" title="Chapter2 - 안드로이드 개발 환경 구축"></a>Chapter2 - 안드로이드 개발 환경 구축</h2><h3 id="호스트-환경-구성"><a href="#호스트-환경-구성" class="headerlink" title="호스트 환경 구성"></a>호스트 환경 구성</h3><p>우분투 리눅스 상에서 안드로이드 플랫폼을 빌드하고 프레임워크를 디버깅하려면 우분투 개발활경을 구축해야한다.</p><p><em>우분투 버전이 책과 달라 환경구성은 아래 블로그를 참고했습니다.</em><br><em><a href="http://bitly.kr/7YftX">http://bitly.kr/7YftX</a></em></p><h4 id="설치과정"><a href="#설치과정" class="headerlink" title="설치과정"></a>설치과정</h4><ul><li>Ubuntu 14.04.6 LTS를 VirtualBox를 이용하여 설치한다.<br><em>추후에 필요하면 가상머신이 아닌 멀티부팅을 이용해 재설치할 예정.</em></li></ul><p><img src="/images/post/install1.PNG" alt="Alt text" title="설치1"></p><p><img src="/images/post/install2.PNG" alt="Alt text" title="설치2"></p><ul><li>필요 패키지를 설치하고, Repo 설치 및 안드로이드 소스코드를 다운로드 한다. 책에 있는것과 마찬가지로 froyo버전을 받았다.</li></ul><p><img src="/images/post/install3.PNG" alt="Alt text" title="설치3"></p><ul><li>안드로이드 플랫폼 빌드 확인을 위해 안드로이드 플랫폼 소스의 최상위 폴더에서 make명령어를 실행했다. 하지만 다음과 같은 에러가 발생하였다.</li></ul><p><img src="/images/post/error1.PNG" alt="Alt text" title="에러1"></p><p>해당 에러는 build system에서 “jar” command를 찾을 수 없어서 발생한다.<br>터미널에서 <em>which jar</em>을 입력하면 아무것도 뜨지않는데, 다음과 같이 해결하였다.  </p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">sudo update-alternatives --install <span class="hljs-regexp">/usr/</span>bin<span class="hljs-regexp">/jar jar /u</span>sr<span class="hljs-regexp">/lib/</span>jvm<span class="hljs-regexp">/jdk1.5.0_22/</span>bin/jar <span class="hljs-number">1</span> (자신의 jdk 경로)<br></code></pre></td></tr></table></figure><p><img src="/images/post/error2.PNG" alt="Alt text" title="에러2"></p><p><strong>이후로도 빌드 오류가 일어났는데, 발생한 오류 -&gt; 해결방법 순이다.</strong></p><p><img src="/images/post/error3.PNG" alt="Alt text" title="에러3"></p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs awk">frameworks<span class="hljs-regexp">/base/</span>tools<span class="hljs-regexp">/aapt/</span>Android.mk 파일의 <span class="hljs-number">31</span>번째 줄에 -fpermissive 추가  <br>LOCAL_CFLAGS += -Wno-format-y2k -fpermissive<br></code></pre></td></tr></table></figure><p><img src="/images/post/error4.PNG" alt="Alt text" title="에러4"></p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs awk">frameworks<span class="hljs-regexp">/base/</span>libs<span class="hljs-regexp">/utils/</span>Android.mk 파일의 <span class="hljs-number">64</span>번째 줄에 -fpermissive 추가  <br>LOCAL_CFLAGS += -DLIBUTILS_NATIVE=<span class="hljs-number">1</span> $(TOOL_CFLAGS) -fpermissive<br></code></pre></td></tr></table></figure><p><strong>-fpermissive 옵션은 부적합한 코드를 컴파일할 수 있도록 해주는 옵션이다.</strong></p><p><img src="/images/post/error5.PNG" alt="Alt text" title="에러5"></p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs powershell"><span class="hljs-built_in">cd</span> external/srec  <br><span class="hljs-built_in">wget</span> <span class="hljs-string">&quot;https://github.com/CyanogenMod/android_external_srec/commit/4d7ae7b79eda47e489669fbbe1f91ec501d42fb2.diff&quot;</span>  <br>patch <span class="hljs-literal">-p1</span> &lt; <span class="hljs-number">4</span>d7ae7b79eda47e489669fbbe1f91ec501d42fb2.diff  <br><span class="hljs-built_in">rm</span> <span class="hljs-operator">-f</span> <span class="hljs-number">4</span>d7ae7b79eda47e489669fbbe1f91ec501d42fb2.diff  <br></code></pre></td></tr></table></figure><p><img src="/images/post/error6.PNG" alt="Alt text" title="에러6"></p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs awk">sudo apt-get install gcc-<span class="hljs-number">4.4</span>  <br>sudo apt-get install g++-<span class="hljs-number">4.4</span>  <br><br>sudo rm -f <span class="hljs-regexp">/usr/</span>bin/gcc  <br>sudo rm -f <span class="hljs-regexp">/usr/</span>bin/g++  <br>sudo ln -s <span class="hljs-regexp">/usr/</span>bin<span class="hljs-regexp">/gcc-4.4 /u</span>sr<span class="hljs-regexp">/bin/g</span>cc  <br>sudo ln -s <span class="hljs-regexp">/usr/</span>bin<span class="hljs-regexp">/g++-4.4 /u</span>sr<span class="hljs-regexp">/bin/g</span>++  <br><br>sudo apt-get install g++-<span class="hljs-number">4.4</span>-multilib  <br></code></pre></td></tr></table></figure><p><img src="/images/post/error7.PNG" alt="Alt text" title="에러7"></p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">sudo apt-<span class="hljs-built_in">get</span> install libswitch-perl<br></code></pre></td></tr></table></figure><p><strong>위의 오류들을 수정하고 빌드에 성공했다.</strong></p><p><img src="/images/post/build.PNG" alt="Alt text" title="빌드완료"></p><ul><li>SDK 개발 환경 구축<br>책에서는 이클립스를 설치했지만, 나는 안드로이드 스튜디오를 설치했는데… ‘.classpath’파일이 없다…<br>안드로이드 스튜디오는 프레임워크 디버깅이 안된다??</li></ul>]]></content>
    
    
    <categories>
      
      <category>Android</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Android</tag>
      
      <tag>인사이드 안드로이드</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[인사이드 안드로이드] 챕터 1 - 프레임워크 개요</title>
    <link href="/chapter1/"/>
    <url>/chapter1/</url>
    
    <content type="html"><![CDATA[<h1 id="인사이드-안드로이드"><a href="#인사이드-안드로이드" class="headerlink" title="[인사이드 안드로이드]"></a>[인사이드 안드로이드]</h1><h2 id="Chapter1-프레임워크-개요"><a href="#Chapter1-프레임워크-개요" class="headerlink" title="Chapter1 - 프레임워크 개요"></a>Chapter1 - 프레임워크 개요</h2><h3 id="서론"><a href="#서론" class="headerlink" title="서론"></a>서론</h3><p>나는 컴퓨터공학과 종합설계 주제 중 ‘안드로이드 프레임워크 개선’을 선택했다. 물론 지금까지 프레임워크를 접한 적은 없다. 지금까지 ‘모바일소프트웨어설계’수업과 간단한 안드로이드 어플리케이션을 제작 해본 게 전부이다. 하지만 안드로이드를 접하면서 흥미를 느꼈고, 모바일 고급 개발자로 나아가고 싶었다. 그러기 위해서 프레임워크의 동작 원리를 이해하고, 분석하여 안드로이드의 프레임워크를 좀 더 개선하면 좋을 것 같다. 앞으로 GitHub 블로그와 ‘인사이드 안드로이드’책을 통해 공부하기로 한다.</p><p><em>이 책이 2010년 출간이라, 버전이 Cupcake, Froyo가 발표될 즈음 이라는데 크게 상관없는지는 잘 모르겠다.</em></p><h4 id="안드로이드-프레임워크-개요"><a href="#안드로이드-프레임워크-개요" class="headerlink" title="안드로이드 프레임워크 개요"></a>안드로이드 프레임워크 개요</h4><p>안드로이드 개발자 가이드 사이트에 따르면 안드로이드를 운영체제와 미들웨어, 그리고 핵심 애플리케이션을 포함한 모바일 디바이스 개발에 적합한 <strong>소프트웨어 스택</strong> 이라 정의한다. 즉, 안드로이드는 모바일 디바이스용 애플리케이션을 쉽게 제작하기 위한 <strong>소프트웨어 프레임워크</strong> 를 제공해 준다.</p><p>다음 그림은 안드로이드 플랫폼의 구조이다.</p><p><img src="/images/post/framework.png" alt="안드로이드 내부 구조" title="안드로이드 내부 구조"></p><ul><li>내부 구조는 크게 애플리케이션 프레임워크, 라이브러리, 안드로이드 런타임, 리눅스 커널로 구성되어있다.</li><li>애플리케이션은 애플리케이션 프레임워크 레이어 위에서 동작한다.</li><li>안드로이드 플랫폼 개발자가 되기 위해서는 프레임워크에 대한 심도 있는 이해가 필수다.</li></ul><h4 id="안드로이드의-소스-코드-구조"><a href="#안드로이드의-소스-코드-구조" class="headerlink" title="안드로이드의 소스 코드 구조"></a>안드로이드의 소스 코드 구조</h4><p>주요 소스 코드의 구성은 다음과 같다.</p><ul><li>Kernel : 안드로이드의 리눅스 커널</li><li>bionic : 안들이드 표준 C라이브러리</li><li>bootloader : 참고용 안드로이드 부트로더</li><li>build : 안드로이드 빌드 시스템</li><li>cts : 안드로이드 호환성 테스트 관련 소스</li><li>dalvik : 달빅 가상 머신</li><li>external : 안드로이드에서 사용하는 오픈소스들</li><li>frameworks : <strong>안드로이드 프레임워크</strong></li><li>hardware : 안드로이드 HAL(Hardware Abstraction Layer) 소스</li><li>packages : 안드로이드 기본 애플리케이션, 컨텐트 프로바이더 등</li><li>system : 안드로이드 init 프로세스, 블루투스 도구 모음 등</li></ul><h4 id="안드로이드의-부팅-과정"><a href="#안드로이드의-부팅-과정" class="headerlink" title="안드로이드의 부팅 과정"></a>안드로이드의 부팅 과정</h4><ol><li><strong>bootloader</strong> 를 통해 리눅스 <strong>Kernel</strong> 이 먼저 시작된다. Kernel 초기화를 수행한 후 마지막 과정에서 init 프로세스를 호출한다.</li><li><strong>init 프로세스</strong> 는 각종 데몬, 컨텍스트 매니저, 미디어 서버, Zygote등을 실행한다.</li><li><strong>컨텍스트 매니저</strong> 는 안드로이드의 시스템 서비스를 관리하는 프로세스로, 프레임워크를 구성하는 중요한 컴포넌트이다. 안드로이드 내에서 동작하는 각종 시스템 서비스에 대한 정보는 컨텍스트 매니저에게서 얻을 수 있다.</li><li><strong>미디어 서버</strong> 는 안드로이드에서 오디오와 카메라같은 C&#x2F;C++ 네이티브 시스템 서비스를 실행하는 역할을 한다.</li><li><strong>Zygote</strong> 는 application을 빠르게 구동하기 위해서 미리 fork 되어 있는 process다. 애플리케이션의 시작 시간을 단축시키며 메모리 공유를 최적화 할 수 있다.</li><li><strong>시스템서버</strong> 는 Zygote에서 최초로 fork되어 실행되는 프로세스다. 시스템 서버는 애플리케이션 생명 주기를 제어하는 액티비티 매니저 서비스나 단말기의 위치 정보를 제공하는 로케이션 매니저 서비스와 같은 자바 시스템 서비스를 실행하는 역할을 한다.</li><li>모든 자바 시스템 서비스가 로딩되고나면 액티비티 매니저 서비스가 HOME 애플리케이션을 실행하며 부팅 과정이 진행된다.</li></ol><ul><li>자바 시스템 서비스를 C언어 기반의 서비스 매니저에 등록하려면 자바와 C언어 간의 인터페이스 역할을 하는 JNI(Java Native Interface)를 추가로 이용해야 한다!</li></ul>]]></content>
    
    
    <categories>
      
      <category>Android</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Android</tag>
      
      <tag>인사이드 안드로이드</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
