<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>체크박스 디자인-2 (checkbox Design-2 with CSS)</title>
    <link href="/uiux6/"/>
    <url>/uiux6/</url>
    
    <content type="html"><![CDATA[<h1 id="체크박스-디자인-2-checkbox-Design-2-with-CSS"><a href="#체크박스-디자인-2-checkbox-Design-2-with-CSS" class="headerlink" title="체크박스 디자인-2 (checkbox Design-2 with CSS)"></a>체크박스 디자인-2 (checkbox Design-2 with CSS)</h1><p>기본 체크박스로 활용할 수 있다.  </p><iframe src="https://rudtn082.github.io/UI/checkbox2/checkbox2.html" width="900" height="160" style="margin: 15px auto; display: block;"></iframe><p>✔️ HTML  </p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs angelscript">&lt;div <span class="hljs-keyword">class</span>=&quot;<span class="hljs-symbol">cbxBox</span>&quot;&gt;<br>    &lt;<span class="hljs-symbol">label</span> <span class="hljs-symbol">class</span>=&quot;<span class="hljs-symbol">box</span>&quot;&gt;<br>        &lt;<span class="hljs-symbol">input</span> <span class="hljs-symbol">type</span>=&quot;<span class="hljs-symbol">checkbox</span>&quot; <span class="hljs-symbol">checked</span>=&quot;&quot;&gt;<br>        &lt;<span class="hljs-symbol">span</span>&gt;&lt;/<span class="hljs-symbol">span</span>&gt;<br>    &lt;/<span class="hljs-symbol">label</span>&gt;<br>&lt;/<span class="hljs-symbol">div</span>&gt;<br></code></pre></td></tr></table></figure><p>✔️ CSS  </p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.cbxBox</span> &#123;<br>    <span class="hljs-attribute">position</span>: relative;<br>    <span class="hljs-attribute">left</span>: <span class="hljs-number">50%</span>;<br>&#125;<br><span class="hljs-selector-class">.box</span> &#123;<br>    <span class="hljs-attribute">display</span>: flex;<br>    <span class="hljs-attribute">align-items</span>: center;<br>&#125;<br><span class="hljs-selector-class">.box</span> <span class="hljs-selector-tag">input</span><span class="hljs-selector-attr">[type=<span class="hljs-string">&quot;checkbox&quot;</span>]</span> &#123;<br>    <span class="hljs-attribute">position</span>: relative;<br>    <span class="hljs-attribute">height</span>: <span class="hljs-number">35px</span>;<br>    <span class="hljs-attribute">width</span>: <span class="hljs-number">35px</span>;<br>    appearance: none;<br>    <span class="hljs-attribute">background-color</span>: <span class="hljs-number">#FFF</span>;<br>    <span class="hljs-attribute">border-radius</span>: <span class="hljs-number">10px</span>;<br>    <span class="hljs-attribute">cursor</span>: pointer;<br>    <span class="hljs-attribute">overflow</span>: hidden;<br>&#125;<br><span class="hljs-selector-class">.box</span> <span class="hljs-selector-tag">input</span><span class="hljs-selector-attr">[type=<span class="hljs-string">&quot;checkbox&quot;</span>]</span><span class="hljs-selector-pseudo">::after</span> &#123;<br>    <span class="hljs-attribute">content</span>: <span class="hljs-string">&#x27;&#x27;</span>;<br>    <span class="hljs-attribute">display</span>: block;<br>    <span class="hljs-attribute">height</span>: <span class="hljs-number">15px</span>;<br>    <span class="hljs-attribute">width</span>: <span class="hljs-number">8px</span>;<br>    <span class="hljs-attribute">border-bottom</span>: <span class="hljs-number">4px</span> solid <span class="hljs-number">#e1f5fe</span>;<br>    <span class="hljs-attribute">border-right</span>: <span class="hljs-number">4px</span> solid <span class="hljs-number">#e1f5fe</span>;<br>    <span class="hljs-attribute">opacity</span>: <span class="hljs-number">0</span>;<br>    <span class="hljs-attribute">transform</span>: <span class="hljs-built_in">rotate</span>(<span class="hljs-number">45deg</span>) <span class="hljs-built_in">translate</span>(-<span class="hljs-number">50%</span>, -<span class="hljs-number">50%</span>);<br>    <span class="hljs-attribute">position</span>: absolute;<br>    <span class="hljs-attribute">top</span>: <span class="hljs-number">45%</span>;<br>    <span class="hljs-attribute">left</span>: <span class="hljs-number">25%</span>;<br>    <span class="hljs-attribute">transition</span>: all .<span class="hljs-number">25s</span> <span class="hljs-built_in">cubic-bezier</span>(<span class="hljs-number">0.075</span>, <span class="hljs-number">0.82</span>, <span class="hljs-number">0.165</span>, <span class="hljs-number">1</span>);<br>&#125;<br><span class="hljs-selector-class">.box</span> <span class="hljs-selector-tag">input</span><span class="hljs-selector-attr">[type=<span class="hljs-string">&quot;checkbox&quot;</span>]</span><span class="hljs-selector-pseudo">::before</span> &#123;<br>    <span class="hljs-attribute">position</span>: absolute;<br>    <span class="hljs-attribute">display</span>: block;<br>    <span class="hljs-attribute">content</span>: <span class="hljs-string">&#x27;&#x27;</span>;<br>    <span class="hljs-attribute">height</span>: <span class="hljs-number">0</span>;<br>    <span class="hljs-attribute">width</span>: <span class="hljs-number">0</span>;<br>    <span class="hljs-attribute">background-color</span>: <span class="hljs-number">#01579b</span>;<br>    <span class="hljs-attribute">border-radius</span>: <span class="hljs-number">50%</span>;<br>    <span class="hljs-attribute">opacity</span>: .<span class="hljs-number">5</span>;<br>    <span class="hljs-attribute">transform</span>: <span class="hljs-built_in">translate</span>(-<span class="hljs-number">50%</span>, -<span class="hljs-number">50%</span>);<br>    <span class="hljs-attribute">top</span>: <span class="hljs-number">50%</span>;<br>    <span class="hljs-attribute">left</span>: <span class="hljs-number">50%</span>;<br>    <span class="hljs-attribute">transition</span>: all .<span class="hljs-number">5s</span> <span class="hljs-built_in">cubic-bezier</span>(<span class="hljs-number">0.075</span>, <span class="hljs-number">0.82</span>, <span class="hljs-number">0.165</span>, <span class="hljs-number">1</span>);<br>&#125;<br><span class="hljs-selector-class">.box</span> <span class="hljs-selector-tag">input</span><span class="hljs-selector-attr">[type=<span class="hljs-string">&quot;checkbox&quot;</span>]</span><span class="hljs-selector-pseudo">:checked</span><span class="hljs-selector-pseudo">::before</span> &#123;<br>    <span class="hljs-attribute">height</span>: <span class="hljs-number">120%</span>;<br>    <span class="hljs-attribute">width</span>: <span class="hljs-number">120%</span>;<br>    <span class="hljs-attribute">opacity</span>: <span class="hljs-number">100%</span>;<br>&#125;<br><span class="hljs-selector-class">.box</span> <span class="hljs-selector-tag">input</span><span class="hljs-selector-attr">[type=<span class="hljs-string">&quot;checkbox&quot;</span>]</span><span class="hljs-selector-pseudo">:checked</span><span class="hljs-selector-pseudo">::after</span> &#123;<br>    <span class="hljs-attribute">opacity</span>: <span class="hljs-number">100%</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>✔️ GitHub<br><a href="https://github.com/rudtn082/UI/tree/main/checkbox2" title="GitHub">링크</a>  </p>]]></content>
    
    
    <categories>
      
      <category>UI_UX</category>
      
    </categories>
    
    
    <tags>
      
      <tag>디자인</tag>
      
      <tag>CSS</tag>
      
      <tag>체크박스</tag>
      
      <tag>checkbox</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>체크박스 디자인-1 (checkbox Design-1 with CSS)</title>
    <link href="/uiux5/"/>
    <url>/uiux5/</url>
    
    <content type="html"><![CDATA[<h1 id="체크박스-디자인-1-checkbox-Design-1-with-CSS"><a href="#체크박스-디자인-1-checkbox-Design-1-with-CSS" class="headerlink" title="체크박스 디자인-1 (checkbox Design-1 with CSS)"></a>체크박스 디자인-1 (checkbox Design-1 with CSS)</h1><p>기본 체크박스로 활용할 수 있다.   </p><iframe src="https://rudtn082.github.io/UI/checkbox1/checkbox1.html" width="900" height="160" style="margin: 15px auto; display: block;"></iframe><p>✔️ HTML  </p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs angelscript">&lt;div <span class="hljs-keyword">class</span>=&quot;<span class="hljs-symbol">cbxBox</span>&quot;&gt;<br>    &lt;<span class="hljs-symbol">input</span> <span class="hljs-symbol">checked</span>=&quot;&quot; <span class="hljs-symbol">type</span>=&quot;<span class="hljs-symbol">checkbox</span>&quot; <span class="hljs-symbol">id</span>=&quot;<span class="hljs-symbol">cb1</span>&quot;&gt;<br>    &lt;<span class="hljs-symbol">label</span> <span class="hljs-symbol">for</span>=&quot;<span class="hljs-symbol">cb1</span>&quot; <span class="hljs-symbol">class</span>=&quot;<span class="hljs-symbol">cbx</span>&quot;&gt;&lt;/<span class="hljs-symbol">label</span>&gt;<br>&lt;/<span class="hljs-symbol">div</span>&gt;<br></code></pre></td></tr></table></figure><p>✔️ CSS  </p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.cbxBox</span> &#123;<br>    <span class="hljs-attribute">position</span>: relative;<br>&#125;<br><span class="hljs-selector-class">.cbxBox</span> <span class="hljs-selector-class">.cbx</span> &#123;<br>    <span class="hljs-attribute">position</span>: relative;<br>    <span class="hljs-attribute">display</span>: block;<br>    <span class="hljs-attribute">width</span>: <span class="hljs-number">25px</span>;<br>    <span class="hljs-attribute">height</span>: <span class="hljs-number">25px</span>;<br>    <span class="hljs-attribute">border</span>: <span class="hljs-number">1px</span> solid <span class="hljs-number">#a1a1a1</span>;<br>    <span class="hljs-attribute">border-radius</span>: <span class="hljs-number">5px</span>;<br>    <span class="hljs-attribute">cursor</span>: pointer;<br>    <span class="hljs-attribute">transition</span>: all <span class="hljs-number">0.3s</span> ease;<br>&#125;<br><span class="hljs-selector-class">.cbxBox</span> <span class="hljs-selector-class">.cbx</span><span class="hljs-selector-pseudo">:after</span> &#123;<br>    <span class="hljs-attribute">content</span>: <span class="hljs-string">&#x27;&#x27;</span>;<br>    <span class="hljs-attribute">position</span>: absolute;<br>    <span class="hljs-attribute">top</span>: <span class="hljs-number">2px</span>;<br>    <span class="hljs-attribute">left</span>: <span class="hljs-number">10px</span>;<br>    <span class="hljs-attribute">width</span>: <span class="hljs-number">5px</span>;<br>    <span class="hljs-attribute">height</span>: <span class="hljs-number">14px</span>;<br>    <span class="hljs-attribute">opacity</span>: <span class="hljs-number">0</span>;<br>    <span class="hljs-attribute">transform</span>: <span class="hljs-built_in">rotate</span>(<span class="hljs-number">45deg</span>) <span class="hljs-built_in">scale</span>(<span class="hljs-number">0</span>);<br>    <span class="hljs-attribute">border-right</span>: <span class="hljs-number">2px</span> solid <span class="hljs-number">#fff</span>;<br>    <span class="hljs-attribute">border-bottom</span>: <span class="hljs-number">2px</span> solid <span class="hljs-number">#fff</span>;<br>    <span class="hljs-attribute">transition</span>: all <span class="hljs-number">0.3s</span> ease;<br>&#125;<br><span class="hljs-selector-class">.cbxBox</span> <span class="hljs-selector-tag">input</span><span class="hljs-selector-attr">[type=checkbox]</span> &#123;<br>    <span class="hljs-attribute">display</span>: none <span class="hljs-meta">!important</span>;<br>&#125;<br><span class="hljs-selector-class">.cbxBox</span> <span class="hljs-selector-tag">input</span><span class="hljs-selector-attr">[type=checkbox]</span><span class="hljs-selector-pseudo">:checked</span> ~ <span class="hljs-selector-class">.cbx</span> &#123;<br>    <span class="hljs-attribute">border-color</span>: transparent;<br>    <span class="hljs-attribute">background</span>: <span class="hljs-number">#392ca7</span>;<br>    <span class="hljs-attribute">animation</span>: anima <span class="hljs-number">0.6s</span> ease;<br>&#125;<br><span class="hljs-selector-class">.cbxBox</span> <span class="hljs-selector-tag">input</span><span class="hljs-selector-attr">[type=checkbox]</span><span class="hljs-selector-pseudo">:checked</span> ~ <span class="hljs-selector-class">.cbx</span><span class="hljs-selector-pseudo">:after</span> &#123;<br>    <span class="hljs-attribute">opacity</span>: <span class="hljs-number">1</span>;<br>    <span class="hljs-attribute">transform</span>: <span class="hljs-built_in">rotate</span>(<span class="hljs-number">45deg</span>) <span class="hljs-built_in">scale</span>(<span class="hljs-number">1</span>);<br>&#125;<br><span class="hljs-keyword">@keyframes</span> anima &#123;<br>    <span class="hljs-selector-tag">from</span> &#123;<br>        <span class="hljs-attribute">transform</span>: <span class="hljs-built_in">scale</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-number">25%</span> &#123;<br>        <span class="hljs-attribute">transform</span>: <span class="hljs-built_in">scale</span>(<span class="hljs-number">0.95</span>, <span class="hljs-number">0.95</span>);<br>    &#125;<br>    <span class="hljs-number">50%</span> &#123;<br>        <span class="hljs-attribute">transform</span>: <span class="hljs-built_in">scale</span>(<span class="hljs-number">1.15</span>, <span class="hljs-number">1.15</span>);<br>    &#125;<br>    <span class="hljs-number">75%</span> &#123;<br>        <span class="hljs-attribute">transform</span>: <span class="hljs-built_in">scale</span>(<span class="hljs-number">0.95</span>, <span class="hljs-number">0.95</span>);<br>    &#125;<br>    <span class="hljs-selector-tag">to</span> &#123;<br>        <span class="hljs-attribute">transform</span>: <span class="hljs-built_in">scale</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>✔️ GitHub<br><a href="https://github.com/rudtn082/UI/tree/main/checkbox1" title="GitHub">링크</a>  </p>]]></content>
    
    
    <categories>
      
      <category>UI_UX</category>
      
    </categories>
    
    
    <tags>
      
      <tag>디자인</tag>
      
      <tag>CSS</tag>
      
      <tag>체크박스</tag>
      
      <tag>checkbox</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>알림 디자인-1 (notification Design-1 with CSS)</title>
    <link href="/uiux3/"/>
    <url>/uiux3/</url>
    
    <content type="html"><![CDATA[<h1 id="알림-디자인-1-notification-Design-1-with-CSS"><a href="#알림-디자인-1-notification-Design-1-with-CSS" class="headerlink" title="알림 디자인-1 (notification Design-1 with CSS)"></a>알림 디자인-1 (notification Design-1 with CSS)</h1><p>알림 창을 띄워 다른화면으로 이동시키는 용도로 활용할 수 있다.  </p><iframe src="https://rudtn082.github.io/UI/notification1/notification1.html" width="900" height="160" style="margin: 15px auto; display: block;"></iframe><p>✔️ HTML  </p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs gradle">&lt;<span class="hljs-keyword">div</span> <span class="hljs-keyword">class</span>=<span class="hljs-string">&quot;notification&quot;</span>&gt;<br>    &lt;span <span class="hljs-keyword">class</span>=<span class="hljs-string">&quot;material-icons-outlined icon&quot;</span>&gt;info&lt;/span&gt;<br>    &lt;<span class="hljs-keyword">div</span> <span class="hljs-keyword">class</span>=<span class="hljs-string">&quot;messages&quot;</span>&gt;<br>        &lt;<span class="hljs-keyword">div</span> <span class="hljs-keyword">class</span>=<span class="hljs-string">&quot;title&quot;</span>&gt;Info&lt;/<span class="hljs-keyword">div</span>&gt;<br>        &lt;<span class="hljs-keyword">div</span> <span class="hljs-keyword">class</span>=<span class="hljs-string">&quot;sub&quot;</span>&gt;Add your info message here.&lt;/<span class="hljs-keyword">div</span>&gt;<br>    &lt;/<span class="hljs-keyword">div</span>&gt;<br>    &lt;a <span class="hljs-keyword">class</span>=<span class="hljs-string">&quot;button&quot;</span> href=<span class="hljs-string">&quot;javascript:;&quot;</span>&gt;<span class="hljs-keyword">Next</span>&lt;/a&gt;<br>&lt;/<span class="hljs-keyword">div</span>&gt;<br></code></pre></td></tr></table></figure><p>✔️ CSS  </p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.notification</span> &#123;<br>    <span class="hljs-attribute">display</span>: inline-flex;<br>    <span class="hljs-attribute">padding</span>: <span class="hljs-number">10px</span> <span class="hljs-number">20px</span>;<br>    <span class="hljs-attribute">background</span>: <span class="hljs-number">#fff</span>;<br>    <span class="hljs-attribute">border-radius</span>: <span class="hljs-number">10px</span>;<br>    <span class="hljs-attribute">justify-content</span>: space-between;<br>    <span class="hljs-attribute">color</span>: <span class="hljs-number">#212121</span>;<br>    <span class="hljs-attribute">gap</span>: <span class="hljs-number">15px</span>;<br>    <span class="hljs-attribute">box-shadow</span>: <span class="hljs-number">0px</span> <span class="hljs-number">10px</span> <span class="hljs-number">20px</span> <span class="hljs-number">13px</span> <span class="hljs-built_in">rgba</span>(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0.1</span>);<br>    <span class="hljs-attribute">animation</span>: scale .<span class="hljs-number">5s</span> linear alternate-reverse infinite;<br>    <span class="hljs-attribute">text-align</span>: left;<br>&#125;<br><span class="hljs-keyword">@keyframes</span> scale &#123;<br>    <span class="hljs-selector-tag">from</span> &#123;<br>        <span class="hljs-attribute">transform</span>: <span class="hljs-built_in">scale</span>(<span class="hljs-number">0.98</span>);<br>    &#125;<br><br>    <span class="hljs-selector-tag">to</span> &#123;<br>        <span class="hljs-attribute">transform</span>: <span class="hljs-built_in">scale</span>(<span class="hljs-number">1</span>);<br>    &#125;<br>&#125;<br><span class="hljs-selector-class">.notification</span> <span class="hljs-selector-class">.icon</span> &#123;<br>    <span class="hljs-attribute">font-size</span>: <span class="hljs-number">40px</span>;<br>    <span class="hljs-attribute">line-height</span>: <span class="hljs-number">65px</span>;<br>    <span class="hljs-attribute">color</span>: <span class="hljs-number">#303f9f</span>;<br>&#125;<br><span class="hljs-selector-class">.notification</span> <span class="hljs-selector-class">.messages</span> &#123;<br>    <span class="hljs-attribute">display</span>: inline-flex;<br>    <span class="hljs-attribute">flex-direction</span>: column;<br>    <span class="hljs-attribute">justify-content</span>: center;<br>&#125;<br><span class="hljs-selector-class">.notification</span> <span class="hljs-selector-class">.messages</span> <span class="hljs-selector-class">.title</span> &#123;<br>    <span class="hljs-attribute">font-size</span>: <span class="hljs-number">16px</span>;<br>    <span class="hljs-attribute">font-family</span>: <span class="hljs-string">&#x27;NotoSansKR-Medium&#x27;</span>;<br>    <span class="hljs-attribute">text-transform</span>: uppercase;<br>    <span class="hljs-attribute">color</span>: <span class="hljs-number">#494949</span>;<br>&#125;<br><span class="hljs-selector-class">.notification</span> <span class="hljs-selector-class">.messages</span> <span class="hljs-selector-class">.sub</span> &#123;<br>    <span class="hljs-attribute">font-size</span>: <span class="hljs-number">13px</span>;<br>&#125;<br><span class="hljs-selector-class">.notification</span> <span class="hljs-selector-class">.button</span> &#123;<br>    <span class="hljs-attribute">line-height</span>: <span class="hljs-number">65px</span>;<br>    <span class="hljs-attribute">padding</span>: <span class="hljs-number">0px</span> <span class="hljs-number">15px</span>;<br>    <span class="hljs-attribute">font-size</span>: <span class="hljs-number">15px</span>;<br>    <span class="hljs-attribute">text-align</span>: center;<br>    <span class="hljs-attribute">background-color</span>: <span class="hljs-number">#303f9f</span>;<br>    <span class="hljs-attribute">color</span>: <span class="hljs-number">#ffffff</span>;<br>    <span class="hljs-attribute">text-transform</span>: uppercase;<br>    <span class="hljs-attribute">border-radius</span>: <span class="hljs-number">10px</span>;<br>    <span class="hljs-attribute">text-decoration</span>: none;<br>&#125;<br><span class="hljs-selector-class">.notification</span> <span class="hljs-selector-class">.button</span><span class="hljs-selector-pseudo">:hover</span> &#123;<br>    <span class="hljs-attribute">background-color</span>: <span class="hljs-number">#1a237e</span>;<br>    <span class="hljs-attribute">font-family</span>: <span class="hljs-string">&#x27;NotoSansKR-Medium&#x27;</span>;<br>&#125;<br><span class="hljs-keyword">@media</span> all <span class="hljs-keyword">and</span> (<span class="hljs-attribute">max-width</span>: <span class="hljs-number">350px</span>) &#123;<br>    <span class="hljs-selector-class">.notification</span> <span class="hljs-selector-class">.messages</span> <span class="hljs-selector-class">.sub</span> &#123;<br>        <span class="hljs-attribute">display</span>: none;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>✔️ GitHub<br><a href="https://github.com/rudtn082/UI/tree/main/notification1" title="GitHub">링크</a>  </p>]]></content>
    
    
    <categories>
      
      <category>UI_UX</category>
      
    </categories>
    
    
    <tags>
      
      <tag>디자인</tag>
      
      <tag>CSS</tag>
      
      <tag>알림</tag>
      
      <tag>notification</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>스위치 디자인-1 (Switch Design-1 with CSS)</title>
    <link href="/uiux4/"/>
    <url>/uiux4/</url>
    
    <content type="html"><![CDATA[<h1 id="스위치-디자인-1-Switch-Design-1-with-CSS"><a href="#스위치-디자인-1-Switch-Design-1-with-CSS" class="headerlink" title="스위치 디자인-1 (Switch Design-1 with CSS)"></a>스위치 디자인-1 (Switch Design-1 with CSS)</h1><p>기본 스위치로 활용할 수 있다.  </p><iframe src="https://rudtn082.github.io/UI/switch1/switch1.html" width="900" height="160" style="margin: 15px auto; display: block;"></iframe><p>✔️ HTML  </p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs angelscript">&lt;label <span class="hljs-keyword">class</span>=&quot;<span class="hljs-symbol">switch1</span>&quot;&gt;<br>    &lt;<span class="hljs-symbol">input</span> <span class="hljs-symbol">type</span>=&quot;<span class="hljs-symbol">checkbox</span>&quot;&gt;<br>    &lt;<span class="hljs-symbol">span</span> <span class="hljs-symbol">class</span>=&quot;<span class="hljs-symbol">slider</span>&quot;&gt;&lt;/<span class="hljs-symbol">span</span>&gt;<br>&lt;/<span class="hljs-symbol">label</span>&gt;<br></code></pre></td></tr></table></figure><p>✔️ CSS  </p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.switch1</span> &#123;<br>    <span class="hljs-attribute">position</span>: relative;<br>    <span class="hljs-attribute">display</span>: inline-block;<br>    <span class="hljs-attribute">font-size</span>: <span class="hljs-number">15px</span>;<br>    <span class="hljs-attribute">width</span>: <span class="hljs-number">60px</span>;<br>    <span class="hljs-attribute">height</span>: <span class="hljs-number">30px</span>;<br>&#125;<br><span class="hljs-selector-class">.switch1</span> <span class="hljs-selector-class">.slider</span> &#123;<br>    <span class="hljs-attribute">position</span>: absolute;<br>    <span class="hljs-attribute">cursor</span>: pointer;<br>    <span class="hljs-attribute">top</span>: <span class="hljs-number">0</span>;<br>    <span class="hljs-attribute">left</span>: <span class="hljs-number">0</span>;<br>    <span class="hljs-attribute">right</span>: <span class="hljs-number">0</span>;<br>    <span class="hljs-attribute">bottom</span>: <span class="hljs-number">0</span>;<br>    <span class="hljs-attribute">background-color</span>: <span class="hljs-number">#fff</span>;<br>    <span class="hljs-attribute">border-radius</span>: <span class="hljs-number">20px</span>;<br>    <span class="hljs-attribute">border</span>: <span class="hljs-number">1px</span> solid <span class="hljs-number">#ccc</span>;<br>    <span class="hljs-attribute">transition</span>: all .<span class="hljs-number">4s</span> ease-in-out;<br>&#125;<br><span class="hljs-selector-class">.switch1</span> <span class="hljs-selector-class">.slider</span><span class="hljs-selector-pseudo">:before</span> &#123;<br>    <span class="hljs-attribute">position</span>: absolute;<br>    <span class="hljs-attribute">content</span>: <span class="hljs-string">&quot;&quot;</span>;<br>    <span class="hljs-attribute">height</span>: <span class="hljs-number">20px</span>;<br>    <span class="hljs-attribute">width</span>: <span class="hljs-number">20px</span>;<br>    <span class="hljs-attribute">border-radius</span>: <span class="hljs-number">50%</span>;<br>    <span class="hljs-attribute">left</span>: <span class="hljs-number">5px</span>;<br>    <span class="hljs-attribute">bottom</span>: <span class="hljs-number">4px</span>;<br>    <span class="hljs-attribute">background-color</span>: <span class="hljs-number">#adb5bd</span>;<br>    <span class="hljs-attribute">transition</span>: all .<span class="hljs-number">4s</span> ease-in-out;<br>&#125;<br><span class="hljs-selector-tag">input</span><span class="hljs-selector-pseudo">:checked</span> ~ <span class="hljs-selector-class">.slider</span> &#123;<br>    <span class="hljs-attribute">background-color</span>: <span class="hljs-number">#1976d2</span>;<br>    <span class="hljs-attribute">border</span>: <span class="hljs-number">1px</span> solid <span class="hljs-number">#1976d2</span>;<br>&#125;<br><span class="hljs-selector-tag">input</span><span class="hljs-selector-pseudo">:checked</span> ~ <span class="hljs-selector-class">.slider</span><span class="hljs-selector-pseudo">:before</span> &#123;<br>    <span class="hljs-attribute">transform</span>: <span class="hljs-built_in">translate</span>(<span class="hljs-number">27px</span>, <span class="hljs-number">0px</span>);<br>    <span class="hljs-attribute">background-color</span>: <span class="hljs-number">#fff</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>✔️ GitHub<br><a href="https://github.com/rudtn082/UI/tree/main/switch1" title="GitHub">링크</a>  </p>]]></content>
    
    
    <categories>
      
      <category>UI_UX</category>
      
    </categories>
    
    
    <tags>
      
      <tag>디자인</tag>
      
      <tag>CSS</tag>
      
      <tag>스위치</tag>
      
      <tag>switch</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>버튼 디자인-2 (button Design-2 with CSS)</title>
    <link href="/uiux2/"/>
    <url>/uiux2/</url>
    
    <content type="html"><![CDATA[<h1 id="버튼-디자인-2-button-Design-2-with-CSS"><a href="#버튼-디자인-2-button-Design-2-with-CSS" class="headerlink" title="버튼 디자인-2 (button Design-2 with CSS)"></a>버튼 디자인-2 (button Design-2 with CSS)</h1><p>좋아요 버튼 등으로 활용할 수 있는 버튼이다.  </p><iframe src="https://rudtn082.github.io/UI/button2/button2.html" width="900" height="160" style="margin: 15px auto; display: block;"></iframe><p>✔️ HTML  </p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;like&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;material-icons-outlined before&quot;</span>&gt;</span>favorite_border<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;material-icons-outlined after&quot;</span>&gt;</span>favorite<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;text&quot;</span>&gt;</span>Like<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br></code></pre></td></tr></table></figure><p>✔️ CSS  </p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.like</span> &#123;<br>    <span class="hljs-attribute">display</span>: flex;<br>    <span class="hljs-attribute">gap</span>: <span class="hljs-number">10px</span>;<br>    <span class="hljs-attribute">justify-content</span>: space-between;<br>    <span class="hljs-attribute">align-items</span>: center;<br>    <span class="hljs-attribute">padding</span>: <span class="hljs-number">15px</span>;<br>    <span class="hljs-attribute">background-color</span>: <span class="hljs-number">#fc8989</span>;<br>    <span class="hljs-attribute">border-radius</span>: <span class="hljs-number">35px</span>;<br>    <span class="hljs-attribute">border</span>: <span class="hljs-number">0px</span>;<br>    <span class="hljs-attribute">font-size</span>: <span class="hljs-number">25px</span>;<br>    <span class="hljs-attribute">margin</span>: <span class="hljs-number">0</span> auto;<br>    <span class="hljs-attribute">color</span>: <span class="hljs-number">#fff</span>;<br>    <span class="hljs-attribute">cursor</span>: pointer;<br>    <span class="hljs-attribute">transition</span>: all .<span class="hljs-number">5s</span>;<br>&#125;<br><span class="hljs-selector-class">.like</span><span class="hljs-selector-pseudo">:hover</span> &#123;<br>    <span class="hljs-attribute">background-color</span>: <span class="hljs-number">#ff6e6e</span>;<br>&#125;<br><span class="hljs-selector-class">.like</span><span class="hljs-selector-pseudo">:hover</span> <span class="hljs-selector-class">.before</span> &#123;<br>    <span class="hljs-attribute">opacity</span>: <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-selector-class">.like</span> <span class="hljs-selector-class">.after</span> &#123;<br>    <span class="hljs-attribute">position</span>: absolute;<br>    <span class="hljs-attribute">opacity</span>: <span class="hljs-number">0</span>;<br>    <span class="hljs-attribute">color</span>: <span class="hljs-number">#fff</span>;<br>&#125;<br><span class="hljs-selector-class">.like</span><span class="hljs-selector-pseudo">:hover</span> <span class="hljs-selector-class">.after</span> &#123;<br>    <span class="hljs-attribute">opacity</span>: <span class="hljs-number">1</span>;<br>    <span class="hljs-attribute">animation</span>: beat <span class="hljs-number">1s</span> infinite;<br>&#125;<br><span class="hljs-keyword">@keyframes</span> beat &#123;<br>    <span class="hljs-number">0%</span> &#123;<br>        <span class="hljs-attribute">transform</span>: <span class="hljs-built_in">scale</span>(<span class="hljs-number">1</span>);<br>    &#125;<br><br>    <span class="hljs-number">15%</span> &#123;<br>        <span class="hljs-attribute">transform</span>: <span class="hljs-built_in">scale</span>(<span class="hljs-number">1.15</span>);<br>    &#125;<br><br>    <span class="hljs-number">30%</span> &#123;<br>        <span class="hljs-attribute">transform</span>: <span class="hljs-built_in">scale</span>(<span class="hljs-number">1</span>);<br>    &#125;<br><br>    <span class="hljs-number">45%</span> &#123;<br>        <span class="hljs-attribute">transform</span>: <span class="hljs-built_in">scale</span>(<span class="hljs-number">1.15</span>);<br>    &#125;<br><br>    <span class="hljs-number">60%</span> &#123;<br>        <span class="hljs-attribute">transform</span>: <span class="hljs-built_in">scale</span>(<span class="hljs-number">1</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>✔️ GitHub<br><a href="https://github.com/rudtn082/UI/tree/main/button2" title="GitHub">링크</a>  </p>]]></content>
    
    
    <categories>
      
      <category>UI_UX</category>
      
    </categories>
    
    
    <tags>
      
      <tag>버튼</tag>
      
      <tag>디자인</tag>
      
      <tag>CSS</tag>
      
      <tag>button</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>버튼 디자인-1 (button Design-1 with CSS)</title>
    <link href="/uiux1/"/>
    <url>/uiux1/</url>
    
    <content type="html"><![CDATA[<h1 id="버튼-디자인-1-button-Design-1-with-CSS"><a href="#버튼-디자인-1-button-Design-1-with-CSS" class="headerlink" title="버튼 디자인-1 (button Design-1 with CSS)"></a>버튼 디자인-1 (button Design-1 with CSS)</h1><p>여러개의 버튼이 같은 레벨에 있어야할 때 사용할 수 있다.  </p><iframe src="https://rudtn082.github.io/UI/button1/button1.html" width="900" height="160" style="margin: 15px auto; display: block;"></iframe><p>✔️ HTML  </p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;buttonBox&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;button red&quot;</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;javascript:;&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>Button<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;material-icons-outlined icons&quot;</span>&gt;</span>delete<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;button blue&quot;</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;javascript:;&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>Button<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;material-icons-outlined icons&quot;</span>&gt;</span>save<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;button green&quot;</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;javascript:;&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>Button<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;material-icons-outlined icons&quot;</span>&gt;</span>done<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure><p>✔️ CSS  </p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.buttonBox</span> &#123;<br>    <span class="hljs-attribute">display</span>: flex;<br>    <span class="hljs-attribute">width</span>: <span class="hljs-number">100%</span>;<br>    <span class="hljs-attribute">height</span>: <span class="hljs-number">50px</span>;<br>&#125;<br><span class="hljs-selector-class">.buttonBox</span> <span class="hljs-selector-class">.button</span> &#123;<br>    <span class="hljs-attribute">flex</span>: <span class="hljs-number">1</span>;<br>    <span class="hljs-attribute">color</span>: <span class="hljs-number">#aaa</span>;<br>    <span class="hljs-attribute">background</span>: <span class="hljs-number">#fff</span>;<br>    <span class="hljs-attribute">border-right</span>: <span class="hljs-number">1px</span> solid <span class="hljs-number">#ccc</span>;<br>    <span class="hljs-attribute">font-size</span>: <span class="hljs-number">17px</span>;<br>    <span class="hljs-attribute">text-align</span>: center;<br>    <span class="hljs-attribute">line-height</span>: <span class="hljs-number">50px</span>;<br>    <span class="hljs-attribute">transition</span>: all <span class="hljs-number">0.5s</span> ease-in-out;<br>    <span class="hljs-attribute">text-decoration</span>: none;<br>&#125;<br><span class="hljs-selector-class">.buttonBox</span> <span class="hljs-selector-class">.button</span><span class="hljs-selector-pseudo">:last-child</span> &#123;<br>    <span class="hljs-attribute">border</span>: <span class="hljs-number">0px</span>;<br>&#125;<br><span class="hljs-selector-class">.buttonBox</span> <span class="hljs-selector-class">.button</span><span class="hljs-selector-pseudo">:hover</span> &#123;<br>    <span class="hljs-attribute">flex</span>: <span class="hljs-number">2</span>;<br>&#125;<br><span class="hljs-selector-class">.buttonBox</span> <span class="hljs-selector-class">.button</span><span class="hljs-selector-class">.red</span><span class="hljs-selector-pseudo">:hover</span> &#123;<br>    <span class="hljs-attribute">color</span>: <span class="hljs-number">#fff</span>;<br>    <span class="hljs-attribute">background</span>: <span class="hljs-number">#d32f2f</span>;<br>&#125;<br><span class="hljs-selector-class">.buttonBox</span> <span class="hljs-selector-class">.button</span><span class="hljs-selector-class">.blue</span><span class="hljs-selector-pseudo">:hover</span> &#123;<br>    <span class="hljs-attribute">color</span>: <span class="hljs-number">#fff</span>;<br>    <span class="hljs-attribute">background</span>: <span class="hljs-number">#1976d2</span>;<br>&#125;<br><span class="hljs-selector-class">.buttonBox</span> <span class="hljs-selector-class">.button</span><span class="hljs-selector-class">.green</span><span class="hljs-selector-pseudo">:hover</span> &#123;<br>    <span class="hljs-attribute">color</span>: <span class="hljs-number">#fff</span>;<br>    <span class="hljs-attribute">background</span>: <span class="hljs-number">#388e3c</span>;<br>&#125;<br><span class="hljs-selector-class">.buttonBox</span> <span class="hljs-selector-class">.button</span> <span class="hljs-selector-class">.icons</span> &#123;<br>    <span class="hljs-attribute">vertical-align</span>: text-bottom;<br>    <span class="hljs-attribute">width</span>: <span class="hljs-number">0</span>;<br>    <span class="hljs-attribute">margin-left</span>: <span class="hljs-number">5px</span>;<br>    <span class="hljs-attribute">overflow</span>: hidden;<br>    <span class="hljs-attribute">font-size</span>: <span class="hljs-number">22px</span>;<br>    <span class="hljs-attribute">transition</span>: width <span class="hljs-number">0.5s</span> ease-in-out;<br>&#125;<br><span class="hljs-keyword">@media</span> all <span class="hljs-keyword">and</span> (<span class="hljs-attribute">min-width</span>: <span class="hljs-number">420px</span>) &#123;<br>    <span class="hljs-selector-class">.buttonBox</span> <span class="hljs-selector-class">.button</span><span class="hljs-selector-pseudo">:hover</span> <span class="hljs-selector-class">.icons</span> &#123;<br>        <span class="hljs-attribute">width</span>: <span class="hljs-number">20px</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>✔️ GitHub<br><a href="https://github.com/rudtn082/UI/tree/main/button1" title="GitHub">링크</a>  </p>]]></content>
    
    
    <categories>
      
      <category>UI_UX</category>
      
    </categories>
    
    
    <tags>
      
      <tag>버튼</tag>
      
      <tag>디자인</tag>
      
      <tag>CSS</tag>
      
      <tag>button</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[안드로이드 프레임워크 개선] - strlcpy1</title>
    <link href="/strlcpy1/"/>
    <url>/strlcpy1/</url>
    
    <content type="html"><![CDATA[<h1 id="안드로이드-프레임워크-개선"><a href="#안드로이드-프레임워크-개선" class="headerlink" title="[안드로이드 프레임워크 개선]"></a>[안드로이드 프레임워크 개선]</h1><h2 id="strlcpy1"><a href="#strlcpy1" class="headerlink" title="strlcpy1"></a>strlcpy1</h2><h3 id="안드로이드-소스코드-구성"><a href="#안드로이드-소스코드-구성" class="headerlink" title="안드로이드 소스코드 구성"></a>안드로이드 소스코드 구성</h3><p>bionic&#x2F; - 안드로이드 표준 C 라이브러리<br>bootable&#x2F; - 부트로더 및 Disk Installer 등<br>build&#x2F; - Makefile 관련 세팅파일들, script, map file<br>development&#x2F; - 개발 시 필요한 utility &amp; application<br>external&#x2F; - 안드로이드 프레임워크가 아닌 외부에서 가져온 라이브러리와 바이너리 위치<br>frameworks&#x2F; - android framework, C&#x2F;C++(JNI포함)&#x2F;JAVA source들, 일부 HAL source도 포함<br>　　　　&#x2F;base - Android Framework source<br>　　　　&#x2F;libs : Android base library<br>　　　　&#x2F;audioflinger : Android audio service &amp; HAL source<br>　　　　&#x2F;surfaceflinger : Android video service &amp; HAL<br>　　　　&#x2F;ui :Application Framework에서 JNI를 통해서  호출되는 Android framework의 client part, HAL (Input device의 경우)  - EventHub.cpp<br>　　　　&#x2F;utils : wrapping class, 압축관련 유틸리티 등<br>　　　　&#x2F;binder : Android Binder &amp; Anonymous shared memory<br>　　　　&#x2F;cmds : binder관련인 service manager소스와 여러가지 command들<br>　　　　&#x2F;media : media관련 client &amp; service library<br>hardware&#x2F; - HAL source &amp; include, 일반적으로 android에서 사용하는 hardware관련 소스들을 포함, 반드시 이 디렉토리에만 위치하는 것은 아니다(vendor 디렉토리에 존재하는 경우도 많음)<br>out&#x2F; - 컴파일 된 결과물이 생성되는 디렉토리<br>packages&#x2F; - android 기본 application source(JAVA)<br>prebuilt&#x2F; - compiler &amp; binaries<br>system&#x2F; - android의 기본 binary 소스<br>      &#x2F;core&#x2F;init :  android init source<br>      &#x2F;core&#x2F;vold :  external storage 제어 모듈  </p><h3 id="strlcpy가-사용되는-곳-정리"><a href="#strlcpy가-사용되는-곳-정리" class="headerlink" title="strlcpy가 사용되는 곳 정리"></a>strlcpy가 사용되는 곳 정리</h3><p>환경 : Android-6.0.1_r77  </p><p><img src="/images/post/str1_1.png" alt="str_1" title="str1_1">  </p><p>링크 : <a href="https://docs.google.com/spreadsheets/d/1GucItCNYztFqANwKHoCE1N-0Nap_DhEjrBPiBnQGsL0/edit?usp=sharing">https://docs.google.com/spreadsheets/d/1GucItCNYztFqANwKHoCE1N-0Nap_DhEjrBPiBnQGsL0/edit?usp=sharing</a>  </p><p>안드로이드 6.0.1_r77 버전 기준 총 488개의 파일에서 1568개의 strlcpy()가 사용 중이고, 오디오나 미디어쪽 하드웨어쪽 소스에서 가장 많이 사용하는 것 같다.  </p>]]></content>
    
    
    <categories>
      
      <category>Android</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Android</tag>
      
      <tag>안드로이드 프레임워크 개선</tag>
      
      <tag>strlcpy</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[안드로이드 프레임워크 개선] - PackageManager10</title>
    <link href="/PackageManager10/"/>
    <url>/PackageManager10/</url>
    
    <content type="html"><![CDATA[<h1 id="안드로이드-프레임워크-개선"><a href="#안드로이드-프레임워크-개선" class="headerlink" title="[안드로이드 프레임워크 개선]"></a>[안드로이드 프레임워크 개선]</h1><h2 id="PackageManager10"><a href="#PackageManager10" class="headerlink" title="PackageManager10"></a>PackageManager10</h2><h3 id="멘토님-의견"><a href="#멘토님-의견" class="headerlink" title="멘토님 의견"></a>멘토님 의견</h3><p>① Git log를 봐도 5년간 change가 없는 곳이다.  </p><p>② 안드로이드의 경우 OpenSource이기 때문에 간혹 라이센스 문제라던지 기타 등등의 이유로 이해할 수 없는 라이브러리를 쓰기도 한다.(경험적인 의견)  </p><p>③ 어쨌든 개선 포인트에 대해서 실험 결과를 바탕으로 결론까지 도출해 보면 좋을 것 같다.  </p><p>④ Contribution의 경우 특별한 방법이 있는 것은 아니고, 지금 Git을 통해 소스를 받은 상태인데, 코드 수정 후에 Commit을 만들고 repo upload 등을 통해 업로드해봐라.<br>(리뷰어 점수를 받고 merge가 되니까 올리는 것은 걱정하지 말라.)</p><h3 id="100번-측정"><a href="#100번-측정" class="headerlink" title="100번 측정(?)"></a>100번 측정(?)</h3><p><img src="/images/post/PM10_1.png" alt="PM10_1" title="PM10_1">  </p><p>100번을 측정하고 보니, 개선이 안되어있었다. 이유를 찾아보니, 잘못된 로그로 측정하고 있었다.  </p><p>100번 측정하는 것은 다음 주에 다시 진행할 예정이다.  </p><h3 id="strlcpy-수정"><a href="#strlcpy-수정" class="headerlink" title="strlcpy 수정"></a>strlcpy 수정</h3><p>로그 수정하기 위해 코드를 보다가 수정하려던 strlcpy()를 잘못 작성한 것을 확인했다.<br>기존 strlcpy()는 마지막에 널값을 추가해주는데, 우리가 작성한 코드는 널값을 넣어주지 않았었다.  </p><p>-수정 전-  </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">size_t</span>                 </span><br><span class="hljs-function"><span class="hljs-title">strlcpy</span><span class="hljs-params">(<span class="hljs-type">char</span>* dst, <span class="hljs-type">const</span> <span class="hljs-type">char</span>* src, <span class="hljs-type">size_t</span> siz)</span>    </span><br><span class="hljs-function"></span>&#123;<br>   <span class="hljs-built_in">memcpy</span>(dst, src, siz);<br><br>   <span class="hljs-keyword">return</span> <span class="hljs-built_in">strlen</span>(src);<br>&#125;<br></code></pre></td></tr></table></figure><p>-수정 후-  </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">size_t</span>                 </span><br><span class="hljs-function"><span class="hljs-title">strlcpy</span><span class="hljs-params">(<span class="hljs-type">char</span>* dst, <span class="hljs-type">const</span> <span class="hljs-type">char</span>* src, <span class="hljs-type">size_t</span> siz)</span>    </span><br><span class="hljs-function"></span>&#123;<br>   <span class="hljs-type">size_t</span> srclen, returnV = <span class="hljs-built_in">strlen</span>(src);<br><br>   siz--;<br><br>   srclen = returnV;<br><br>   <span class="hljs-keyword">if</span> (srclen &gt; siz)<br>      srclen = siz;<br><br>   <span class="hljs-built_in">memcpy</span>(dst, src, srclen);<br>   dst[srclen] = <span class="hljs-string">&#x27;\0&#x27;</span>;<br><br>   <span class="hljs-keyword">return</span> returnV;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="문제점"><a href="#문제점" class="headerlink" title="문제점"></a>문제점</h3><p>(추측) 말 그대로 copy기 때문에 우리가 바꾼 부분이 첫 번째 부팅과 새로 앱을 깔았을 경우에서만 사용되는 것 같음<br>-&gt; 검증해야 함, 논문을 쓸 수 있을지?(매번 켤 때마다 개선되는 것이 아니기 때문에)  </p><h3 id="앞으로-방향"><a href="#앞으로-방향" class="headerlink" title="앞으로 방향"></a>앞으로 방향</h3><ol><li>전체 부팅시간을 측정해보고 개선이 된다면 그대로 부팅속도 향상 쪽으로<br>(패키지 스캐닝 개선으로 주제를 잡을 것이면 copy말고도 find부분도 개선이 필요한가?)  </li><li>부팅속도 개선이 안된다면 메모리 블록 복사를 통한 안드로이드 개선쪽으로(다른 곳에서도 strlcpy를 사용하기 때문에)</li></ol><p>기존 논문 제목과 목차를 다음과 같이 하려고 했었는데, 방향을 결정하고 PPT 제작 예정  </p><p><img src="/images/post/PM10_2.png" alt="PM10_2" title="PM10_2">  </p><p><img src="/images/post/PM10_3.png" alt="PM10_3" title="PM10_3">  </p>]]></content>
    
    
    <categories>
      
      <category>Android</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Android</tag>
      
      <tag>안드로이드 프레임워크 개선</tag>
      
      <tag>PackageManager</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[안드로이드 프레임워크 개선] - PackageManager9</title>
    <link href="/PackageManager9/"/>
    <url>/PackageManager9/</url>
    
    <content type="html"><![CDATA[<h1 id="안드로이드-프레임워크-개선"><a href="#안드로이드-프레임워크-개선" class="headerlink" title="[안드로이드 프레임워크 개선]"></a>[안드로이드 프레임워크 개선]</h1><h2 id="PackageManager9"><a href="#PackageManager9" class="headerlink" title="PackageManager9"></a>PackageManager9</h2><h3 id="문제의-if문"><a href="#문제의-if문" class="headerlink" title="문제의 if문"></a>문제의 if문</h3><p>지난주 아래의 if문이 무조건 true로 밖에 나올 수 없다고 생각했었는데, strlcpy()를 수정하기 전에 실제로 그러한지 확인을 했다.  </p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-selector-tag">if</span> (<span class="hljs-built_in">strlcpy</span>(localFileName, nativeLibPath.<span class="hljs-built_in">c_str</span>(), <span class="hljs-built_in">sizeof</span>(localFileName)) != nativeLibPath.<span class="hljs-built_in">size</span>()) &#123;<br>    <span class="hljs-selector-tag">ALOGD</span>(<span class="hljs-string">&quot;Couldn&#x27;t allocate local file name for library&quot;</span>);<br>    <span class="hljs-selector-tag">return</span> <span class="hljs-selector-tag">INSTALL_FAILED_INTERNAL_ERROR</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>strlcpy()의 결과로 nativeLibPath.c_str()의 문자열의 길이와 nativeLibPath.size()를 비교하게 되는 코드인데,<br>결국 리턴 받은 utf_chars_의 길이와 strlen(utf_chars_)를 수행하는 꼴이 된다.<br>혹시 우리가 모르는 예외가 있을 수 있다고 생각해 직접 비교하는 코드를 만들어 확인했다.  </p><p><img src="/images/post/PM9_1.png" alt="PM9_1" title="PM9_1">  </p><p>0~30 길이의 문자열을 랜덤으로 생성해서, strlcpy의 결과와 해당 문자열을 strlen 한 결과를 비교하여 false가 나오는지 확인했다.<br>결과는 10만 번을 수행했지만 다음과 같이 모두 true로 나왔다.  </p><p><img src="/images/post/PM9_2.png" alt="PM9_2" title="PM9_2">  </p>]]></content>
    
    
    <categories>
      
      <category>Android</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Android</tag>
      
      <tag>안드로이드 프레임워크 개선</tag>
      
      <tag>PackageManager</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[안드로이드 프레임워크 개선] - PackageManager8</title>
    <link href="/PackageManager8/"/>
    <url>/PackageManager8/</url>
    
    <content type="html"><![CDATA[<h1 id="안드로이드-프레임워크-개선"><a href="#안드로이드-프레임워크-개선" class="headerlink" title="[안드로이드 프레임워크 개선]"></a>[안드로이드 프레임워크 개선]</h1><h2 id="PackageManager8"><a href="#PackageManager8" class="headerlink" title="PackageManager8"></a>PackageManager8</h2><p>지난주에 strlcpy를 memcpy로 변경해보았는데, 속도는 빨라졌지만, 동일하게 동작하는지 알 수 없었다.<br>먼저 우리가 모르는 부분에 대해서 공부를 해보기로 했다.  </p><h3 id="strlcpy"><a href="#strlcpy" class="headerlink" title="strlcpy()"></a>strlcpy()</h3><p>Version : android-6.0.1_r77<br>소스 코드 : <a href="https://android.googlesource.com/platform/system/core/+/refs/tags/android-6.0.1_r77/libcutils/strlcpy.c">https://android.googlesource.com/platform/system/core/+/refs/tags/android-6.0.1_r77/libcutils/strlcpy.c</a>  </p><p>src를 dst로 siz크기만큼 copy 한다. strncpy()와 비슷해 보였지만 다음과 같은 다른 점이 있었다.<br>먼저, strcpy()는 널값까지 복사가 되지만 오버플로우 문제가 있다.<br>strncpy()는 널값을 상관하지 않고 n의 길이만큼 복사하게 된다. n의 길이에 따라서 널값을 복사하지 않을 때가 있고, 성능 저하 문제가 있다.  </p><p>strlcpy()는 OpenBSD 프로젝트를 통해 유래된 비표준 C 함수였다.<br>다른 점이 있다면 strlcpy()는 주어진 크기가 0이 아닌 모든 문자열에 대해 대상 문자열을 NUL 종료하도록 보장합니다.  </p><p>그리고 보통 strncpy()를 사용하면 strlen()를 사용하여 결과의 길이를 찾는 것이 일반적이기 마련인데, strlcpy()의 리턴 값을 결괏값의 길이로 하여 최종 strlen()을 찾는 것이 더 이상 필요하지 않는다.  </p><p>다음과 같은 strlcpy()의 예시를 작성해보았다.  </p><p><img src="/images/post/PM8_1.png" alt="PM8_1" title="PM8_1">  </p><p>아래와 같이 동작을 하고 마지막에 s - src - 1 (쓰레기값 - 기본값 - 널값)으로, 결과적으로는 src 문자열 길이를 리턴해준다.  </p><p><img src="/images/post/PM8_2.png" alt="PM8_2" title="PM8_2">  </p><h3 id="memcpy"><a href="#memcpy" class="headerlink" title="memcpy()"></a>memcpy()</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span>  <span class="hljs-comment">// C++ 에서는 &lt;cstring&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">void</span>* <span class="hljs-title">memcpy</span><span class="hljs-params">(<span class="hljs-type">void</span>* destination, <span class="hljs-type">const</span> <span class="hljs-type">void</span>* source, <span class="hljs-type">size_t</span> num)</span></span>;<br></code></pre></td></tr></table></figure><p>memcpy()는 source가 가리키는 곳 부터 num바이트 만큼을 destination에 복사한다.<br>(이 때, destination과 source의 타입은 모두 위 함수와 무관하다)  </p><p>strlcpy()와 다른점은 strncpy()와 같이 널 종료 문자(null terminating character)을 검사하지 않는다. num 바이트 만큼을 복사한다.  </p><h3 id="localFileName-가변-배열-선언"><a href="#localFileName-가변-배열-선언" class="headerlink" title="localFileName 가변 배열 선언?"></a>localFileName 가변 배열 선언?</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">const</span> <span class="hljs-type">size_t</span> fileNameLen = <span class="hljs-built_in">strlen</span>(fileName);<br><span class="hljs-type">char</span> localFileName[nativeLibPath.<span class="hljs-built_in">size</span>() + fileNameLen + <span class="hljs-number">2</span>];<br></code></pre></td></tr></table></figure><p>‘C99 표준’에서는 프로그램 실행 중에 크기가 변할 수 있는 배열인 VLA(Variable Length Array)를 지원한다고한다.  </p><p><img src="/images/post/PM8_3.png" alt="PM8_3" title="PM8_3">  </p><p>그래서 안드로이드 6.0.1을 빌드하기 위해서 필요한 gcc버전을 확인해보았는데, 4.8.4 버전을 사용하고 있었다.<br>gcc 4.8.4 버전의 메뉴얼을 확인해보았다.  </p><p><img src="/images/post/PM8_4.png" alt="PM8_4" title="PM8_4">  </p><p><img src="/images/post/PM8_5.png" alt="PM8_5" title="PM8_5">  </p><p>gcc계열의 컴파일러에서는(4.5이상) 가변 길이 배열에 대한 표준안이 채택되어 사용 중이다.  </p><p>우리가 평소에 윈도우에서 사용하는 Visual Studio는 C99 표준이 전부다 적용된 것이 아니라 가변 길이 배열은 사용이 불가능하다고 한다.  </p><h3 id="ScopedUtfChars"><a href="#ScopedUtfChars" class="headerlink" title="ScopedUtfChars"></a>ScopedUtfChars</h3><p>com_android_internal_content_NativeLibraryHelper.cpp에서 nativeLibPath가 ScopedUtfChars형을 갖게된다.<br>.c_str()와 .size()가 등장하는데, return값은 다음과 같다.  </p><p>const char* utf_chars_</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">const</span> <span class="hljs-type">char</span>* <span class="hljs-title">c_str</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123;<br>  <span class="hljs-keyword">return</span> utf_chars_;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">size_t</span> <span class="hljs-title">size</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-built_in">strlen</span>(utf_chars_);<br>&#125;<br></code></pre></td></tr></table></figure><p>함수 선언에 사용되는 const는 이 함수가 값을 변경하지 않음을 보장한다.  </p><p>nativeLibPath.size()는 문자열의 길이를 뜻하는 것.</p><h3 id="memcpy-로-변경"><a href="#memcpy-로-변경" class="headerlink" title="memcpy()로 변경?"></a>memcpy()로 변경?</h3><p>memcpy로 변경하기 위해서는 if문의 nativeLibPath.c_str() 길이와</p><p>기존 코드는 다음과 같다.  </p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-selector-tag">if</span> (<span class="hljs-built_in">strlcpy</span>(localFileName, nativeLibPath.<span class="hljs-built_in">c_str</span>(), <span class="hljs-built_in">sizeof</span>(localFileName)) != nativeLibPath.<span class="hljs-built_in">size</span>()) &#123;<br>    <span class="hljs-selector-tag">ALOGD</span>(<span class="hljs-string">&quot;Couldn&#x27;t allocate local file name for library&quot;</span>);<br>    <span class="hljs-selector-tag">return</span> <span class="hljs-selector-tag">INSTALL_FAILED_INTERNAL_ERROR</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>nativeLibPath.c_str()의 문자열 길이와 nativeLibPath.size()의 값을 비교하게 된다.  </p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-selector-tag">memcpy</span>(localFileName, nativeLibPath.<span class="hljs-built_in">c_str</span>(), <span class="hljs-built_in">sizeof</span>(localFileName))<br><span class="hljs-selector-tag">if</span>(<span class="hljs-built_in">strlen</span>(nativeLibPath.<span class="hljs-built_in">c_str</span>()) != nativeLibPath.<span class="hljs-built_in">size</span>()) &#123;<br>  <span class="hljs-selector-tag">ALOGD</span>(<span class="hljs-string">&quot;Couldn&#x27;t allocate local file name for library&quot;</span>);<br>  <span class="hljs-selector-tag">return</span> <span class="hljs-selector-tag">INSTALL_FAILED_INTERNAL_ERROR</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>로 변경한다면 같은 내용이 될 것같다…. 하지만.. 두 가지의 의문점이 있었다.<br>① memcpy()를 하고나서 strlen()을 한다면 속도의 개선이 있을지?<br>② nativeLibPath.c_str()의 문자열의 길이와 nativeLibPath.size()를 비교하는 의미를 잘 모르겠다. 결국에는 같은 것을 비교하는 꼴이라 if문 안으로 들어올 일이 전혀 없다고 생각한다.  </p><h3 id="strlcpy-를-커스텀"><a href="#strlcpy-를-커스텀" class="headerlink" title="strlcpy()를 커스텀?"></a>strlcpy()를 커스텀?</h3><p>그래서 memcpy를 사용하여 개선을 하는 것도 좋지만 다른 방법을 생각해보았다.<br>strlcpy() 자체를 커스텀해서 기존의 고치려는 코드는 그대로 냅두고, strlcpy.c 파일을 수정하는 방법도 괜찮을 것 같다.  </p><p>실제로 구글링 결과 아직 확인해보지는 못했지만, Implement strlcpy라는 글이 있는 것을 보아 충분히 가능할 것으로 보인다.  </p>]]></content>
    
    
    <categories>
      
      <category>Android</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Android</tag>
      
      <tag>안드로이드 프레임워크 개선</tag>
      
      <tag>PackageManager</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[안드로이드 프레임워크 개선] - PackageManager7</title>
    <link href="/PackageManager7/"/>
    <url>/PackageManager7/</url>
    
    <content type="html"><![CDATA[<h1 id="안드로이드-프레임워크-개선"><a href="#안드로이드-프레임워크-개선" class="headerlink" title="[안드로이드 프레임워크 개선]"></a>[안드로이드 프레임워크 개선]</h1><h2 id="PackageManager7"><a href="#PackageManager7" class="headerlink" title="PackageManager7"></a>PackageManager7</h2><p>시간이 오래걸리는 파트를 분석했고, 이번주는 시간이 오래 걸리는 파트에서 부르는 메소드를 분석하기로 했다.  </p><p>Version : android-6.0.1_r77<br>PackageManagerService.java  </p><p>소스 코드 : <a href="https://android.googlesource.com/platform/frameworks/base/+/refs/tags/android-6.0.1_r77/services/core/java/com/android/server/pm/PackageManagerService.java">https://android.googlesource.com/platform/frameworks/base/+/refs/tags/android-6.0.1_r77/services/core/java/com/android/server/pm/PackageManagerService.java</a>  </p><h3 id="derivePackageAbi"><a href="#derivePackageAbi" class="headerlink" title="derivePackageAbi()"></a>derivePackageAbi()</h3><p>Line : 7554 ~ 7685  </p><p>해당 메소드는 ABI를 결정하고 내부 앱인지를 판단하여 lib 라이브러리를 설치한다.<br>scanPackageDirtyLI에서 부르는 메소드로, 앱의 개수마다 불리게 되어 개선이 필요해 보인다.  </p><p>① setNativeLibraryPaths(pkg)를 호출하여 lib 디렉토리를 작성<br>(시스템에 내장 APK가있는 경우 system&#x2F;lib, vendor&#x2F;lib와 같은 시스템 APK 디렉토리에 lib 디렉토리를 작성하고)<br>(사용자가 APK를 설치하는 경우 data&#x2F;app-lib 아래의 pk 디렉토리와 같은 lib 디렉토리를 작성.)  </p><p>②-1 lib 라이브러리를 추출해야하는 경우, 즉 extractLibs가 true 인 경우 NativeLibraryHelper.copyNativeBinariesForSupportedAbi()를 호출하여 ABI를 일치시키고 ABI 디렉토리에 해당하는 lib 파일을 해당 디렉토리로 복사한다.  </p><p>②-2 lib 라이브러리가 필요하지 않은 경우, NativeLibraryHelper.findSupportedAbi()가 ABI와 일치하도록 호출된다.  </p><p><strong>새로 설치된 APK의 경우 lib 라이브러리를 추출해야 한다. 즉 extractLibs가 true.</strong>  </p><p>③ APKprimaryCpuAbi, secondaryCpuAbi를 설정한다.  </p><p><em>ABI란?</em><br><em>API보다 저수준(바이너리에서 호환) &#x2F; 두 개의 바이너리 프로그램 모듈 사이의 interface 이다. 보통 한 쪽은 라이브러리 혹은 운영체제이고, 다른 한 쪽은 사용자가 동작시키는 프로그램이다.</em>  </p><p>derivePackageAbi() 메소드에서 앱 마다 걸리는 시간을 측정 해 보기위해 다음과 같은 코드를 이용했다.  </p><p><img src="/images/post/PM7_1.png" alt="PM7_1" title="PM7_1">  </p><p>다음과 같은 시간이 걸렸으며, 설치된 앱 개수에 따라서 오랜 시간이 걸릴 것으로 예상된다.  </p><p><img src="/images/post/PM7_2.png" alt="PM7_2" title="PM7_2">  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">derivePackageAbi</span><span class="hljs-params">(PackageParser.Package pkg, File scanFile,</span><br><span class="hljs-params">                             String cpuAbiOverride, <span class="hljs-type">boolean</span> extractLibs)</span><br>        <span class="hljs-keyword">throws</span> PackageManagerException &#123;<br><br>        setNativeLibraryPaths(pkg); <span class="hljs-comment">// ① 호출하여 lib 디렉토리를 작성  </span><br><br>        <span class="hljs-keyword">if</span> (pkg.isForwardLocked() || pkg.applicationInfo.isExternalAsec() ||<br>                (isSystemApp(pkg) &amp;&amp; !pkg.isUpdatedSystemApp())) &#123;<br>            extractLibs = <span class="hljs-literal">false</span>; <span class="hljs-comment">// extractLibs 값 결정</span><br>        &#125;<br><br>        <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">nativeLibraryRootStr</span> <span class="hljs-operator">=</span> pkg.applicationInfo.nativeLibraryRootDir;<br>        <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-variable">useIsaSpecificSubdirs</span> <span class="hljs-operator">=</span> pkg.applicationInfo.nativeLibraryRootRequiresIsa;<br>        NativeLibraryHelper.<span class="hljs-type">Handle</span> <span class="hljs-variable">handle</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">try</span> &#123;<br>            handle = NativeLibraryHelper.Handle.create(scanFile);<br><br>            <span class="hljs-keyword">final</span> <span class="hljs-type">File</span> <span class="hljs-variable">nativeLibraryRoot</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(nativeLibraryRootStr);<br><br>            pkg.applicationInfo.primaryCpuAbi = <span class="hljs-literal">null</span>; <span class="hljs-comment">// ③ 설정해야 할 것</span><br>            pkg.applicationInfo.secondaryCpuAbi = <span class="hljs-literal">null</span>; <span class="hljs-comment">// ③ 설정해야 할 것</span><br><br>            <span class="hljs-keyword">if</span> (isMultiArch(pkg.applicationInfo)) &#123;<br><br>                <span class="hljs-keyword">if</span> (pkg.cpuAbiOverride != <span class="hljs-literal">null</span><br>                        &amp;&amp; !NativeLibraryHelper.CLEAR_ABI_OVERRIDE.equals(pkg.cpuAbiOverride)) &#123;<br>                    Slog.w(TAG, <span class="hljs-string">&quot;Ignoring abiOverride for multi arch application.&quot;</span>);<br>                &#125;<br><br>                <span class="hljs-type">int</span> <span class="hljs-variable">abi32</span> <span class="hljs-operator">=</span> PackageManager.NO_NATIVE_LIBRARIES;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">abi64</span> <span class="hljs-operator">=</span> PackageManager.NO_NATIVE_LIBRARIES;<br><br>                <span class="hljs-keyword">if</span> (Build.SUPPORTED_32_BIT_ABIS.length &gt; <span class="hljs-number">0</span>) &#123;<br>                    <span class="hljs-keyword">if</span> (extractLibs) &#123; <span class="hljs-comment">// ②-1, extractLibs가 true 인 경우</span><br>                        abi32 = NativeLibraryHelper.copyNativeBinariesForSupportedAbi(handle,<br>                                nativeLibraryRoot, Build.SUPPORTED_32_BIT_ABIS,<br>                                useIsaSpecificSubdirs);<br>                    &#125; <span class="hljs-keyword">else</span> &#123; ②-<span class="hljs-number">2</span>, extractLibs가 <span class="hljs-literal">false</span> 인 경우<br>                        abi32 = NativeLibraryHelper.findSupportedAbi(handle, Build.SUPPORTED_32_BIT_ABIS);<br>                    &#125;<br>                &#125;<br><br>                maybeThrowExceptionForMultiArchCopy(<br>                        <span class="hljs-string">&quot;Error unpackaging 32 bit native libs for multiarch app.&quot;</span>, abi32);<br><br>                <span class="hljs-keyword">if</span> (Build.SUPPORTED_64_BIT_ABIS.length &gt; <span class="hljs-number">0</span>) &#123;<br>                    <span class="hljs-keyword">if</span> (extractLibs) &#123; <span class="hljs-comment">// ②-1, extractLibs가 true 인 경우</span><br>                        abi64 = NativeLibraryHelper.copyNativeBinariesForSupportedAbi(handle,<br>                                nativeLibraryRoot, Build.SUPPORTED_64_BIT_ABIS,<br>                                useIsaSpecificSubdirs);<br>                    &#125; <span class="hljs-keyword">else</span> &#123; ②-<span class="hljs-number">2</span>, extractLibs가 <span class="hljs-literal">false</span> 인 경우<br>                        abi64 = NativeLibraryHelper.findSupportedAbi(handle, Build.SUPPORTED_64_BIT_ABIS);<br>                    &#125;<br>                &#125;<br><br>                maybeThrowExceptionForMultiArchCopy(<br>                        <span class="hljs-string">&quot;Error unpackaging 64 bit native libs for multiarch app.&quot;</span>, abi64);<br><br>                <span class="hljs-keyword">if</span> (abi64 &gt;= <span class="hljs-number">0</span>) &#123;<br>                    pkg.applicationInfo.primaryCpuAbi = Build.SUPPORTED_64_BIT_ABIS[abi64]; <span class="hljs-comment">// ③ ABI설정</span><br>                &#125;<br><br>                <span class="hljs-keyword">if</span> (abi32 &gt;= <span class="hljs-number">0</span>) &#123;<br>                    <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">abi</span> <span class="hljs-operator">=</span> Build.SUPPORTED_32_BIT_ABIS[abi32];<br>                    <span class="hljs-keyword">if</span> (abi64 &gt;= <span class="hljs-number">0</span>) &#123;<br>                        pkg.applicationInfo.secondaryCpuAbi = abi; <span class="hljs-comment">// ③ ABI설정</span><br>                    &#125; <span class="hljs-keyword">else</span> &#123;<br>                        pkg.applicationInfo.primaryCpuAbi = abi; <span class="hljs-comment">// ③ ABI설정</span><br>                    &#125;<br>                &#125;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                String[] abiList = (cpuAbiOverride != <span class="hljs-literal">null</span>) ?<br>                        <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>[] &#123; cpuAbiOverride &#125; : Build.SUPPORTED_ABIS;<br><br>                <span class="hljs-type">boolean</span> <span class="hljs-variable">needsRenderScriptOverride</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>                <span class="hljs-keyword">if</span> (Build.SUPPORTED_64_BIT_ABIS.length &gt; <span class="hljs-number">0</span> &amp;&amp; cpuAbiOverride == <span class="hljs-literal">null</span> &amp;&amp;<br>                        NativeLibraryHelper.hasRenderscriptBitcode(handle)) &#123;<br>                    abiList = Build.SUPPORTED_32_BIT_ABIS;<br>                    needsRenderScriptOverride = <span class="hljs-literal">true</span>;<br>                &#125;<br><br>                <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> copyRet;<br>                <span class="hljs-keyword">if</span> (extractLibs) &#123; <span class="hljs-comment">// ②-1, extractLibs가 true 인 경우</span><br>                    copyRet = NativeLibraryHelper.copyNativeBinariesForSupportedAbi(handle,<br>                            nativeLibraryRoot, abiList, useIsaSpecificSubdirs);<br>                &#125; <span class="hljs-keyword">else</span> &#123; ②-<span class="hljs-number">2</span>, extractLibs가 <span class="hljs-literal">false</span> 인 경우<br>                    copyRet = NativeLibraryHelper.findSupportedAbi(handle, abiList);<br>                &#125;<br>                <span class="hljs-keyword">if</span> (copyRet &lt; <span class="hljs-number">0</span> &amp;&amp; copyRet != PackageManager.NO_NATIVE_LIBRARIES) &#123;<br>                    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">PackageManagerException</span>(INSTALL_FAILED_INTERNAL_ERROR,<br>                            <span class="hljs-string">&quot;Error unpackaging native libs for app, errorCode=&quot;</span> + copyRet);<br>                &#125;<br>                <span class="hljs-keyword">if</span> (copyRet &gt;= <span class="hljs-number">0</span>) &#123;<br>                    pkg.applicationInfo.primaryCpuAbi = abiList[copyRet]; <span class="hljs-comment">// ③ ABI설정</span><br>                &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (copyRet == PackageManager.NO_NATIVE_LIBRARIES &amp;&amp; cpuAbiOverride != <span class="hljs-literal">null</span>) &#123;<br>                    pkg.applicationInfo.primaryCpuAbi = cpuAbiOverride; <span class="hljs-comment">// ③ ABI설정</span><br>                &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (needsRenderScriptOverride) &#123;<br>                    pkg.applicationInfo.primaryCpuAbi = abiList[<span class="hljs-number">0</span>]; <span class="hljs-comment">// ③ ABI설정</span><br>                &#125;<br>            &#125;<br>        &#125; <span class="hljs-keyword">catch</span> (IOException ioe) &#123;<br>            Slog.e(TAG, <span class="hljs-string">&quot;Unable to get canonical file &quot;</span> + ioe.toString());<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            IoUtils.closeQuietly(handle);<br>        &#125;<br><br>        setNativeLibraryPaths(pkg);<br>    &#125;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Android</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Android</tag>
      
      <tag>안드로이드 프레임워크 개선</tag>
      
      <tag>PackageManager</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[안드로이드 프레임워크 개선] - PackageManager6</title>
    <link href="/PackageManager6/"/>
    <url>/PackageManager6/</url>
    
    <content type="html"><![CDATA[<h1 id="안드로이드-프레임워크-개선"><a href="#안드로이드-프레임워크-개선" class="headerlink" title="[안드로이드 프레임워크 개선]"></a>[안드로이드 프레임워크 개선]</h1><h2 id="PackageManager6"><a href="#PackageManager6" class="headerlink" title="PackageManager6"></a>PackageManager6</h2><h3 id="scanPackageDirtyLI"><a href="#scanPackageDirtyLI" class="headerlink" title="scanPackageDirtyLI"></a>scanPackageDirtyLI</h3><p>Version : android-6.0.1_r77<br>PackageManagerService.java<br>Line : 6482 ~ 7545  </p><p>소스 코드 : <a href="https://android.googlesource.com/platform/frameworks/base/+/refs/tags/android-6.0.1_r77/services/core/java/com/android/server/pm/PackageManagerService.java">https://android.googlesource.com/platform/frameworks/base/+/refs/tags/android-6.0.1_r77/services/core/java/com/android/server/pm/PackageManagerService.java</a>  </p><p>PackageManagerService.java의 <strong>scanPackageDirtyLI</strong> 메소드 중 오래걸리는 파트를 확인하기 위해 다음과 같은 방법을 통해 로그를 찍었다.  </p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">long scanStart = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">SystemClock</span>.</span></span>uptime<span class="hljs-constructor">Millis()</span>;<br><br>:<br>:<br><br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Slog</span>.</span></span>i(TAG, <span class="hljs-string">&quot;Time to scan part 1: &quot;</span><br>                  + ((<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">SystemClock</span>.</span></span>uptime<span class="hljs-constructor">Millis()</span>-scanStart)/<span class="hljs-number">1000</span>f)<br>                  + <span class="hljs-string">&quot; seconds&quot;</span>);<br></code></pre></td></tr></table></figure><p>로그는 다음과 같이 출력되었으며 그 아래와 같이 평균을 내었다.  </p><p><img src="/images/post/PM6_1.png" alt="PM6_1" title="PM6_1">  </p><h5 id="파트1-6482-6555-평균-0-0004초"><a href="#파트1-6482-6555-평균-0-0004초" class="headerlink" title="파트1 - 6482 ~ 6555 : 평균 0.0004초"></a>파트1 - 6482 ~ 6555 : 평균 0.0004초</h5><h5 id="파트2-6565-6666-평균-0-0000714초"><a href="#파트2-6565-6666-평균-0-0000714초" class="headerlink" title="파트2 - 6565 ~ 6666 : 평균 0.0000714초"></a>파트2 - 6565 ~ 6666 : 평균 0.0000714초</h5><h5 id="파트3-6668-6822-평균-0-0000371초"><a href="#파트3-6668-6822-평균-0-0000371초" class="headerlink" title="파트3 - 6668 ~ 6822 : 평균 0.0000371초"></a>파트3 - 6668 ~ 6822 : 평균 0.0000371초</h5><h5 id="파트4-6824-6961-평균-0-0000928초"><a href="#파트4-6824-6961-평균-0-0000928초" class="headerlink" title="파트4 - 6824 ~ 6961 : 평균 0.0000928초"></a>파트4 - 6824 ~ 6961 : 평균 0.0000928초</h5><h5 id="파트5-6963-7148-평균-0-0315초"><a href="#파트5-6963-7148-평균-0-0315초" class="headerlink" title="파트5 - 6963 ~ 7148 : 평균 0.0315초"></a>파트5 - 6963 ~ 7148 : 평균 0.0315초</h5><h5 id="파트6-7153-7545-평균-0-0000714초"><a href="#파트6-7153-7545-평균-0-0000714초" class="headerlink" title="파트6 - 7153 ~ 7545 : 평균 0.0000714초"></a>파트6 - 7153 ~ 7545 : 평균 0.0000714초</h5><p>라는 결과를 얻었다. 로그를 통해서 파트5부분이 가장 오래걸리며, 해결이 시급한 부분으로 보인다.  </p><h3 id="6963-7148"><a href="#6963-7148" class="headerlink" title="6963 ~ 7148"></a>6963 ~ 7148</h3><p>가장 시간이 오래걸렸던 파트부분을 다시 세 부분으로 나누어서 시간을 측정했다.  </p><h5 id="파트1-6963-7023-평균-0-0161초"><a href="#파트1-6963-7023-평균-0-0161초" class="headerlink" title="파트1 - 6963 ~ 7023 : 평균 0.0161초"></a>파트1 - 6963 ~ 7023 : 평균 0.0161초</h5><h5 id="파트2-7029-7091-평균-0-0141초"><a href="#파트2-7029-7091-평균-0-0141초" class="headerlink" title="파트2 - 7029 ~ 7091 : 평균 0.0141초"></a>파트2 - 7029 ~ 7091 : 평균 0.0141초</h5><h5 id="파트3-7093-7148-평균-0초"><a href="#파트3-7093-7148-평균-0초" class="headerlink" title="파트3 - 7093 ~ 7148 : 평균 0초"></a>파트3 - 7093 ~ 7148 : 평균 0초</h5><p>라는 결과를 얻었다. 해당 시간값을 통해서 부팅속도 개선을 위한 영역을 좁힐 수 있었다.  </p>]]></content>
    
    
    <categories>
      
      <category>Android</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Android</tag>
      
      <tag>안드로이드 프레임워크 개선</tag>
      
      <tag>PackageManager</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[안드로이드 프레임워크 개선] - PackageManager5</title>
    <link href="/PackageManager5/"/>
    <url>/PackageManager5/</url>
    
    <content type="html"><![CDATA[<h1 id="안드로이드-프레임워크-개선"><a href="#안드로이드-프레임워크-개선" class="headerlink" title="[안드로이드 프레임워크 개선]"></a>[안드로이드 프레임워크 개선]</h1><h2 id="PackageManager5"><a href="#PackageManager5" class="headerlink" title="PackageManager5"></a>PackageManager5</h2><h3 id="scanPackageDirtyLI"><a href="#scanPackageDirtyLI" class="headerlink" title="scanPackageDirtyLI"></a>scanPackageDirtyLI</h3><p>지난주 빌드를 통해 로그를 출력하는 것을 성공했기 때문에 이번에는 PackageManagerService.java의 <strong>scanPackageDirtyLI</strong> 메소드를 분석하기로 했다.  </p><h3 id="scanPackageDirtyLI-분석"><a href="#scanPackageDirtyLI-분석" class="headerlink" title="scanPackageDirtyLI 분석"></a>scanPackageDirtyLI 분석</h3><p>Version : android-6.0.1_r77<br>PackageManagerService.java<br>Line : 6482 ~ 7545  </p><p>소스 코드 : <a href="https://android.googlesource.com/platform/frameworks/base/+/refs/tags/android-6.0.1_r77/services/core/java/com/android/server/pm/PackageManagerService.java">https://android.googlesource.com/platform/frameworks/base/+/refs/tags/android-6.0.1_r77/services/core/java/com/android/server/pm/PackageManagerService.java</a>  </p><p>일단 개선이 가능할 것 같다고 생각하는 부분에 대해서 작성 해 보았다.  </p><h4 id="1-Line-6638"><a href="#1-Line-6638" class="headerlink" title="1. Line : 6638"></a>1. Line : 6638</h4><p><img src="/images/post/PM5_1.png" alt="PM5_1" title="PM5_1">  </p><p>이 부분은 먼저, 6595번째 줄에서 pkg가 시스템 앱이 아닌 경우 다음과 같이 null로 지정해주었다.  </p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs 1c">if (!isSystemApp(pkg)) &#123;<br>    <span class="hljs-comment">// Only system apps can use these features.</span><br>    pkg.mOriginalPackages = <span class="hljs-literal">null</span>;<br>    pkg.mRealPackage = <span class="hljs-literal">null</span>;<br>    pkg.mAdoptPermissions = <span class="hljs-literal">null</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>그러면 시스템 앱이 아닌 사용자가 설치한 애플리케이션에 대해서 for문을 이용해 처음부터 끝까지 반복하게 되는데, 사용자가 설치한 앱이 많을 수록 많은 시간이 소요될 것으로 예상되며 개선할 수 있다고도 생각한다.  </p><h4 id="2-Line-6783"><a href="#2-Line-6783" class="headerlink" title="2. Line : 6783"></a>2. Line : 6783</h4><p><img src="/images/post/PM5_2.png" alt="PM5_2" title="PM5_2">  </p><p>이 부분도 마찬가지로 for문을 이용하여 0부터 N까지 반복한다. 이중 for문을 사용하기 떄문에 충분히 개선 할 수 있다고 생각한다.  </p><h4 id="3-Line-7228"><a href="#3-Line-7228" class="headerlink" title="3. Line : 7228"></a>3. Line : 7228</h4><p><img src="/images/post/PM5_3.png" alt="PM5_3" title="PM5_3">  </p><p>이 부분도 마찬가지로 for문을 이용하여 0부터 N까지 반복한다. 이중 for문을 사용하기 떄문에 충분히 개선 할 수 있다고 생각한다.  </p><h4 id="그외-개선과-관련된-생각"><a href="#그외-개선과-관련된-생각" class="headerlink" title="그외 개선과 관련된 생각.."></a>그외 개선과 관련된 생각..</h4><p>scanPackageDirtyLI 메소드에서 시스템 앱일 경우와 아닌 경우를 나누는 경우가 몇 번 존재했던 것 같다. 애초에 scanPackageDirtyLI를 두 개를 만들고 매개변수를 다르게 오버로딩하여 시스템 앱일 경우와 아닌 경우 다른 메소드를 실행하는 것은 어떨까?…  </p>]]></content>
    
    
    <categories>
      
      <category>Android</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Android</tag>
      
      <tag>안드로이드 프레임워크 개선</tag>
      
      <tag>PackageManager</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[안드로이드 프레임워크 개선] - PackageManager4</title>
    <link href="/PackageManager4/"/>
    <url>/PackageManager4/</url>
    
    <content type="html"><![CDATA[<h1 id="안드로이드-프레임워크-개선"><a href="#안드로이드-프레임워크-개선" class="headerlink" title="[안드로이드 프레임워크 개선]"></a>[안드로이드 프레임워크 개선]</h1><h2 id="PackageManager4"><a href="#PackageManager4" class="headerlink" title="PackageManager4"></a>PackageManager4</h2><h3 id="역할-분담"><a href="#역할-분담" class="headerlink" title="역할 분담"></a>역할 분담</h3><p>지난주 코드 분석을 통해서 우리는 PackageManagerService.java의 <strong>scanPackageDirtyLI</strong> 메소드, <strong>PackageParser.java</strong> 를 집중적으로 봐야겠다고 파악했다.<br>PackageManagerService.java 에서 PackageParser.java를 부르기 때문에, PackageParser.java를 먼저 보기로 했고, 1차적으로 다음과 같이 분담하여 분석을 하기로 했다.  </p><ol><li>parsePermission, parsePermissiongroup, parsePermissiontree  </li><li>parseActivity, parseActivityalias, parseProvider  </li><li>parseService, parsePackage, parseInstrumentation</li></ol><p>의 메소드를 중에서 나는 3번 service, package, instrumentation 메소드 리뷰를 맡았다.  </p><h3 id="PackageParser-java-분석"><a href="#PackageParser-java-분석" class="headerlink" title="PackageParser.java 분석"></a>PackageParser.java 분석</h3><p>Version : android-6.0.1_r77<br>PackageParser.java  </p><p>소스 코드 : <a href="https://android.googlesource.com/platform/frameworks/base/+/refs/tags/android-6.0.1_r77/core/java/android/content/pm/PackageParser.java">https://android.googlesource.com/platform/frameworks/base/+/refs/tags/android-6.0.1_r77/core/java/android/content/pm/PackageParser.java</a>  </p><p>위 9개의 메소드가 아래와 같이 동일한 형태를 보였다.  </p><h4 id="1-parseService-메소드"><a href="#1-parseService-메소드" class="headerlink" title="1. parseService 메소드"></a>1. parseService 메소드</h4><p>Line : 3779 ~ 3899  </p><p>해당 메소드는 새로운 Service 객체인 s를 생성하여 s의 info 값의 exported, permission, flags, processName을 설정하고 마지막에 s를 리턴한다.<br>(인자로 받은 패키지가 Heavy-weight applications이면 메인 프로세스에서 서비스할 수 없다는 에러를 가짐)  </p><h4 id="2-parsePackage-메소드"><a href="#2-parsePackage-메소드" class="headerlink" title="2. parsePackage 메소드"></a>2. parsePackage 메소드</h4><p>Line : 752 ~ 758  </p><p>해당 메소드는 인자로 받은 packageFile이 있으면(디렉토리가 존재하면) parseClusterPackage를 실행하고, 존재하지 않으면 parseMonolithicPackage를 실행한다.  </p><h5 id="2-1-parseClusterPackage-메소드"><a href="#2-1-parseClusterPackage-메소드" class="headerlink" title="2-1. parseClusterPackage 메소드"></a>2-1. parseClusterPackage 메소드</h5><p>Line : 769 ~ 814  </p><p>주어진 디렉토리를 받아 처리한다.  </p><p>해당 메소드는 Core App일 경우에만 동작하며, 패키지 이름, 버전 코드, base APK, split names(패키지 명 나눈 것)을 검사 후 Package를 리턴한다.  </p><h5 id="2-2-parseMonolithicPackage-메소드"><a href="#2-2-parseMonolithicPackage-메소드" class="headerlink" title="2-2. parseMonolithicPackage 메소드"></a>2-2. parseMonolithicPackage 메소드</h5><p>Line : 827 ~ 834  </p><p>2-1과 다르게 주어진 APK파일을 받아 처리한다.  </p><p>해당 메소드는 Core App일 경우에만 동작하며, parseBaseApk를 통해 얻은 Package를 리턴한다.  </p><h4 id="3-parseInstrumentation-메소드"><a href="#3-parseInstrumentation-메소드" class="headerlink" title="3. parseInstrumentation 메소드"></a>3. parseInstrumentation 메소드</h4><p>Line : 2339 ~ 2397  </p><p>안드로이드에서 Instrumentation는 테스트 중인 어플리케이션을 컨트롤 하고 상태를 확인할 수 있도록 제공하는 프레임워크 라고한다.  </p><p>해당 메소드는 Instrumentation인 a를 생성해서targetPackage, handleProfiling, functionalTest 값을 채워 에러가 없는경우 a를 리턴하고 에러가 있는경우 null을 리턴한다.  </p><h3 id="빌드-후-플래싱-재시도"><a href="#빌드-후-플래싱-재시도" class="headerlink" title="빌드 후 플래싱 재시도"></a>빌드 후 플래싱 재시도</h3><p>지난번 빌드에서 제대로 빌드하여 디바이스에 플래싱 되었는지 제대로 확인할 수 없었다.<br>빌드가 제대로 확인되었는지 보기 위해 PackageManagerService.java의 scanDirLI메소드의 Log를 이용하여 확인했다.  </p><p><img src="/images/post/PM4_1.png" alt="PM4_1" title="PM4_1">  </p><p>DEBUG_PACKAGE_SCANNING 플래그 부분의 if문을 벗겨내고, TEST용 로그를 추가하여 재빌드했다.  </p><p><img src="/images/post/PM4_2.png" alt="PM4_2" title="PM4_2">  </p><p>로그를 확인해보니, 아래와 같이 정상적으로 출력이 되었다. 빌드와 플래싱이 제대로 되는 것을 확인할 수 있었다.  </p><p><img src="/images/post/PM4_3.png" alt="PM4_3" title="PM4_3">  </p><h3 id="scanPackageDirtyLI-메소드-분석-및-향후-계획"><a href="#scanPackageDirtyLI-메소드-분석-및-향후-계획" class="headerlink" title="scanPackageDirtyLI 메소드 분석 및 향후 계획"></a>scanPackageDirtyLI 메소드 분석 및 향후 계획</h3><p>현재 scanPackageDirtyLI 메소드를 정밀하게 분석하기 위해 다음과 같이 주석을 달아놓은 상태이다.  </p><p><img src="/images/post/PM4_4.png" alt="PM4_4" title="PM4_4">  </p><p>PackageParser.java를 일부만 봤을 때는 특별한 점이나 개선해야 할 부분이 있는지 확인하지 못했다.<br>플래싱이 제대로 되는것을 확인했기 때문에 먼저 scanPackageDirtyLI 메소드를 정밀하게 분석하고 개선할 사항이 있는지 분석할 예정이다.  </p>]]></content>
    
    
    <categories>
      
      <category>Android</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Android</tag>
      
      <tag>안드로이드 프레임워크 개선</tag>
      
      <tag>PackageManager</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[안드로이드 프레임워크 개선] - PackageManager3</title>
    <link href="/PackageManager3/"/>
    <url>/PackageManager3/</url>
    
    <content type="html"><![CDATA[<h1 id="안드로이드-프레임워크-개선"><a href="#안드로이드-프레임워크-개선" class="headerlink" title="[안드로이드 프레임워크 개선]"></a>[안드로이드 프레임워크 개선]</h1><h2 id="PackageManager3"><a href="#PackageManager3" class="headerlink" title="PackageManager3"></a>PackageManager3</h2><h3 id="역할-분담"><a href="#역할-분담" class="headerlink" title="역할 분담"></a>역할 분담</h3><p>우리는 지난주에 이어 빌드한 내용을 넥서스 5 디바이스에 플래싱 하기로 하였다.<br>우여곡절 끝에 플래싱 한 디바이스는 벽돌이 되어서, 일단 역할 분담을 하고 프로젝트를 계속 진행하기로 하였다.  </p><ol><li>넥서스 5 플래싱 진행.  </li><li>PackageManagerService.java의 생성자 파트 코드 리뷰.  </li><li>‘DEBUG_PACKAGE_SCANNING’ 플래그가 포함된 파트 리뷰.</li></ol><p>이 중에서 나는 3번 ‘DEBUG_PACKAGE_SCANNING’ 플래그가 포함된 파트 리뷰를 맡았다.  </p><h3 id="코드-분석"><a href="#코드-분석" class="headerlink" title="코드 분석"></a>코드 분석</h3><p>Version : android-6.0.1_r77<br>PackageManagerService.java  </p><p>소스 코드 : <a href="https://android.googlesource.com/platform/frameworks/base/+/refs/tags/android-6.0.1_r77/services/core/java/com/android/server/pm/PackageManagerService.java">https://android.googlesource.com/platform/frameworks/base/+/refs/tags/android-6.0.1_r77/services/core/java/com/android/server/pm/PackageManagerService.java</a>  </p><p>DEBUG_PACKAGE_SCANNING 플래그는 2개의 메소드안에서 다루어지고 있다.  </p><h4 id="1-scanDirLI-메소드"><a href="#1-scanDirLI-메소드" class="headerlink" title="1. scanDirLI 메소드"></a>1. scanDirLI 메소드</h4><p>Line : 5625 ~ 5662   </p><p><strong>scanDirLI</strong>는 <strong>PackageManagerService</strong>에서 패키지들을 synchronized 할 때 사용된다.  </p><p>해당 메소드는 directory 내의 package를 확인한 후 package별로 <strong>scanPackageLI</strong>를 수행하며, 인스톨에 실패한 invalid package를 삭제한다.  </p><p>DEBUG_PACKAGE_SCANNING 플래그가 true일 경우에는 스캐닝 중인 app의 directory, scanFlags, parseFlags를 로그로 출력한다.  </p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs gradle"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> scanDirLI(<span class="hljs-keyword">File</span> dir, <span class="hljs-keyword">int</span> parseFlags, <span class="hljs-keyword">int</span> scanFlags, <span class="hljs-keyword">long</span> currentTime) &#123;<br>    <span class="hljs-keyword">final</span> <span class="hljs-keyword">File</span>[] files = dir.listFiles();<br>    <span class="hljs-keyword">if</span> (ArrayUtils.isEmpty(files)) &#123;<br>        Log.d(TAG, <span class="hljs-string">&quot;No files in app dir &quot;</span> + dir);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>     <span class="hljs-comment">//  Scanning 로그 출력  //</span><br>    <span class="hljs-keyword">if</span> (DEBUG_PACKAGE_SCANNING) &#123;<br>        Log.d(TAG, <span class="hljs-string">&quot;Scanning app dir &quot;</span> + dir + <span class="hljs-string">&quot; scanFlags=&quot;</span> + scanFlags<br>                + <span class="hljs-string">&quot; flags=0x&quot;</span> + Integer.toHexString(parseFlags));<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">File</span> <span class="hljs-keyword">file</span> : files) &#123;<br>        <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> isPackage = (isApkFile(<span class="hljs-keyword">file</span>) || <span class="hljs-keyword">file</span>.isDirectory())<br>                &amp;&amp; !PackageInstallerService.isStageName(<span class="hljs-keyword">file</span>.getName());<br>        <span class="hljs-keyword">if</span> (!isPackage) &#123;<br>            <span class="hljs-comment">// Ignore entries which are not packages</span><br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br>        <span class="hljs-keyword">try</span> &#123;<br>            scanPackageLI(<span class="hljs-keyword">file</span>, parseFlags | PackageParser.PARSE_MUST_BE_APK,<br>                    scanFlags, currentTime, <span class="hljs-keyword">null</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (PackageManagerException e) &#123;<br>            Slog.w(TAG, <span class="hljs-string">&quot;Failed to parse &quot;</span> + <span class="hljs-keyword">file</span> + <span class="hljs-string">&quot;: &quot;</span> + e.getMessage());<br>            <span class="hljs-comment">// Delete invalid userdata apps</span><br>            <span class="hljs-keyword">if</span> ((parseFlags &amp; PackageParser.PARSE_IS_SYSTEM) == <span class="hljs-number">0</span> &amp;&amp;<br>                    e.error == PackageManager.INSTALL_FAILED_INVALID_APK) &#123;<br>                logCriticalInfo(Log.WARN, <span class="hljs-string">&quot;Deleting invalid package at &quot;</span> + <span class="hljs-keyword">file</span>);<br>                <span class="hljs-keyword">if</span> (<span class="hljs-keyword">file</span>.isDirectory()) &#123;<br>                    mInstaller.rmPackageDir(<span class="hljs-keyword">file</span>.getAbsolutePath());<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    <span class="hljs-keyword">file</span>.<span class="hljs-keyword">delete</span>();<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="2-scanPackageDirtyLI-메소드"><a href="#2-scanPackageDirtyLI-메소드" class="headerlink" title="2. scanPackageDirtyLI 메소드"></a>2. scanPackageDirtyLI 메소드</h4><p>Line : 6482 ~ 7545  </p><p><strong>scanPackageDirtyLI</strong>는 <strong>scanPackageLI</strong>에서 부르며, <strong>scanPackageLI</strong>는 <strong>scanDirLI</strong>에서 부른다.  </p><p>해당 메소드는 인자로 받은 package를 분석하여 다시 return한다.<br>(분석 내용은 패키지 업데이트 여부, codePath, partition(system partition or data partition), certificate, 버전 체크 등등)  </p><p>DEBUG_PACKAGE_SCANNING 플래그가 true일 경우에는 다음을 로그로 출력한다.<br><em>line 6545 - 스캐닝 중인 app의 name</em><br><em>line 6572 - PackageSetting 값이 있을 때, Package의 codePath, 세팅값의 codePathString, resourcePathString</em><br><em>line 6611 - Package의 mSharedUserId가 null이 아닌 경우, Package의 mSharedUserId, 세팅값의 userId, packages</em><br><em>line 6939 - normal package이며 해당 directory가 존재하지 않을 경우</em><br><em>line 7259 - Package의 Provider가 존재할때? provider 이름, info name, Syncable한지</em><br><em>line 7285 - Providers의 info.name</em><br><em>line 7305 - Services의 info.name</em><br><em>line 7325 - receivers의 info.name</em><br><em>line 7345 - activities의 info.name</em><br><em>line 7379 - permissionGroups의 info.name</em><br><em>line 7480 - Permissions의 info.name</em><br><em>line 7508 - Instrumentation의 info.name</em>   </p><p>아래 코드는 내용이 많기 때문에, DEBUG_PACKAGE_SCANNING 플래그가 포함된 부분만 발췌  </p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br></pre></td><td class="code"><pre><code class="hljs gradle"><span class="hljs-keyword">private</span> PackageParser.<span class="hljs-keyword">Package</span> scanPackageDirtyLI(PackageParser.<span class="hljs-keyword">Package</span> pkg, <span class="hljs-keyword">int</span> parseFlags,<br>        <span class="hljs-keyword">int</span> scanFlags, <span class="hljs-keyword">long</span> currentTime, UserHandle user) <span class="hljs-keyword">throws</span> PackageManagerException &#123;<br>    <span class="hljs-comment">//  Scanning 로그 출력  //</span><br>    <span class="hljs-keyword">if</span> (DEBUG_PACKAGE_SCANNING) &#123;<br>      <span class="hljs-keyword">if</span> ((parseFlags &amp; PackageParser.PARSE_CHATTY) != <span class="hljs-number">0</span>) <span class="hljs-comment">// PackageParser</span><br>          Log.d(TAG, <span class="hljs-string">&quot;Scanning package &quot;</span> + pkg.packageName);<br>    &#125;<br><br>    :<br>    :<br><br>    <span class="hljs-keyword">if</span> ((scanFlags &amp; SCAN_REQUIRE_KNOWN) != <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">if</span> (mExpectingBetter.containsKey(pkg.packageName)) &#123;<br>            logCriticalInfo(Log.WARN,<br>                    <span class="hljs-string">&quot;Relax SCAN_REQUIRE_KNOWN requirement for package &quot;</span> + pkg.packageName);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            PackageSetting known = mSettings.peekPackageLPr(pkg.packageName);<br>            <span class="hljs-keyword">if</span> (known != <span class="hljs-keyword">null</span>) &#123;<br>                <span class="hljs-comment">//  Scanning 로그 출력  //</span><br>                <span class="hljs-keyword">if</span> (DEBUG_PACKAGE_SCANNING) &#123;<br>                    Log.d(TAG, <span class="hljs-string">&quot;Examining &quot;</span> + pkg.codePath<br>                            + <span class="hljs-string">&quot; and requiring known paths &quot;</span> + known.codePathString<br>                            + <span class="hljs-string">&quot; &amp; &quot;</span> + known.resourcePathString);<br>                &#125;<br>                <span class="hljs-keyword">if</span> (!pkg.applicationInfo.getCodePath().equals(known.codePathString)<br>                        || !pkg.applicationInfo.getResourcePath().equals(known.resourcePathString)) &#123;<br>                    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> PackageManagerException(INSTALL_FAILED_PACKAGE_CHANGED,<br>                            <span class="hljs-string">&quot;Application package &quot;</span> + pkg.packageName<br>                            + <span class="hljs-string">&quot; found at &quot;</span> + pkg.applicationInfo.getCodePath()<br>                            + <span class="hljs-string">&quot; but expected at &quot;</span> + known.codePathString + <span class="hljs-string">&quot;; ignoring.&quot;</span>);<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    :<br>    :<br><br>    <span class="hljs-keyword">synchronized</span> (mPackages) &#123;<br>        <span class="hljs-keyword">if</span> (pkg.mSharedUserId != <span class="hljs-keyword">null</span>) &#123;<br>            suid = mSettings.getSharedUserLPw(pkg.mSharedUserId, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-keyword">true</span>);<br>            <span class="hljs-keyword">if</span> (suid == <span class="hljs-keyword">null</span>) &#123;<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> PackageManagerException(INSTALL_FAILED_INSUFFICIENT_STORAGE,<br>                        <span class="hljs-string">&quot;Creating application package &quot;</span> + pkg.packageName<br>                        + <span class="hljs-string">&quot; for shared user failed&quot;</span>);<br>            &#125;<br>            <span class="hljs-comment">//  Scanning 로그 출력  //</span><br>            <span class="hljs-keyword">if</span> (DEBUG_PACKAGE_SCANNING) &#123;<br>                <span class="hljs-keyword">if</span> ((parseFlags &amp; PackageParser.PARSE_CHATTY) != <span class="hljs-number">0</span>) <span class="hljs-comment">// PackageParser</span><br>                    Log.d(TAG, <span class="hljs-string">&quot;Shared UserID &quot;</span> + pkg.mSharedUserId + <span class="hljs-string">&quot; (uid=&quot;</span> + suid.userId<br>                            + <span class="hljs-string">&quot;): packages=&quot;</span> + suid.packages);<br>            &#125;<br>        &#125;<br><br>        :<br>        :<br>    &#125;<br><br>    :<br>    :<br><br>    <span class="hljs-keyword">if</span> (mPlatformPackage == pkg) &#123;<br>        <span class="hljs-comment">// The system package is special.</span><br>        dataPath = <span class="hljs-keyword">new</span> <span class="hljs-keyword">File</span>(Environment.getDataDirectory(), <span class="hljs-string">&quot;system&quot;</span>);<br>        pkg.applicationInfo.dataDir = dataPath.getPath();<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-comment">// This is a normal package, need to make its data directory.</span><br>      dataPath = Environment.getDataUserPackageDirectory(pkg.volumeUuid,<br>              UserHandle.USER_OWNER, pkg.packageName);<br>      <span class="hljs-keyword">boolean</span> uidError = <span class="hljs-keyword">false</span>;<br>      <span class="hljs-keyword">if</span> (dataPath.exists()) &#123;<br><br>        :<br>        :<br><br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">//  Scanning 로그 출력  //</span><br>            <span class="hljs-keyword">if</span> (DEBUG_PACKAGE_SCANNING) &#123;<br>                <span class="hljs-keyword">if</span> ((parseFlags &amp; PackageParser.PARSE_CHATTY) != <span class="hljs-number">0</span>) <span class="hljs-comment">// PackageParser</span><br>                    Log.v(TAG, <span class="hljs-string">&quot;Want this data dir: &quot;</span> + dataPath);<br>            &#125;<br>            <span class="hljs-comment">//invoke installer to do the actual installation</span><br>            <span class="hljs-keyword">int</span> ret = createDataDirsLI(pkg.volumeUuid, pkgName, pkg.applicationInfo.uid,<br>                    pkg.applicationInfo.seinfo);<br>            <span class="hljs-keyword">if</span> (ret &lt; <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-comment">// Error from installer</span><br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> PackageManagerException(INSTALL_FAILED_INSUFFICIENT_STORAGE,<br>                        <span class="hljs-string">&quot;Unable to create data dirs [errorCode=&quot;</span> + ret + <span class="hljs-string">&quot;]&quot;</span>);<br>            &#125;<br>            <span class="hljs-keyword">if</span> (dataPath.exists()) &#123;<br>                pkg.applicationInfo.dataDir = dataPath.getPath();<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                Slog.w(TAG, <span class="hljs-string">&quot;Unable to create data directory: &quot;</span> + dataPath);<br>                pkg.applicationInfo.dataDir = <span class="hljs-keyword">null</span>;<br>            &#125;<br>        &#125;<br><br><br>    :<br>    :<br><br>    <span class="hljs-comment">// writer</span><br>    <span class="hljs-keyword">synchronized</span> (mPackages) &#123;<br>        <span class="hljs-comment">// We don&#x27;t expect installation to fail beyond this point</span><br><br>        :<br>        :<br><br>        <span class="hljs-keyword">int</span> N = pkg.providers.<span class="hljs-keyword">size</span>();<br>        StringBuilder r = <span class="hljs-keyword">null</span>;<br>        <span class="hljs-keyword">int</span> i;<br>        <span class="hljs-keyword">for</span> (i=<span class="hljs-number">0</span>; i&lt;N; i++) &#123;<br><br>          :<br>          :<br><br>          String names[] = p.info.authority.split(<span class="hljs-string">&quot;;&quot;</span>);<br>          p.info.authority = <span class="hljs-keyword">null</span>;<br>          <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; names.length; j++) &#123;<br><br>            :<br>            :<br><br>            <span class="hljs-keyword">if</span> (!mProvidersByAuthority.containsKey(names[j])) &#123;<br>                mProvidersByAuthority.put(names[j], p);<br>                <span class="hljs-keyword">if</span> (p.info.authority == <span class="hljs-keyword">null</span>) &#123;<br>                    p.info.authority = names[j];<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    p.info.authority = p.info.authority + <span class="hljs-string">&quot;;&quot;</span> + names[j];<br>                &#125;<br>                <span class="hljs-comment">//  Scanning 로그 출력  //</span><br>                <span class="hljs-keyword">if</span> (DEBUG_PACKAGE_SCANNING) &#123;<br>                    <span class="hljs-keyword">if</span> ((parseFlags &amp; PackageParser.PARSE_CHATTY) != <span class="hljs-number">0</span>) <span class="hljs-comment">// PackageParser</span><br>                        Log.d(TAG, <span class="hljs-string">&quot;Registered content provider: &quot;</span> + names[j]<br>                                + <span class="hljs-string">&quot;, className = &quot;</span> + p.info.name + <span class="hljs-string">&quot;, isSyncable = &quot;</span><br>                                + p.info.isSyncable);<br>                &#125;<br>            &#125;<br>          &#125;<br>        &#125;<br><br>        <span class="hljs-comment">//  Scanning 로그 출력  //</span><br>        <span class="hljs-keyword">if</span> (r != <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-keyword">if</span> (DEBUG_PACKAGE_SCANNING) Log.d(TAG, <span class="hljs-string">&quot;  Providers: &quot;</span> + r);<br>        &#125;<br><br>        N = pkg.services.<span class="hljs-keyword">size</span>();<br>        r = <span class="hljs-keyword">null</span>;<br>        <span class="hljs-keyword">for</span> (i=<span class="hljs-number">0</span>; i&lt;N; i++) &#123;<br>            PackageParser.Service s = pkg.services.get(i); <span class="hljs-comment">// PackageParser</span><br>            s.info.processName = fixProcessName(pkg.applicationInfo.processName,<br>                    s.info.processName, pkg.applicationInfo.uid);<br>            mServices.addService(s);<br>            <span class="hljs-keyword">if</span> ((parseFlags&amp;PackageParser.PARSE_CHATTY) != <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-keyword">if</span> (r == <span class="hljs-keyword">null</span>) &#123;<br>                    r = <span class="hljs-keyword">new</span> StringBuilder(<span class="hljs-number">256</span>);<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    r.<span class="hljs-keyword">append</span>(<span class="hljs-string">&#x27; &#x27;</span>);<br>                &#125;<br>                r.<span class="hljs-keyword">append</span>(s.info.name);<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-comment">//  Scanning 로그 출력  //</span><br>        <span class="hljs-keyword">if</span> (r != <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-keyword">if</span> (DEBUG_PACKAGE_SCANNING) Log.d(TAG, <span class="hljs-string">&quot;  Services: &quot;</span> + r);<br>        &#125;<br><br>        :<br>        :<br><br>        <span class="hljs-comment">//  이런식으로 Receivers, Activities, Permission Groups, Permissions, Instrumentation로그 출력   //</span><br><br>        :<br>        :<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>전체적인 흐름을 보았는데, 스캐닝에 관련된 내용 중 개선을 한다면 <strong>scanPackageDirtyLI</strong> 부분을 더 보거나<br>PackageParser의 내용이 많이 나오는데, <strong>PackageParser.java</strong>를 정밀하게 보는 것이 좋을 것 같다.  </p><h3 id="디바이스-플래싱"><a href="#디바이스-플래싱" class="headerlink" title="디바이스 플래싱"></a>디바이스 플래싱</h3><p>보유하고 있는 기기인 넥서스 5에 플래싱 완료하였다.  </p><p><img src="/images/post/PM3_1.png" alt="PM3_1" title="PM3_1">  </p><p>다음에는 이전에 사용하려고 했던 갤럭시 A8 (SM-A800S)도 순정 펌웨어를 받아 플래싱 해보려고 한다.  </p>]]></content>
    
    
    <categories>
      
      <category>Android</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Android</tag>
      
      <tag>안드로이드 프레임워크 개선</tag>
      
      <tag>PackageManager</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[안드로이드 프레임워크 개선] - PackageManager2</title>
    <link href="/PackageManager2/"/>
    <url>/PackageManager2/</url>
    
    <content type="html"><![CDATA[<h1 id="안드로이드-프레임워크-개선"><a href="#안드로이드-프레임워크-개선" class="headerlink" title="[안드로이드 프레임워크 개선]"></a>[안드로이드 프레임워크 개선]</h1><h2 id="PackageManager2"><a href="#PackageManager2" class="headerlink" title="PackageManager2"></a>PackageManager2</h2><h3 id="디바이스-선정"><a href="#디바이스-선정" class="headerlink" title="디바이스 선정"></a>디바이스 선정</h3><p>지난주 adb shell과 안드로이드 스튜디오를 통한 logcat을 출력할 때는 갤럭시 A8 2016 (SM-A800S) 기기를 임시로 사용하였다.  </p><p>팀원들과 회의 결과 코드를 수정하고 빌드하는 데 구글 레퍼런스 디바이스를 사용하는 것이 좋다고 판단하였다.<br>우리가 개선하고자 하는 안드로이드 버전은 6.0.1 버전으로 현재 보유하고 있는 갤럭시 넥서스는 해당 버전을 지원하지 않았다.  </p><p>우리는 넥서스 5를 테스트 및 개선을 위한 디바이스로 선정하였고, 앞으로 해당 디바이스를 통해 개선을 진행한다.  </p><p>운영체제 및 버전 : Android 6.0.1_r77  </p><h3 id="빌드-환경-구성"><a href="#빌드-환경-구성" class="headerlink" title="빌드 환경 구성"></a>빌드 환경 구성</h3><p>빌드 환경 구성은 아래의 블로그를 참고했다.<br><a href="https://gamdekong.tistory.com/55?category=763105">https://gamdekong.tistory.com/55?category=763105</a>  </p><h4 id="repo-설치"><a href="#repo-설치" class="headerlink" title="repo 설치"></a>repo 설치</h4><p>보유하고 있는 넥서스 5에 포팅하기 위한 android-6.0.1_r77 버전의 AOSP 소스를 받아온다.  </p><p><img src="/images/post/PM2_1.png" alt="PM2_1" title="PM2_1">  </p><p>소스를 받아온 후 빌드하기 위한 프로그램을 설치하고, mk파일을 수정한다.  </p><h4 id="빌드-make"><a href="#빌드-make" class="headerlink" title="빌드(make)"></a>빌드(make)</h4><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">make</span><br></code></pre></td></tr></table></figure><p>명령어를 통해 빌드를 수행한다.  </p><p><img src="/images/post/PM2_2.png" alt="PM2_2" title="PM2_2">  </p><p>빌드 완료 후 에뮬레이터를 실행한다.<br>나와 같은 경우는 터미널이 바로 꺼지는 경우가 발생해서, 구동 시 마다 환경 설정을 다시 했다.  </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">source</span> build/envsetup.sh<br>lunch aosp_arm-eng<br>emulator &amp;<br></code></pre></td></tr></table></figure><p><img src="/images/post/PM2_3.png" alt="PM2_3" title="PM2_3">  </p><h3 id="코드-수정-및-빌드"><a href="#코드-수정-및-빌드" class="headerlink" title="코드 수정 및 빌드"></a>코드 수정 및 빌드</h3><p>우리는 PackageManager 부분의 Package Scanning 시간을 줄이는 방식을 통해 개선을 수행하고자 하기 때문에, Scanning log를 보기위해 PackageManagerService.java 코드를 수정 후 빌드해야 한다.  </p><p><a href="https://android.googlesource.com/platform/frameworks/base/+/a029ea1/services/java/com/android/server/pm/PackageManagerService.java#189">https://android.googlesource.com/platform/frameworks/base/+/a029ea1/services/java/com/android/server/pm/PackageManagerService.java#189</a> 소스를 보게 되면,  </p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-keyword">private</span> <span class="hljs-type">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> DEBUG_PACKAGE_SCANNING = <span class="hljs-literal">false</span>;<br></code></pre></td></tr></table></figure><p>의 DEBUG flag값이 있다. 이 값을 true로 해놓고 빌드해서 올려 package scanning에 관련된 로그를 확인하는 것이 목표이다.  </p><p>다음과 같이 수정 후 make 명령어를 통해 빌드 하였다.  </p><p><img src="/images/post/PM2_4.png" alt="PM2_4" title="PM2_4">  </p><h3 id="Scanning-결과"><a href="#Scanning-결과" class="headerlink" title="Scanning 결과"></a>Scanning 결과</h3><p>디바이스에 올려서 확인하기 전, 우선 에뮬레이터를 이용해서 로그값을 확인했다.  </p><p><img src="/images/post/PM2_5.png" alt="PM2_5" title="PM2_5">  </p><p><img src="/images/post/PM2_6.png" alt="PM2_6" title="PM2_6">  </p><p>Scanning에 관련된 로그들이 출력된 것을 확인할 수 있었다.  </p><p>하지만 PackageManagerService.java 코드를 살펴보니, Scanning에 관련된 다른 로그들도 출력되어야 할 것 같은데, 다른 로그들은 출력되지 않았다.  </p><h4 id="더-찾아봐야-할-로그들"><a href="#더-찾아봐야-할-로그들" class="headerlink" title="더 찾아봐야 할 로그들"></a>더 찾아봐야 할 로그들</h4><p>DEBUG flag값을 따라서 어떤 로그들이 출력되어야 하는지 확인해보았다.  </p><p>DEBUG_PACKAGE_SCANNING을 true로 변경했기 때문에, 관련 조건문에 있는 로그들은 다음과 같다.  </p><ul><li>Log.d(TAG, “Scanning app dir “ + dir + “ scanMode&#x3D;” + scanMode + “ flags&#x3D;0x” + Integer.toHexString(flags));  </li><li>Log.d(TAG, “Scanning package “ + pkg.packageName);  </li><li>Log.d(TAG, “Shared UserID “ + pkg.mSharedUserId + “ (uid&#x3D;” + suid.userId + “): packages&#x3D;” + suid.packages);  </li><li>Log.v(TAG, “Want this data dir: “ + dataPath);  </li><li>Log.d(TAG, “Registered content provider: “ + names[j] + “, className &#x3D; “ + p.info.name + “, isSyncable &#x3D; “ + p.info.isSyncable);  </li><li>Log.d(TAG, “  Providers: “ + r);  </li><li>Log.d(TAG, “  Services: “ + r);  </li><li>Log.d(TAG, “  Receivers: “ + r);  </li><li>Log.d(TAG, “  Activities: “ + r);  </li><li>Log.d(TAG, “  Permission Groups: “ + r);  </li><li>Log.d(TAG, “  Permissions: “ + r);  </li><li>Log.d(TAG, “  Instrumentation: “ + r);</li></ul>]]></content>
    
    
    <categories>
      
      <category>Android</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Android</tag>
      
      <tag>안드로이드 프레임워크 개선</tag>
      
      <tag>PackageManager</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[안드로이드 프레임워크 개선] - PackageManager</title>
    <link href="/PackageManager1/"/>
    <url>/PackageManager1/</url>
    
    <content type="html"><![CDATA[<h1 id="안드로이드-프레임워크-개선"><a href="#안드로이드-프레임워크-개선" class="headerlink" title="[안드로이드 프레임워크 개선]"></a>[안드로이드 프레임워크 개선]</h1><h2 id="PackageManager"><a href="#PackageManager" class="headerlink" title="PackageManager"></a>PackageManager</h2><h3 id="주제-선정"><a href="#주제-선정" class="headerlink" title="주제 선정"></a>주제 선정</h3><p>지난 학기 동안 ‘인사이드 안드로이드’ 책을 통해서 안드로이드의 구조에 대해서 전반적으로 파악하는 시간을 가졌다.<br>또한 6월 1일에 진행되었던, 이원영 선배님께서 멘토링을 통하여 Common Framework에 대한 내용과 개선을 어떻게 진행하면 좋을지에 대하여 다루어 주셨다.<br>우리 팀은 이를 종합하여 기존에 설정하였던 전반적인 안드로이드 개선에 대한 주제를 구체화하기로 했다.  </p><h4 id="부팅시간-개선"><a href="#부팅시간-개선" class="headerlink" title="부팅시간 개선"></a>부팅시간 개선</h4><p>우리는 부팅시간 개선이라는 주제를 선정하였다.<br>이를 위하여 여러 가지 방법이 있겠지만, 부팅시간에 영향을 줄만한 Package Scanning 시간을 줄이는 것을 세부 목표로 잡았다.<br>Scanning 시간을 줄이기 위해서 PackageManager 쪽 코드를 공부해보고 Package Scanning 시간에 불필요한 Scanning을 하는지를 알아보려고 한다.  </p><h5 id="부팅-로그-출력"><a href="#부팅-로그-출력" class="headerlink" title="부팅 로그 출력"></a>부팅 로그 출력</h5><p>먼저, 부팅 시에 Package Scanning에 대한 흐름을 보아야 한다.<br>단말기를 재부팅시키고 로그를 확인해보는 과정을 가졌다.  </p><p>이를 확인하고자 하는 단말기는 갤럭시 A8 2016 (SM-A800S)으로, 6.0.1 버전으로 다운그레이드 하였다.<br>먼저, 안드로이드 스튜디오의 Logcat기능을 통해서 로그를 확인해보았다.<br>PackageManager로 태그를 걸어 PackageManager부분만 확인한 결과는 다음과 같다.  </p><p><img src="/images/post/PM1_1.png" alt="PM1_1" title="PM1_1">  </p><p>이 방법을 사용할 때는 단말기가 꺼져있을 때 오프라인으로 되어있어, 부팅 중 로그를 출력하지 못하는 것 같다.  </p><p>다음 방법으로 adb shell을 이용하여 로그를 출력해보았다.  </p><p><img src="/images/post/PM1_2.png" alt="PM1_2" title="PM1_2">  </p><p>안드로이드 구조를 공부했던 것 처럼 먼저 start init process 부분이 있었다.<br>더 내려가서 확인해보니, 우리가 확인해야할 부분인 PackageManager 부분을 확인할 수 있었다.  </p><p><img src="/images/post/PM1_3.png" alt="PM1_3" title="PM1_3">  </p><p>Start PackageManagerService  </p><p><img src="/images/post/PM1_4.png" alt="PM1_4" title="PM1_4">  </p><p>End PackageManagerService  </p><p>다음 주 부터는 로그를 확인하여 불필요한 Scanning이 있는지 분석할 예정이다.  </p><h5 id="adb-shell-명령어"><a href="#adb-shell-명령어" class="headerlink" title="adb shell 명령어"></a>adb shell 명령어</h5><p>adb shell의 명령어 같은 경우에는 안드로이드 개발자 문서에 설명되어 있다.  </p><p><a href="https://developer.android.com/studio/command-line/adb?hl=ko#shellcommands">https://developer.android.com/studio/command-line/adb?hl=ko#shellcommands</a>  </p><h3 id="Android-Package-Manager-and-Package-Installer"><a href="#Android-Package-Manager-and-Package-Installer" class="headerlink" title="Android Package Manager and Package Installer"></a>Android Package Manager and Package Installer</h3><p>원문 : <a href="http://kpbird.blogspot.com/2012/10/in-depth-android-package-manager-and.html">http://kpbird.blogspot.com/2012/10/in-depth-android-package-manager-and.html</a>  </p><h4 id="Package-Manager와-Package-Installer는-무엇인가"><a href="#Package-Manager와-Package-Installer는-무엇인가" class="headerlink" title="Package Manager와 Package Installer는 무엇인가?"></a>Package Manager와 Package Installer는 무엇인가?</h4><p>PackageInstaller는 Android에 Package를 설치하는 기본 Application이다.<br>PackageInstaller는 Application&#x2F;Package를 관리하기 위한 사용자 인터페이스를 제공한다.<br>PackageInstaller는 InstallAppProgress Activity를 호출해 사용자의 명령을 전달받는다.  </p><p>InstallAppProgress는 indalld를 통해 Package 설치를 Package Manager Service에게 요청한다.<br>소스코드는 <Android Source>&#x2F;packages&#x2F;apps&#x2F;PackageInstaller 에서 확인할 수 있다.  </p><p>installd 데몬의 가장 중요한 역할은 Linux 데몬 소켓인 &#x2F;dev &#x2F;socket &#x2F;installed를 통해 Package Manager Service로 부터 요청을 받는 것이다. installd는 Root Permission으로 APK 설치를 위한 단계를 수행하게 된다.<br>[Ref: <a href="https://github.com/android/platform_frameworks_base/blob/master/cmds/installd/commands.c]">https://github.com/android/platform_frameworks_base/blob/master/cmds/installd/commands.c]</a>  </p><p>PackageManager는 Application 설치, 삭제, 업그레이드를 위한 API이다.<br>APK파일을 설치할 때, PackageManager는 Package (APK) 파일을 분석해 확인창을 보여주고, OK 버튼을 누르면 PackageManager가 4개의 Parameter를 갖는 InstallPackage 메소드를 호출한다. (Paramter : uri, installFlags, observer, installPackageName)   PackageManager는 Package 서비스를 실행하고 Package 서비스에서 분산이 이루어진다.<br>PackageInstaller 소스코드의 “PackageInstallerActivity.java” 와 “InstallAppProgress.java”를 확인해 보자.<br>system_service 프로세스로 동작하는 Package Manager 서비스와 install 데몬 (installd)은 system 부팅 시점에 native process로 동작한다.  </p><h4 id="Package-Manager와-Package-Installer의-소스코드를-어디서-찾을-수-있는가"><a href="#Package-Manager와-Package-Installer의-소스코드를-어디서-찾을-수-있는가" class="headerlink" title="Package Manager와 Package Installer의 소스코드를 어디서 찾을 수 있는가?"></a>Package Manager와 Package Installer의 소스코드를 어디서 찾을 수 있는가?</h4><p>&lt; Package Manager &gt;<br>frameworks&#x2F;base&#x2F;services&#x2F;java&#x2F;com&#x2F;android&#x2F;server&#x2F;pm&#x2F;Settings.java<br>frameworks&#x2F;base&#x2F;services&#x2F;java&#x2F;com&#x2F;android&#x2F;server&#x2F;pm&#x2F;PackageManagerService.java<br>frameworks&#x2F;base&#x2F;services&#x2F;java&#x2F;com&#x2F;android&#x2F;server&#x2F;pm&#x2F;IPackageManager.aidl<br>frameworks&#x2F;base&#x2F;services&#x2F;java&#x2F;com&#x2F;android&#x2F;server&#x2F;pm&#x2F;PackageSignatures.java<br>frameworks&#x2F;base&#x2F;services&#x2F;java&#x2F;com&#x2F;android&#x2F;server&#x2F;pm&#x2F;PreferredActivity.java<br>frameworks&#x2F;services&#x2F;java&#x2F;com&#x2F;android&#x2F;server&#x2F;PreferredComponent.java<br>frameworks&#x2F;core&#x2F;java&#x2F;android&#x2F;content&#x2F;IntentFilter.java<br>frameworks&#x2F;base&#x2F;core&#x2F;java&#x2F;android&#x2F;content&#x2F;pm&#x2F;PackageParser.java<br>frameworks&#x2F;base&#x2F;services&#x2F;java&#x2F;com&#x2F;android&#x2F;server&#x2F;pm&#x2F;Installer.java<br>frameworks&#x2F;base&#x2F;core&#x2F;java&#x2F;com&#x2F;android&#x2F;internal&#x2F;app&#x2F;IMediaContainerService.aidl<br>frameworks&#x2F;base&#x2F;packages&#x2F;DefaultContainerService&#x2F;src&#x2F;com&#x2F;android&#x2F;defcontainer&#x2F;DefaultContainerService.java  </p><p>&lt; Package Installer &gt;<br>packages&#x2F;apps&#x2F;PackageInstaller&#x2F;src&#x2F;com&#x2F;android&#x2F;packageinstaller&#x2F;PackageInstallerActivity.java<br>packages&#x2F;apps&#x2F;PackageInstaller&#x2F;src&#x2F;com&#x2F;android&#x2F;packageinstaller&#x2F;PackageUtil.java<br>packages&#x2F;apps&#x2F;PackageInstaller&#x2F;src&#x2F;com&#x2F;android&#x2F;packageinstaller&#x2F;InstallAppProgress.java  </p>]]></content>
    
    
    <categories>
      
      <category>Android</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Android</tag>
      
      <tag>안드로이드 프레임워크 개선</tag>
      
      <tag>PackageManager</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[인사이드 안드로이드] 챕터 11 - 자바 시스템 서비스 동작 분석</title>
    <link href="/chapter11/"/>
    <url>/chapter11/</url>
    
    <content type="html"><![CDATA[<h1 id="인사이드-안드로이드"><a href="#인사이드-안드로이드" class="headerlink" title="[인사이드 안드로이드]"></a>[인사이드 안드로이드]</h1><h2 id="Chapter11-자바-시스템-서비스-동작-분석"><a href="#Chapter11-자바-시스템-서비스-동작-분석" class="headerlink" title="Chapter11 - 자바 시스템 서비스 동작 분석"></a>Chapter11 - 자바 시스템 서비스 동작 분석</h2><h3 id="액티비티-매니저-서비스"><a href="#액티비티-매니저-서비스" class="headerlink" title="액티비티 매니저 서비스"></a>액티비티 매니저 서비스</h3><p>액티비티 매니저 서비스는 자바 시스템 서비스의 일종인 코어 플랫폼 서비스로서 안드로이드 애플리케이션 컴포넌트인 액티비티, 서비스, 브로드캐스트 리시버등을 생성하고, 이들의 생명주기를 관리하는 역할을 한다.  </p><p>ApiDemos 예제 코드에 들어있는 Remote Service Controller 애플리케이션을 토대로 액티비티 매니저 서비스가 안드로이드의 애플리케이션 서비스를 어떻게 생성하고 해당 서비스의 생명주기를 어떻게 제어하는지 알아본다.  </p><p><img src="/images/post/JS1.png" alt="JS1" title="JS1">  </p><p>Remote Service Controller 예제 애플리케이션은 별도의 프로세스를 통해 리모트 서비스를 실행하는 예제로 ⑴ ‘Start Service’ 버튼을 누르면 ⑵ RemoteService가 시작되는 간단한 프로그램이다.  </p><p><img src="/images/post/JS2.png" alt="JS2" title="JS2">  </p><p>⑴ 안드로이드 애플리케이션은 startService()나 bindService() API를 통해 애플리케이션 서비스를 생성한다.<br>⑵ 애플리케이션으로부터 startService()를 통해 서비스 실행 요청을 받은 액티비 매니저 서비스는 요청받은 서비스 클래스(RemoteService.class)를 바로 로드하는 것이 아니라 Zygote에게 서비스를 실행시키기 위한 ActivityThread 생성을 요청한다.<br>⑶ 액티비티 매니저 서비스로부터 ActivityThread 실행을 요청받은 Zygote는 새로운 프로세스를 생성한 다음 그위에 ActivityThread 클래스를 로딩한다.<br>⑷ ActivityThread에게 RemoteService 서비스의 생성을 요청한다.<br>⑸ ActivityThread는 RemoteService를 실행한다.  </p><p>이렇듯 안드로이드의 액티비티 매니저 서비스는 애플리케이션 서비스를 포함한 액티비티, 브로드캐스트 리시버 같은 안드로이드 애플리케이션 컴포넌트를 생성하는 중요한 역할을 하는 시스템 서비스다.  </p><h3 id="액티비티-매니저-서비스를-통한-서비스-생성-코드-분석"><a href="#액티비티-매니저-서비스를-통한-서비스-생성-코드-분석" class="headerlink" title="액티비티 매니저 서비스를 통한 서비스 생성 코드 분석"></a>액티비티 매니저 서비스를 통한 서비스 생성 코드 분석</h3><p>액티비티가 startService() API 메서드를 호출할 경우 액티비티 매니저 서비스가 어떻게 애플리케이션 서비스를 생성하는지 소스 코드를 바탕으로 자세히 살펴보자  </p><h4 id="Controller-액티비티-startService-메서드-호출"><a href="#Controller-액티비티-startService-메서드-호출" class="headerlink" title="Controller 액티비티 - startService() 메서드 호출"></a>Controller 액티비티 - startService() 메서드 호출</h4><p>⑴과 같이 ‘Start Servcie’ 버튼을 누르면 코드 11-1의 이벤트 핸들러가 호출된다. 이 경우 단순히 인텐트(intent)를 인자로 startService() API 메서드를 호출한다.  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-type">OnClickListener</span> <span class="hljs-variable">mStartListener</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">OnClickListener</span>() &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onClick</span><span class="hljs-params">(View v)</span> &#123;<br>        startService(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Intent</span>(<span class="hljs-string">&quot;com.example.android.apis.app.REMOTE_SERVICE&quot;</span>));<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="액티비티-매니저-서비스의-startService-메서드-호출-과정-바인더-RPC-활용"><a href="#액티비티-매니저-서비스의-startService-메서드-호출-과정-바인더-RPC-활용" class="headerlink" title="액티비티 매니저 서비스의 startService() 메서드 호출 과정(바인더 RPC 활용)"></a>액티비티 매니저 서비스의 startService() 메서드 호출 과정(바인더 RPC 활용)</h4><p>액티비티에서 호출한 startService() API는 서비스 생성 및 실행과 관련된 내용을 액티비티 매니저 서비스에 요청하는 기능만 수행할 뿐 실제 구현은 액티비티 매니저 서비스에 속한, 동일한 이름을 가진 startService() 스텁 메서드에 들어 있다.  </p><p>즉, 액티비티에서 호출한 startService() API는 자바 서비스 프레임워크 기반에서 바인더 RPC 형태로 액티비티 매니저 서비스에서 제공하는 startService() 스텁 메서드를 호출하게 되는 것이다.  </p><p><img src="/images/post/JS3.png" alt="JS3" title="JS3">  </p><p>⑴ Controller 액티비티 - ActivityManagerProxy 객체의 startService() 프록시 메서드를 호출<br>⑵ ActivityManagerProxy 객체 - 자바 서비스 프레임워크를 통해 ActivityManagerNative 객체에 START_SERVICE_TRANSACTION RPC 코드와 바인더 RPC 데이터를 전송<br>⑶ ActivityManagerNative 객체 - ActivityManagerService에 포함된 startService() 스텁 메서드를 호출  </p><h5 id="⑴-Controller-액티비티"><a href="#⑴-Controller-액티비티" class="headerlink" title="⑴ Controller 액티비티"></a>⑴ Controller 액티비티</h5><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs scala">public <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ContextWrapper</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Context</span> </span>&#123;<br>    <span class="hljs-type">Context</span> mBase;<br><br>    public <span class="hljs-type">ComponentName</span> startService(<span class="hljs-type">Intent</span> service) &#123;<br>        <span class="hljs-keyword">return</span> mBase.startService(service); <span class="hljs-comment">// ContextImpl 객체의 startService() 메서드 호출</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>ContextWrapper는 context 추상 클래스를 확장한 클래스로 멤버 변수 mBase에 저장된 context 객체를 래핑(wrapping)하는 역할을 한다. 현재 ContextWrapper 객체는 그림에서 볼 수 있듯이 Controller 액티비티의 ContextImpl 객체를 래핑하고 있다.  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> ComponentName <span class="hljs-title function_">startService</span><span class="hljs-params">(Intent service)</span> &#123;<br>    <span class="hljs-type">ComponentName</span> <span class="hljs-variable">cn</span> <span class="hljs-operator">=</span> ActivityManagerNative.getDefault().startService(<br>                          mMainThread.getApplicationThread(), service,<br>                          service.resolveTypeIfNeeded(getContentResolver()));<br><br>    <span class="hljs-keyword">return</span> cn;<br>&#125;<br></code></pre></td></tr></table></figure><p>다음 그림은 위 코드의 핵심 부분인 ActivityManagerNative.getDefault().startService()의 과정을 나타낸다. 아래 그림에서도 확인할 수 있듯이 ActivityManagerNative.getDefault() 함수는 결국 ActivityManagerProxy 객체를 반환하는데 이 객체는 액티비티 매니저 서비스가 제공하는 IActivityManager 서비스 인터페이스 기반의 메서드들을 바인더 RPC 를 통해서 호출하는 역할을 한다. 따라서 액티비티 측에서는 이 객체를 통해 startService() 스텁 메서드처럼 액티비티 매니저 서비스가 제공하는 IActivityManager 인터페이스에 포함된 다양한 메서드를 로컬 함수를 호출하듯 자유롭게 이용할 수 있다.  </p><p><img src="/images/post/JS4.png" alt="JS4" title="JS4">  </p><p>따라서 ActivityManagerNative.getDefault().startService() 메서드는 ActivityManagerProxy 클래스의 startService() 프록시 메서드를 호출한다. 이는 결국 ActivityManagerService의 startService() 스텁 메서드를 원격으로 호출하는 역할을 수행한다.  </p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">public ComponentName start<span class="hljs-constructor">Service(IApplicationThread <span class="hljs-params">caller</span>, Intent <span class="hljs-params">service</span>, String <span class="hljs-params">resolvedType</span>)</span><br></code></pre></td></tr></table></figure><p>startService() 메서드의 주요 인자를 간단히 살펴보면 첫 번째 인자인 caller는 IApplicationThread 타입의 변수로서 액티비티 매니저 서비스로부터 전송된 IApplicationThread 서비스 인터페이스 기반의 바인더 RPC 를 처리하는 역할을 수행한다.  </p><h5 id="⑵-ActivityManagerProxy-객체-startService-프록시-메서드-처리"><a href="#⑵-ActivityManagerProxy-객체-startService-프록시-메서드-처리" class="headerlink" title="⑵ ActivityManagerProxy 객체 - startService() 프록시 메서드 처리"></a>⑵ ActivityManagerProxy 객체 - startService() 프록시 메서드 처리</h5><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs haskell"><span class="hljs-title">public</span> <span class="hljs-type">ComponentName</span> startService(<span class="hljs-type">IApplicationThread</span> caller, <span class="hljs-type">Intent</span> service,<br>        <span class="hljs-type">String</span> resolvedType) throws <span class="hljs-type">RemoteException</span><br>&#123;<br>    <span class="hljs-type">Parcel</span> <span class="hljs-class"><span class="hljs-keyword">data</span> = <span class="hljs-type">Parcel</span>.obtain();</span><br>    <span class="hljs-type">Parcel</span> reply = <span class="hljs-type">Parcel</span>.obtain();<br><br>    // 전송 <span class="hljs-class"><span class="hljs-keyword">data</span> 생성 (인자값을 <span class="hljs-title">data</span>에 저장)</span><br>    <span class="hljs-class"><span class="hljs-keyword">data</span>.writeInterfaceToken(<span class="hljs-type">IActivityManager</span>.<span class="hljs-title">descriptor</span>);</span><br>    <span class="hljs-class"><span class="hljs-keyword">data</span>.writeStrongBinder(<span class="hljs-title">caller</span> != <span class="hljs-title">null</span> ? <span class="hljs-title">caller</span>.<span class="hljs-title">asBinder</span>() : null);</span><br>    service.writeToParcel(<span class="hljs-class"><span class="hljs-keyword">data</span>, 0);</span><br>    <span class="hljs-class"><span class="hljs-keyword">data</span>.writeString(<span class="hljs-title">resolvedType</span>);</span><br><br>    // 바인더 <span class="hljs-type">RPC</span> 데이터 전송<br>    mRemote.transact(<span class="hljs-type">START_SERVICE_TRANSACTION</span>, <span class="hljs-class"><span class="hljs-keyword">data</span>, reply, 0);</span><br>    reply.readException();<br>    <span class="hljs-type">ComponentName</span> res = <span class="hljs-type">ComponentName</span>.readFromParcel(reply);<br>    <span class="hljs-class"><span class="hljs-keyword">data</span>.recycle();</span><br>    reply.recycle();<br><br>    return res;<br>&#125;<br></code></pre></td></tr></table></figure><p>위 코드에서 mRemote.transact() 메서드는 자바 객체에서 바인더 RPC 데이터를 전송하는 데 쓰인다. ActivityManagerProxy 객체는 startService() 프록시 메서드의 인자로 전달된 caller, service, resolved에 들어 있는 값을 바인더 RPC 데이터를 저장하는 데 사용되는 Pacel 객체 변수인 data에 저장한다. 그런 다음 START_SERVICE_TRANSACTION 트랜잭션을 통해 저장한 data 값을 ActivityManagerNative 객체에 전달한다.  </p><h5 id="⑶-ActivityManagerNative-객체-startService-스텁-메서드-호출"><a href="#⑶-ActivityManagerNative-객체-startService-스텁-메서드-호출" class="headerlink" title="⑶ ActivityManagerNative 객체 - startService() 스텁 메서드 호출"></a>⑶ ActivityManagerNative 객체 - startService() 스텁 메서드 호출</h5><p>ActivityManagerNative 객체는 상대편인 ActivityManagerProxy 객체에게서 전달받은 RPC 코드를 토대로 액티비티 매니저 서비스에서 호출한 스텁 매서드를 파악한다. 여기서는 ActivityManagerProxy 객체가 START_SERVICE_TRANSACTION RPC코드를 전송했으므로 아래 코드에서 볼 수 있듯이 startService() 스텁 메서드가 호출돼야 한다.  </p><p>다음은 startService() 스텁 메서드에 전달해야 할 인자를 구해서 startService() 스텁 메서드를 실제로 호출하면 된다. 이를 위해 RPC 데이터를 언마샬링한 후, 액티비티 매니저 서비스의 startService() 스텁 메서드를 호출한다.  </p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs haskell"><span class="hljs-title">public</span> boolean onTransact(int code, <span class="hljs-type">Parcel</span> <span class="hljs-class"><span class="hljs-keyword">data</span>, <span class="hljs-type">Parcel</span> reply, int flags)</span><br>        throws <span class="hljs-type">RemoteException</span> &#123;<br>    switch (code) &#123;<br>    <span class="hljs-keyword">case</span> <span class="hljs-type">START_ACTIVITY_TRANSACTION</span>:<br>    &#123;<br>        <span class="hljs-class"><span class="hljs-keyword">data</span>.enforceInterface(<span class="hljs-type">IActivityManager</span>.<span class="hljs-title">descriptor</span>);</span><br>        <span class="hljs-type">IBinder</span> b = <span class="hljs-class"><span class="hljs-keyword">data</span>.readStrongBinder();</span><br>        <span class="hljs-type">IApplicationThread</span> app = <span class="hljs-type">ApplicationThreadNative</span>.asInterface(b);<br>        <span class="hljs-type">Intent</span> intent = <span class="hljs-type">Intent</span>.<span class="hljs-type">CREATOR</span>.createFromParcel(<span class="hljs-class"><span class="hljs-keyword">data</span>);</span><br>        <span class="hljs-type">String</span> resolvedType = <span class="hljs-class"><span class="hljs-keyword">data</span>.readString();</span><br><br>        <span class="hljs-type">Uri</span>[] grantedUriPermissions = <span class="hljs-class"><span class="hljs-keyword">data</span>.createTypedArray(<span class="hljs-type">Uri</span>.<span class="hljs-type">CREATOR</span>);</span><br>        int grantedMode = <span class="hljs-class"><span class="hljs-keyword">data</span>.readInt();</span><br>        <span class="hljs-type">IBinder</span> resultTo = <span class="hljs-class"><span class="hljs-keyword">data</span>.readStrongBinder();</span><br>        <span class="hljs-type">String</span> resultWho = <span class="hljs-class"><span class="hljs-keyword">data</span>.readString();    </span><br>        int requestCode = <span class="hljs-class"><span class="hljs-keyword">data</span>.readInt();</span><br>        boolean onlyIfNeeded = <span class="hljs-class"><span class="hljs-keyword">data</span>.readInt() != 0;</span><br>        boolean debug = <span class="hljs-class"><span class="hljs-keyword">data</span>.readInt() != 0;</span><br>        <span class="hljs-type">String</span> profileFile = <span class="hljs-class"><span class="hljs-keyword">data</span>.readString();</span><br>        <span class="hljs-type">ParcelFileDescriptor</span> profileFd = <span class="hljs-class"><span class="hljs-keyword">data</span>.readInt() != 0</span><br>                ? <span class="hljs-class"><span class="hljs-keyword">data</span>.readFileDescriptor() : null;</span><br>        boolean autoStopProfiler = <span class="hljs-class"><span class="hljs-keyword">data</span>.readInt() != 0;</span><br>        int result = startActivity(app, intent, resolvedType,<br>                grantedUriPermissions, grantedMode, resultTo, resultWho,<br>                requestCode, onlyIfNeeded, debug, profileFile, profileFd, autoStopProfiler);<br>        reply.writeNoException();<br>        reply.writeInt(result);<br>        return true;<br>    &#125;<br>    :<br>    return super.onTransact(code, <span class="hljs-class"><span class="hljs-keyword">data</span>, reply, flags);</span><br>&#125;<br></code></pre></td></tr></table></figure><p>onTransact() 메서드의 역할은 아래 그림과 같이 ActivityManagerProxy의 startService() 프록시 메서드의 인자 값(caller, service, resolvedType)이 마샬링된 data 변수(Parcel 객체)를 바인더 RPC를 통해 수신한 다음, data 변수를 언마샬링하고 각 데이터를 별도의 변수에 저장하는 것이다. 그러고 나서 저장된 변수를 인자로 삼아 액티비티 매니저 서비스의 startService() 스텁 메서드를 호출하는 것이다.  </p><p><img src="/images/post/JS5.png" alt="JS5" title="JS5">  </p><p>아래 코드에 대해 살펴보면,</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">IApplicationThread app = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">ApplicationThreadNative</span>.</span></span><span class="hljs-keyword">as</span><span class="hljs-constructor">Interface(<span class="hljs-params">b</span>)</span>;<br></code></pre></td></tr></table></figure><p>ApplicationThreadNative.asInterface() 메서드는 ApplicationThreadNative 객체에 대응하는 ApplicationThreadProxy 객체를 생성한다. 그러고 나면 서비스 생성을 요청한 RemoteActivityController 액티비티와 액티비티 매니저 서비스 간에는 다음 그림과 같이 두 개의 바인더 연결이 성립된다. 액티비티는 IActivityManager 서비스 인터페이스 기반의 바인더 RPC를 통해 서비스 실행, 인텐트 송수신 등의 기능 수행을 요청할 수 있다. 반대로 액티비티 매니저 서비스는 IApplicationThread 인터페이스 기반의 바인더 RPC를 통해 자신과 연결된 애플리케이션을 제어할 수 있다.  </p><p><img src="/images/post/JS6.png" alt="JS6" title="JS6">  </p><h4 id="액티비티-매니저-서비스-startService-스텁-메서드-실행"><a href="#액티비티-매니저-서비스-startService-스텁-메서드-실행" class="headerlink" title="액티비티 매니저 서비스 - startService() 스텁 메서드 실행"></a>액티비티 매니저 서비스 - startService() 스텁 메서드 실행</h4><p>이제 액티비티 매니저 서비스가 요청받은 서비스를 어떻게 실행하는지 살펴본다.  </p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-function"><span class="hljs-keyword">public</span> ComponentName <span class="hljs-title">startService</span><span class="hljs-params">(IApplicationThread caller, Intent service,</span></span><br><span class="hljs-params"><span class="hljs-function">        <span class="hljs-type">String</span> resolvedType, <span class="hljs-type">int</span> userId)</span> </span>&#123;<br><br>        <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> callingPid = Binder.<span class="hljs-built_in">getCallingPid</span>();<br>        <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> callingUid = Binder.<span class="hljs-built_in">getCallingUid</span>();<br>        <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> origId = Binder.<span class="hljs-built_in">clearCallingIdentity</span>();<br>        ComponentName res = mServices.<span class="hljs-built_in">startServiceLocked</span>(caller, service,<br>                resolvedType, callingPid, callingUid, userId);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br></code></pre></td></tr></table></figure><p>이 메서드에서 주로 하는 일은 startServiceLocked() 메서드를 호출하는 것이다.  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java">ComponentName <span class="hljs-title function_">startServiceLocked</span><span class="hljs-params">(IApplicationThread caller, Intent service, String</span><br><span class="hljs-params">            resolvedType, <span class="hljs-type">int</span> callingPid, <span class="hljs-type">int</span> callingUid, <span class="hljs-type">int</span> userId)</span> &#123;<br>    <span class="hljs-comment">// retrieveServiceLocked() 메서드의 반환값인 ServiceLookupResult 구조체 변수 res로부터 ServiceRecord 값을 얻는다.</span><br>    <span class="hljs-type">ServiceLookupResult</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span><br>            retrieveServiceLocked(service, resolvedType,<br>                    callingPid, callingUid, userId, <span class="hljs-literal">true</span>, callerFg);<br>    <span class="hljs-type">ServiceRecord</span> <span class="hljs-variable">r</span> <span class="hljs-operator">=</span> res.record;<br>    <span class="hljs-keyword">return</span> startServiceInnerLocked(smap, service, r, callerFg, addToStarting);<br>&#125;<br></code></pre></td></tr></table></figure><p>이 메서드에서 주로 하는 일은 ServiceRecord 값을 얻는 것이다. ServiceRecord는 안드로이드 애플리케이션 서비스에 대한 각종 정보(서비스 패키지명과 위치, 권한, 서비스 프로세스 정보, 실행 통계 정보 등)가 담긴 클래스이다.  </p><p>이렇게 구한 ServiceRecord 객체를 bringUpServiceLocked() 메서드의 첫 번째 인자로 전달한다.  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String <span class="hljs-title function_">bringUpServiceLocked</span><span class="hljs-params">(ServiceRecord r, <span class="hljs-type">int</span> intentFlags,</span><br><span class="hljs-params">            <span class="hljs-type">boolean</span> execInFg, <span class="hljs-type">boolean</span> whileRestarting)</span> &#123;<br><br>    <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">appName</span> <span class="hljs-operator">=</span> r.processName;<br>    <span class="hljs-type">ProcessRecord</span> <span class="hljs-variable">app</span> <span class="hljs-operator">=</span> getProcessRecordLocked(appName, r.appInfo.uid);<br><br>    <span class="hljs-keyword">if</span> (app != <span class="hljs-literal">null</span> &amp;&amp; app.thread != <span class="hljs-literal">null</span>) &#123;<br>          <span class="hljs-comment">// 기존 프로세스 영역 내에서 서비스를 실행함.</span><br>          realStartServiceLocked(r, app, execInFg);<br>          <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br><br>    startProcessLocked(appName, r.appInfo, <span class="hljs-literal">true</span>, intentFlags, <span class="hljs-string">&quot;service&quot;</span>, r.name, <span class="hljs-literal">false</span>);<br>    mPendingServices.add(r);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>bringUpServiceLocked() 메서드는 ServiceRecord 객체를 참조해서 해당 서비스가 실행된 프로세스 이름과 uid를 통해 ProcessRecord 객체가 존재하는지 검사한다. 이를 위해 getProcessRecordLocked() 메서드가 호출된다.  </p><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs processing"><span class="hljs-keyword">final</span> ProcessRecord <span class="hljs-title function_">startProcessLocked</span>(<span class="hljs-built_in">String</span> processName, ApplicationInfo info,<br>            <span class="hljs-type">boolean</span> knownToBeDead, <span class="hljs-type">int</span> intentFlags, <span class="hljs-built_in">String</span> hostingType, ComponentName hostingName,<br>            <span class="hljs-type">boolean</span> allowWhileBooting) &#123;<br>                <span class="hljs-comment">// ProcessRecord를 새로 생성</span><br>                app = <span class="hljs-title function_">getProcessRecordLocked</span>(<span class="hljs-literal">null</span>, info, processName);<br>                mProcessNames.<span class="hljs-property">put</span>(processName, info.<span class="hljs-property">uid</span>, app);<br>                <span class="hljs-title function_">startProcessLocked</span>(app, hostingType, hostingNameStr);<br><br>                <span class="hljs-title function_">return</span> (app.<span class="hljs-property">pid</span> != <span class="hljs-number">0</span>) ? app : <span class="hljs-literal">null</span>;<br>            &#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">startProcessLocked</span>(ProcessRecord app, <span class="hljs-built_in">String</span> hostingType, <span class="hljs-built_in">String</span> hostingNameStr) &#123;<br>  <span class="hljs-type">int</span> uid = app.<span class="hljs-property">info</span>.<span class="hljs-property">uid</span>;<br>  <span class="hljs-type">int</span>[] gids = <span class="hljs-literal">null</span>;<br>  <span class="hljs-type">int</span> debugFlags = <span class="hljs-number">0</span>;<br><br>  gids = mContext.<span class="hljs-property">getPackageManager</span>().<span class="hljs-property">getPackageGids</span>(app.<span class="hljs-property">info</span>.<span class="hljs-property">packageName</span>);<br><br>  <span class="hljs-type">int</span> pid = Process.<span class="hljs-property">start</span>(<span class="hljs-string">&quot;android.app.ActivityThread&quot;</span>, <span class="hljs-literal">null</span>, uid, uid, gids, debugFlags, <span class="hljs-literal">null</span>);<br><br>  <span class="hljs-comment">// 액티비티 매니저 서비스의 mPidsSelfLocked 해시에 생성된 프로세스의 pid 값을 key로 해서 ProcessRecord 객체를 저장함.</span><br>  <span class="hljs-variable">this</span>.<span class="hljs-property">mPidsSelfLocked</span>.<span class="hljs-property">put</span>(pid, app);<br>&#125;<br></code></pre></td></tr></table></figure><p>ActivityManagerService 클래스 코드에는 두 개의 startProcessLocked() 메서드가 존재한다.  </p><p>첫 번째 startProcessLocked() 메서드의 역할은 리모트 서비스를 실행하기 위해 새로 생성할 프로세스 정보를 포함하는 ProcessRecord 객체를 만들고, 이를 mProcessNames 큐에 삽입하는 것이다. 이 과정이 성공적으로 끝나면 두 번째 startProcessLocked() 메서드를 호출한다.  </p><p>두 번째 startProcessLocked() 메서더의 역할은 Process 클래스의 start() 메서드를 통해 Zygote에게 android.app.ActivityThread 프로세스 생성을 요청하는 것이다.  </p><h4 id="ActivityThread-클래스의-main-메서드-실행"><a href="#ActivityThread-클래스의-main-메서드-실행" class="headerlink" title="ActivityThread 클래스의 main() 메서드 실행"></a>ActivityThread 클래스의 main() 메서드 실행</h4><p>지금부터는 Zygote가 서비스 실행을 위해 액티비티 매니저 서비스가 요청한 ActivityThread 클래스를 새로운 프로세스 상에서 어떻게 실행하는지 알아본다.  </p><p>클래스의 실행을 요청받으면 새로운 프로세스를 생성하고 그 위에 해당 클래스를 로드한 후 해당 클래스의 main() 메서드를 호출한다.  </p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ActivityThread</span> extends ClientTransactionHandler &#123;<br>    <span class="hljs-comment">// ApplicationThread() 생성</span><br>    <span class="hljs-keyword">final</span> ApplicationThread mAppThread = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ApplicationThread</span>();<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-type">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">void</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">String</span>[] args)</span> </span>&#123;<br>            <span class="hljs-built_in">Process</span>.<span class="hljs-built_in">setArgV0</span>(<span class="hljs-string">&quot;&lt;pre-initialized&gt;&quot;</span>);<br>            Looper.<span class="hljs-built_in">prepareMainLooper</span>(); <span class="hljs-comment">// Looper.prepareMainLooper() 메서드를 이용해서 메시지 큐를 생성</span><br>            ActivityThread thread = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ActivityThread</span>(); <span class="hljs-comment">// ActivityThread 객체를 생성</span><br>            thread.<span class="hljs-built_in">attach</span>(<span class="hljs-literal">false</span>);<br>            Looper.<span class="hljs-built_in">loop</span>();<br>        &#125;<br><br>        <span class="hljs-comment">// 메시지 핸들러</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-type">void</span> <span class="hljs-title">handleMessage</span><span class="hljs-params">(Message msg)</span> </span>&#123;<br>           <span class="hljs-keyword">switch</span> (msg.what) &#123;<br>             :<br>             <span class="hljs-keyword">case</span> CREATE_SERVICE:<br>                   <span class="hljs-built_in">handleCreateService</span>((CreateServiceData)msg.obj);<br>                   <span class="hljs-keyword">break</span>;<br>             <span class="hljs-keyword">case</span> SERVICE_ARGS:<br>                   <span class="hljs-built_in">handleServiceArgs</span>((ServiceArgsData)msg.obj);<br>                   <span class="hljs-keyword">break</span>;<br>             <span class="hljs-keyword">case</span> STOP_SERVICE:<br>                   <span class="hljs-built_in">handleStopService</span>((IBinder)msg.obj);<br>                   <span class="hljs-keyword">break</span>;<br>             :<br>           &#125;<br>       &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>Looper는 각 스레드의 메시지 루프를 실행하는 클래스.</p><p>ActivityThread 객체는 액티비티 매니저 서비스와의 상호작용을 통해 안드로이드 애플리케이션 프로세스의 메인 스레드 실행 및 액티비티 스케줄링 등을 수행한다.  </p><p>attach() 메서드는 다음 그림과 같은 과정을 보인다.  </p><p><img src="/images/post/JS7.png" alt="JS7" title="JS7">  </p><p>⑴ ActivityThread - ActivityManagerProxy 객체의 attachApplication() 프록시 메서드를 호출<br>⑵ ActivityManagerProxy 객체 - ActivityManagerNative 객체에 ATTACH_APPLICATION_TRANSACTION RPC 코드와 바인더 RPC 데이터를 전송<br>⑶ ActivityManagerNative 객체 - ActivityManagerService에 포함된 attachApplication() 스텁 메서드를 호출  </p><p>코드를 바탕으로 attach() 메서드가 바인더 RPC를 통해 attachApplication()을 어떻게 호출하는지 알아보자.  </p><h5 id="⑴-ActivityThread-attachApplication-프록시-메서드-호출"><a href="#⑴-ActivityThread-attachApplication-프록시-메서드-호출" class="headerlink" title="⑴ ActivityThread - attachApplication() 프록시 메서드 호출"></a>⑴ ActivityThread - attachApplication() 프록시 메서드 호출</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">attach</span><span class="hljs-params">(<span class="hljs-type">boolean</span> system)</span> &#123;<br>    :<br>    <span class="hljs-keyword">if</span> (!system) &#123;<br>        <span class="hljs-type">IActivityManager</span> <span class="hljs-variable">mgr</span> <span class="hljs-operator">=</span> ActivityManagerNative.getDefault();<br>        <span class="hljs-keyword">try</span> &#123;<br>            mgr.attachApplication(mAppThread);<br>        &#125; <span class="hljs-keyword">catch</span> (RemoteException ex) &#123;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>이 메서드의 주요 기능은 ActivityThread와 액티비티 매니저 서비스 간에 IActivityManager 인터페이스 기반의 바인더 RPC를 위한 연결을 설정하는 것이다. 바인더 RPC 연결이 설정되면 ActivityThread는 ActivityManagerProxy 객체를 통해 액티비티 매니저 서비스에게 특정 작업을 요청할 수 있다.  </p><h5 id="⑵-ActivityManagerProxy-객체"><a href="#⑵-ActivityManagerProxy-객체" class="headerlink" title="⑵ ActivityManagerProxy 객체"></a>⑵ ActivityManagerProxy 객체</h5><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs haskell"><span class="hljs-title">public</span> void attachApplication(<span class="hljs-type">IApplicationThread</span> app)<br>&#123;<br>  <span class="hljs-type">Parcel</span> <span class="hljs-class"><span class="hljs-keyword">data</span> = <span class="hljs-type">Parcel</span>.obtain();</span><br>  <span class="hljs-type">Parcel</span> reply = <span class="hljs-type">Parcel</span>.obtain();<br>  <span class="hljs-class"><span class="hljs-keyword">data</span>.writeInterfaceToken(<span class="hljs-type">IActivityManager</span>.<span class="hljs-title">descriptor</span>);</span><br>  <span class="hljs-class"><span class="hljs-keyword">data</span>.writeStrongBinder(<span class="hljs-title">app</span>.<span class="hljs-title">asBinder</span>());</span><br>  mRemote.transact(<span class="hljs-type">ATTACH_APPLICATION_TRANSACTION</span>, <span class="hljs-class"><span class="hljs-keyword">data</span>, reply, 0);</span><br>&#125;<br></code></pre></td></tr></table></figure><p>⑴ 에서 호출된 attachApplication() 프록시 메서드를 살펴보면, app 매개변수를 통해 전달받은 ApplicationThread에 대한 바인더 객체를 마샬링해서 ATTACH_APPLICATION_TRANSACTION RPC 코드와 바인더 RPC 데이터를 ActivityManagerNative 객체에 전달한다.  </p><h5 id="⑶-ActivityManagerNative-객체-attachApplication-스텁-메서드를-호출"><a href="#⑶-ActivityManagerNative-객체-attachApplication-스텁-메서드를-호출" class="headerlink" title="⑶ ActivityManagerNative 객체 - attachApplication() 스텁 메서드를 호출"></a>⑶ ActivityManagerNative 객체 - attachApplication() 스텁 메서드를 호출</h5><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">public boolean on<span class="hljs-constructor">Transact(<span class="hljs-params">int</span> <span class="hljs-params">code</span>, Parcel <span class="hljs-params">data</span>, Parcel <span class="hljs-params">reply</span>, <span class="hljs-params">int</span> ?<span class="hljs-params">ags</span>)</span><br>&#123;<br>  switch (code) &#123;<br>    :<br>    case ATTACH_APPLICATION_TRANSACTION: &#123;<br>      IApplicationThread app = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">ApplicationThreadNative</span>.</span></span><span class="hljs-keyword">as</span><span class="hljs-constructor">Interface(<span class="hljs-params">data</span>.<span class="hljs-params">readStrongBinder</span>()</span>);<br>      attach<span class="hljs-constructor">Application(<span class="hljs-params">app</span>)</span>;<br>      return <span class="hljs-literal">true</span>;<br>    &#125;<br>    :<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>ActivityThread가 보낸 ATTACH_APPLICATION_TRANSACTION RPC 코드와 바인더 RPC 데이터는 ActivityManagerNative 객체의 onTransact() 메서드를 통해 처리된다.  </p><p>지금까지의 과정을 정리하면 ActivityThread 객체는 attach() 메서드를 통해 액티비티 매니저 서비스가 자신을 제어할 수 있도록 바인더 RPC 연결을 설정한다. 연결이 설정되고 나면 액티비티 매니저 서비스의 attachApplication() 스텁 메서드가 호출된다.  </p><h4 id="액티비티-매니저-서비스-attachApplication-스텁-메서드-처리"><a href="#액티비티-매니저-서비스-attachApplication-스텁-메서드-처리" class="headerlink" title="액티비티 매니저 서비스 - attachApplication() 스텁 메서드 처리"></a>액티비티 매니저 서비스 - attachApplication() 스텁 메서드 처리</h4><p>attachApplication() 스텁 메서드의 전체적인 동작 과정  </p><p><img src="/images/post/JS8.png" alt="JS8" title="JS8">  </p><p>⑴ 액티비티 매니저 서비스 - ActivityManagerProxy 객체의 scheduleCreateService() 프록시 메서드 호출  </p><p>⑵ ActivityManagerProxy 객체 - ActivityThread의 ActivityManagerNative 객체에 SCHEDULE_CREATE_SERVICE_TRANSACTION RPC 코드와 바인더 RPC 데이터 전송  </p><p>⑶ ActivityManagerNative 객체 - ApplicationCreateService의 ApplicationThread 객체에 포함된 scheduleCreateService() 스텁 메서드 호출   </p><p>⑷ ApplicationThread 객체 - ApplicationCreateService의 ActivityThread에 메시지큐를 이용해 CREATE_SERVICE 메시지 전달  </p><p>⑸ ActivityThread 객체 - RemoteService 서비스 생성 및 서비스 생명주기에 따른 onCreate() 호출  </p><h5 id="⑴-액티비티-매니저-서비스-scheduleCreateService-프록시-메서드-호출"><a href="#⑴-액티비티-매니저-서비스-scheduleCreateService-프록시-메서드-호출" class="headerlink" title="⑴ 액티비티 매니저 서비스 - scheduleCreateService() 프록시 메서드 호출"></a>⑴ 액티비티 매니저 서비스 - scheduleCreateService() 프록시 메서드 호출</h5><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">public final void attach<span class="hljs-constructor">Application(IApplicationThread <span class="hljs-params">thread</span>)</span><br>&#123;<br>  <span class="hljs-built_in">int</span> callingPid - <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Binder</span>.</span></span>get<span class="hljs-constructor">CallingPid()</span>;<br>  attach<span class="hljs-constructor">ApplicationLocked(<span class="hljs-params">thread</span>, <span class="hljs-params">callingPid</span>)</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>이 메서드는 단순히 attachApplicationLocked() 메서드를 호출하는 역할을 한다.<br>thread인자는 ApplicationThreadProxy 객체, callingPid 인자는 attachApplication() 스텁 메서드를 호출한 프로세스의 pid.</p><p>다음 코드는 attachApplicationLocked() 메서드의 주요 부분이다.  </p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-comment">// thread는 ApplicationThreadProxy 객체를 가리킴</span><br><span class="hljs-function">pricate <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title">attachApplicationLocked</span><span class="hljs-params">(IApplicationThread thread, <span class="hljs-type">int</span> pid)</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-comment">// 생성된 ActivityThread의 pid 값을 가지는 ProcessRecord를 얻음</span><br>  ProcessRecord app;<br>  app = mPidsSelfLocked.<span class="hljs-built_in">get</span>(pid);<br><br>  <span class="hljs-comment">// ProcessRecord와 ApplicationThreadProxy 객체를 연결함</span><br>  app.thread = thread;<br><br>  <span class="hljs-comment">// 실행할 서비스의 ServiceRecord를 얻음</span><br>  ServiceRecord sr = null;<br><br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;mPendingServices.<span class="hljs-built_in">size</span>(); i++) &#123;<br>    sr = mPendingServices.<span class="hljs-built_in">get</span>(i); <span class="hljs-comment">// 큐에 저장했던 RemoteService에 대한 ServiceRecord 객체를 얻는다.  </span><br>    mPendingServices.<span class="hljs-built_in">remove</span>(i);<br>    i--;<br><br>    <span class="hljs-built_in">realStartServiceLocked</span>(sr, app); <span class="hljs-comment">// ProcessRecord와 ServiceRecord 값을 realStartServiceLocked() 메서드로 전달한다.  </span><br>  &#125;<br><br>  <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/images/post/JS9.png" alt="JS9" title="JS9">  </p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-keyword">private</span> final void real<span class="hljs-constructor">StartServiceLocked(ServiceRecord <span class="hljs-params">r</span>, ProcessRecord <span class="hljs-params">app</span>)</span><br>&#123;<br>  app.thread.schedule<span class="hljs-constructor">CreateService(<span class="hljs-params">r</span>, <span class="hljs-params">r</span>.<span class="hljs-params">serviceInfo</span>)</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>내부적으로 app.thread.scheduleCreateService() 메서드를 호출한다. app.thread에는 서비스 실행을 요청한 ActivityThread를 제어하기 위한 ApplicationThreadProxy 객체가 저장돼 있다.<br>app.thread.scheduleCreateService() 메서드는 ApplicationThreadProxy의 scheduleCreateService() 메서드를 호출한다.  </p><h5 id="⑵-ActivityManagerProxy-객체-바인더-RPC-데이터-전송"><a href="#⑵-ActivityManagerProxy-객체-바인더-RPC-데이터-전송" class="headerlink" title="⑵ ActivityManagerProxy 객체 - 바인더 RPC 데이터 전송"></a>⑵ ActivityManagerProxy 객체 - 바인더 RPC 데이터 전송</h5><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs haskell"><span class="hljs-title">public</span> final void scheduleCreateService(<span class="hljs-type">IBinder</span> token, <span class="hljs-type">ServiceInfo</span> info)<br>&#123;<br>  <span class="hljs-type">Parcel</span> <span class="hljs-class"><span class="hljs-keyword">data</span> = <span class="hljs-type">Parcel</span>.obtain();</span><br>  <span class="hljs-class"><span class="hljs-keyword">data</span>.writeStrongBinder(<span class="hljs-title">token</span>);</span><br>  info.writeToParcel(<span class="hljs-class"><span class="hljs-keyword">data</span>, 0);</span><br>  mRemote.transact(<span class="hljs-type">SCHEDULE_CREATE_SERVICE_TRANSACTION</span>, <span class="hljs-class"><span class="hljs-keyword">data</span>, null, <span class="hljs-type">IBinder</span>.<span class="hljs-type">FLAG_ONEWAY</span>);</span><br>&#125;<br></code></pre></td></tr></table></figure><p>scheduleCreateService() 프록시 메서드는 생성할 서비스(여기서는 RemoteService)에 대한 정보를 포함한 ServiceInfo 객체를 SCHEDULE_CREATE_SERVICE_TRANSACTION RPC 코드와 RPC 데이터를 통해 ApplicationThreadNative 객체에 전달한다.  </p><h5 id="⑶-ActivityManagerNative-객체-scheduleCreateService-스텁-메서드-호출"><a href="#⑶-ActivityManagerNative-객체-scheduleCreateService-스텁-메서드-호출" class="headerlink" title="⑶ ActivityManagerNative 객체 - scheduleCreateService() 스텁 메서드 호출"></a>⑶ ActivityManagerNative 객체 - scheduleCreateService() 스텁 메서드 호출</h5><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">public boolean on<span class="hljs-constructor">Transact(<span class="hljs-params">int</span> <span class="hljs-params">code</span>, Parcel <span class="hljs-params">data</span>, Parcel <span class="hljs-params">reply</span>, <span class="hljs-params">int</span> <span class="hljs-params">flags</span>)</span><br>&#123;<br>  switch(code) &#123;<br>    :<br>    case SCHEDULE_CREATE_SERVICE_TRANSACTION: &#123;<br>      IBinder token = data.read<span class="hljs-constructor">StrongBinder()</span>;<br>      serviceInfo info = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">ServiceInfo</span>.</span><span class="hljs-module"><span class="hljs-identifier">CREATOR</span>.</span></span>create<span class="hljs-constructor">FromParcel(<span class="hljs-params">data</span>)</span>;<br>      schedule<span class="hljs-constructor">CreateService(<span class="hljs-params">token</span>, <span class="hljs-params">info</span>)</span>;<br>      return <span class="hljs-literal">true</span>;<br>    &#125;<br>    :<br>  &#125;<br><br>  return super.on<span class="hljs-constructor">Transact(<span class="hljs-params">code</span>, <span class="hljs-params">data</span>, <span class="hljs-params">reply</span>, ?<span class="hljs-params">ags</span>)</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>ApplicationThreadProxy 객체가 data 변수에 마샬링해서 전달한 ServiceRecord 객체(Binder 객체를 확장한 객체)와 ServiceInfo 객체를 언마샬링한 다음 각각 token과 info 변수에 저장한다. 그리고 이렇게 바인더 RPC로부터 수신한 데이터를 저장한 token과 info를 각각 ActivityThread의 scheduleCreateService() 스텁 메서드의 인자로 넘긴다.  </p><h5 id="⑷-ApplicationThread-객체-ActivityThread로-CREATE-SERVICE-메시지-전달"><a href="#⑷-ApplicationThread-객체-ActivityThread로-CREATE-SERVICE-메시지-전달" class="headerlink" title="⑷ ApplicationThread 객체 - ActivityThread로 CREATE_SERVICE 메시지 전달"></a>⑷ ApplicationThread 객체 - ActivityThread로 CREATE_SERVICE 메시지 전달</h5><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">public final void schedule<span class="hljs-constructor">CreateService(IBinder <span class="hljs-params">token</span>, ServiceInfo <span class="hljs-params">info</span>)</span><br>&#123;<br>  CreateServiceData s = <span class="hljs-keyword">new</span> <span class="hljs-constructor">CreateServiceData()</span>;<br>  s.token = token;<br>  s.info = info;<br>  queue<span class="hljs-constructor">OrSendMessage(H.CREATE_SERVICE, <span class="hljs-params">s</span>)</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>scheduleCreateService() 스텁 메서드는 인자를 이용해 CreateServiceData라는 객체를 만든 다음 이를 ActivityThread 메시지 큐에 CREATE_SERVICE 메시지로 전달한다.  </p><p>지금까지의 과정을 살펴보면 다음과 같이 나타낼 수 있다.  </p><p><img src="/images/post/JS10.png" alt="JS10" title="JS10">  </p><p>ApplicationThread는 액티비티 매니저 서비스의 제어 명령을 바인더 RPC로 수신하기 위한 용도로 사용되고,<br>실제 액티비티 매니저 서비스로부터 요청받은 서비스를 실행하거나 생명주기를 관리하는 일은 ActivityThread가 처리하기 때문이다.  </p><h5 id="⑸-ActivityThread-객체-서비스-생성-및-서비스의-onCreate-호출"><a href="#⑸-ActivityThread-객체-서비스-생성-및-서비스의-onCreate-호출" class="headerlink" title="⑸ ActivityThread 객체 - 서비스 생성 및 서비스의 onCreate() 호출"></a>⑸ ActivityThread 객체 - 서비스 생성 및 서비스의 onCreate() 호출</h5><p>ActivityThread의 메시지 핸들러 코드 중 CREATE_SERVICE 메시지를 처리하는 주요 부분이며, 실질적인 처리는 handleCreateService() 메서드에서 이루어진다.</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">public void handle<span class="hljs-constructor">Message(Message <span class="hljs-params">msg</span>)</span><br>&#123;<br>  switch (msg.what) &#123;<br>    :<br>    case CREATE_SERVICE:<br>    handle<span class="hljs-constructor">CreateService((CreateServiceData)</span>msg.obj);<br>    break;<br>    :<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">private</span> final void handle<span class="hljs-constructor">CreateService(CreateServiceData <span class="hljs-params">data</span>)</span><br>&#123;<br>  <span class="hljs-comment">// 서비스 인스턴스 생성</span><br>  PackageInfo packageInfo = get<span class="hljs-constructor">PackageInfoNoCheck(<span class="hljs-params">data</span>.<span class="hljs-params">info</span>.<span class="hljs-params">applicationInfo</span>)</span>;<br>  Service service = null;<br>  java.lang.ClassLoader cl = packageInfo.get<span class="hljs-constructor">ClassLoader()</span>;<br>  service = (Service) cl.load<span class="hljs-constructor">Class(<span class="hljs-params">data</span>.<span class="hljs-params">info</span>.<span class="hljs-params">name</span>)</span>.<span class="hljs-keyword">new</span><span class="hljs-constructor">Instance()</span>;<br><br>  <span class="hljs-comment">// 서비스 생명주기 시작</span><br>  service.on<span class="hljs-constructor">Create()</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="정리"><a href="#정리" class="headerlink" title="정리"></a>정리</h3><p><img src="/images/post/JS11.png" alt="JS11" title="JS11">  </p><p>⑴ Controller 액티비티는 RemoteService 서비스를 실행하기 위해 startService() API를 통해 액티비티 매니저 서비스에 RemoteService 서비스 실행을 요청한다.  </p><p>⑵ 요청받은 서비스가 리모트 서비스인 경우 액티비티 매니저 서비스는 Zygote에게 서비스를 별도의 독립 프로세스로 실행시키기 위해 ActivityThread 생성을 요청한다.  </p><p>⑶ Zygote에 의해 생성된 ActivityThread는 attachApplication() 프록시 메서드를 통해 액티비티 매니저 서비스에게 자신을 등록한다. 이를 통해 액티비티 매니저 서비스는 생성도니 ActivityThread를 제어할 수 있다.  </p><p>⑷ 액티비티 매니저 서비스는 ⑴에서 요청받은 RemoteService 생성을 ActivityThread에 요청한다.  </p><p>⑸ ActivityThread는 요청했던 RemoteService 서비스의 인스턴스를 생성한 다음 이 서비스의 onCreate() 콜백 함수를 호출한다.  </p>]]></content>
    
    
    <categories>
      
      <category>Android</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Android</tag>
      
      <tag>인사이드 안드로이드</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[인사이드 안드로이드] 챕터 10 - 자바 서비스 프레임워크</title>
    <link href="/chapter10/"/>
    <url>/chapter10/</url>
    
    <content type="html"><![CDATA[<h1 id="인사이드-안드로이드"><a href="#인사이드-안드로이드" class="headerlink" title="[인사이드 안드로이드]"></a>[인사이드 안드로이드]</h1><h2 id="Chapter10-자바-서비스-프레임워크"><a href="#Chapter10-자바-서비스-프레임워크" class="headerlink" title="Chapter10 - 자바 서비스 프레임워크"></a>Chapter10 - 자바 서비스 프레임워크</h2><p>안드로이드 서비스 프레임워크는 자바 서비스 프레임워크와 네이티브 서비스 프레임워크로 나뉜다. 자바 서비스 프레임워크는 네이티브 서비스 프레임워크에서 제공하는 4가지 핵심 기능을 동일하게 제공하지만 시스템 내부에서 서비스가 동작하는 매커니즘이나 서비스 작성 방법에 있어서는 차이점이 있다.  </p><h3 id="자바-서비스-프레임워크"><a href="#자바-서비스-프레임워크" class="headerlink" title="자바 서비스 프레임워크"></a>자바 서비스 프레임워크</h3><p>자바 서비스 프레임워크는 자바 기반의 애플리케이션 프레임워크에서 동작하는 자바 시스템 서비스를 개발할 때 이용하는 클래스의 집합이다. 자바 서비스 프레임워크는 JNI를 통해 네이티브 서비스 프레임워크를 재사용함으로써 자바 레이어의 서비스 사용자가 자바로 작성된 서비스뿐만 아니라 C++로 작성된 서비스도 이용할 수 있게 된다.  </p><p><img src="/images/post/sf1.png" alt="sf1" title="sf1">  </p><p>자바 서비스 프레임워크는 네이티브 서비스 프레임워크와 다음과 같은 차이점이 있다.  </p><p>① 서비스 생성 : 자바 서비스 프레임워크에서 자바 서비스를 개발하는 방법은 두 가지다.<br>  첫 번째 방법은 Binder 클래스를 상속받아 개발하는 것으로, 서비스를 정밀하게 제어해야 할 때 적잘한 방식으로 자바 시스템 서비스를 작성할 때도 쓰이는 방법이다.<br>  두 번째 방법은 Service 클래스를 상속받아 개발하는 것인데 일반적으로 특정 작업을 주기적으로 백그라운드에서 수행하는 프로세스를 구현하는 데 사용된다.<br>② 바인더 IPC 처리 : 자바 서비스 프레임워크에서는 바인더 IPC를 지원하기 위해 JNI를 통해 연결된 네이티브 서비스 프레임워크의 구성요소를 재사용한다.  </p><h4 id="자바-서비스-프레임워크의-계층별-요소"><a href="#자바-서비스-프레임워크의-계층별-요소" class="headerlink" title="자바 서비스 프레임워크의 계층별 요소"></a>자바 서비스 프레임워크의 계층별 요소</h4><p>다음 그림은 자바 서비스 프레임워크의 구성요소를 계층별로 표현한 것이다. 각 레이어별로 네이티브 서비스 프레임워크와 차이점은 첫째, 서비스 사용자의 서비스 레이어에 매니저(Manager) 클래스가 위치한다. 둘째, RPC 레이어에 AIDL 도구로 자동 생성된 스텁(Stub)과 프록시(Proxy) 클래스가 위치한다. 셋째, IPC 레이어에 위치한 구성요소가 JNI를 통해 네이티브 서비스 프레임워크의 구성요소와 연결돼 있다.  </p><p><img src="/images/post/sf2.png" alt="sf2" title="sf2">  </p><p><strong>서비스 레이어</strong>  </p><p>FooManager 클래스를 구현하는 이유는 SDK에 serviceManager 클래스가 포함되지 않았기 때문에 애플리케이션에서 serviceManager 클래스를 이용하여 시스템 서비스를 등록하거나 또는 시스템 서비스를 검색 할 수 없기 때문이다.  </p><p><img src="/images/post/sf3.png" alt="sf3" title="sf3">  </p><p>시스템 서비스 개발자는 애플리케이션 개발자가 시스템 서비스를 이용할 수 있게 SDK에 래퍼 클래스를 포함시켜야 한다.  </p><p><strong>RPC 레이어</strong>  </p><p>자바 서비스 프레임워크는 안드로이드 플랫폼에 포함된 AIDL(Android Interface Definition Language) 언어와 컴파일러를 이용해 서비스 프록시와 서비스 스텁을 자동으로 생성한다. AIDL은 안드로이드에서 프로세스 간의 IPC(InterProcess Communication)를 통해 상호작용하는 자바 기반의 코드를 작성하는 데 사용되는 인터페이스 정의 언어다.  </p><p><strong>IPC 레이어</strong>  </p><p>자바 서비스 프레임워크를 이용해 개발한 서비스와 서비스 프록시가 상호작용할 때도 바인더 RPC를 이용한다. 바인더 RPC를 위해 네이티브 서비스 프레임워크에서는 BpBinder와 BBinder 클래스를 제공하지만 자바 서비스 프레임워크에서는 BinderProxy와 Binder 클래스가 이용된다.<br>서비스 프록시에서 서비스에게 바인더 RPC 데이터를 전달하려면 바인더 IPC를 이용해야 하는데, 자바 서비스 프레임워크에서는 JNI를 통해 네이티브 서비스 프레임워크의 바인더 IPC를 재사용한다.  </p><p><img src="/images/post/sf4.png" alt="sf4" title="sf4">  </p><h4 id="자바-서비스-프레임워크의-클래스별-상호작용"><a href="#자바-서비스-프레임워크의-클래스별-상호작용" class="headerlink" title="자바 서비스 프레임워크의 클래스별 상호작용"></a>자바 서비스 프레임워크의 클래스별 상호작용</h4><p>자바 서비스 프레임워크는 바인더 RPC를 지원하기 위해 JNI를 통해 네이티브 서비스 프레임워크의 기능을 재사용하므로 서비스 클라이언트와 서비스 서버 내부의 구성요소 간에 수직 방향으로 이뤄지는 상호작용 역시 두 프레임워크 사이에 차이점이 있다. 먼저 자바 시스템 서비스 사용자가 위치한 서비스 클라이언트부터 살펴보면 다음 그림에서 서비스 사용자가 FooManager의 foo() 메서드를 호출하는 과정과 BinderProxy의 transact() 메서드가 JNI 네이티브 함수인 android_os_BinderProxy_transact() 로 BpBinder의 transact() 함수를 호출하는 과정이 추가돼 있음을 확인할 수 있다.  </p><p><img src="/images/post/sf5.png" alt="sf5" title="sf5">  </p><p>자바 시스템 서비스가 위치한 서비스 서버를 살펴보면 다음 그림에서 BBinder의 transact() 함수가 JavaBBinder 네이티브 서비스 스텁을 이용해 Binder execTransact() 메서드를 호출하는 과정이 추가되었다.  </p><p><img src="/images/post/sf6.png" alt="sf6" title="sf6">  </p><p>다음 그림은 자바 서비스를 시스템에 등록하는 과정에서 자바 서비스 프레임워크 구성요소가 상호작용 하는 과정을 보여준다. 네이티브 서비스 프레임워크와 비슷하게 서비스 등록과 사용에 관한 주체는 서비스를 제공하는 서비스 서버, 서비스를 이용하는 서비스 클라이언트, 서비스 매니저, 참여 주체 사이에 통신을 지원하는 바인더 드라이버로 구성된다.  </p><p><img src="/images/post/sf7.png" alt="sf7" title="sf7">  </p><p>① 서비스 등록 요청(서비스) : 자바 서비스 프레임워크는 자바 서비스 매니저인 ServiceManager 클래스를 이용해서 이 과정을 처리한다. FooManager 서비스는 자신을 시스템에 등록하기 위해 ServiceManager의 addService() 메서드를 호출한다. ServiceManager 내부에는 BinderProxy가 있으며, BinderProxy는 컨텍스트 매니저를 가리키는 BpBinder와 JNI를 통해 연결돼 있다.<br>② 서비스 등록(서비스 매니저) : ServiceManagerProxy 서비스 프록시는 addService() 메서드의 호출 정보를 RPC 데이터로 변환한다. 이때 바인더 RPC 데이터는 Parcel 클래스에 저장되어 BinderProxy에 전달되고, JNI를 통해 BpBinder에 전달된다. 그러고 나서 바인더 IPC를 통해 컨텍스트 매니저에 전달되어 FooService 서비스가 시스템에 등록된다.<br>③ 서비스 검색 요청(서비스 사용자) : FooService 서비스를 사용하기 위해 네이티브 서비스 사용자는 BpServiceManager를 통해 서비스를 검색했지만 자바 서비스 사용자는 SDK에서 제공하는 getSystemService() 메서드를 호출해서 서비스를 검색한다.<br>④ 서비스 검색(서비스 매니저) : getSystemService()는 ServiceManager의 getService() 메서드를 호출해 시스템에서 FooService 서비스를 검색한다. 만약 FooService 서비스가 검색되면 IFooService.Stub.Proxy 서비스 프록시를 참조하는 FooManager를 서비스 사용자에게 반환한다.<br>⑤ foo() 서비스 프록시 메서드 호출(서비스 사용자) : 서비스 사용자는 FooManager의 foo() 메서드를 호출한다. 그러고 나면 IFooService.Stub.Proxy는 foo() 메서드 호출 정보를 RPC 데이터로 변환한 다음 BinderProxy를 통해 BpBinder에 전달한다.<br>⑥ foo() 서비스 스텁 메서드 실행(서비스) : BBinder는 바인더 드라이버로부터 바인더 RPC 데이터를 전달받아 JavaBBinder을 통해서 Binder의 execTransact() 메서드를 호출한다. 그러고 나서 IFooService.Stub 서비스 스텁의 onTransact() 메서드로 RPC 데이터가 전달되고 이 데이터를 분석하여 FooService의 foo() 서비스 스텁 메서드를 호출한다.  </p><p>자바 서비스 프레임워크의 가장 중요한 특징은 JNI를 통해 네이티브 서비스프레임워크의 기능을 재사용한다는 점이다. 특히 IPC 레이어에 위치한 바인더 IPC 처리를 위해 BinderProxy와 Binder 클래스가 JNI를 통해 BpBinder와 BBinder 클래스의 기능을 재사용한다는 점이 주목할만하다.  </p><h3 id="동작-메커니즘"><a href="#동작-메커니즘" class="headerlink" title="동작 메커니즘"></a>동작 메커니즘</h3><p>여기서 주목해서 살펴봐야 할 점은 각 클래스의 생성 과정과 JNI 네이티브 함수 설정 인데 이를 바탕으로 자바 서비스 프레임워크가 네이티브 서비스 프레임워크를 재사용하는 메커니즘을 이해할 수 있다.  </p><h4 id="자바-서비스-프레임워크-초기화"><a href="#자바-서비스-프레임워크-초기화" class="headerlink" title="자바 서비스 프레임워크 초기화"></a>자바 서비스 프레임워크 초기화</h4><p>app_process 프로세스가 실행되면 AndroidRuntime 클래스에서 startReg() 함수를 호출해서 JNI 네이티브 함수를 달빅 가상 머신으로 로딩한다. 이때 register_android_os_Binder() 함수를 호출해서 등록되는 JNI 네이티브 함수가 바로 자바 서비스 프레임워크와 관련이 있는 네이티브 함수들이다.  </p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-built_in">int</span> register<span class="hljs-constructor">_android_os_Binder(JNIEnv<span class="hljs-operator">*</span> <span class="hljs-params">env</span>)</span><br>&#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">int</span><span class="hljs-constructor">_register_android_os_Binder(<span class="hljs-params">env</span>)</span> &lt; <span class="hljs-number">0</span>)<br>        return -<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">int</span><span class="hljs-constructor">_register_android_os_BinderInternal(<span class="hljs-params">env</span>)</span> &lt; <span class="hljs-number">0</span>)<br>        return -<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">int</span><span class="hljs-constructor">_register_android_os_BinderProxy(<span class="hljs-params">env</span>)</span> &lt; <span class="hljs-number">0</span>)<br>        return -<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">int</span><span class="hljs-constructor">_register_android_os_Parcel(<span class="hljs-params">env</span>)</span> &lt; <span class="hljs-number">0</span>)<br>        return -<span class="hljs-number">1</span>;<br>    return <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>위의 코드는 register_android_os_Binder() 함수의 일부로 총 네 종류의 함수를 호출하고 있다. 함수명에서 마지막 단어는 JNI 네이티브 함수를 사용하는 자바 클래스의 이름을 나타낸다.  </p><h4 id="Binder"><a href="#Binder" class="headerlink" title="Binder"></a>Binder</h4><p>Binder 클래스를 사용하려면 달빅 가상 머신에 Binder의 네이티브 메서드를 위한 JNI 네이티브 함수를 등록해줘야 한다. 이전의 코드 int_register_android_os_Binder() 함수가 호출되면 Binder 클래스의 일부 정보를 전역 변수인 gBinderOffsets에 저장하고, Binder 클래스의 네이티브 메서드와 JNI 네이티브 함수를 매핑한다.  </p><figure class="highlight mel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs mel">static <span class="hljs-keyword">int</span> int_register_android_os_Binder(JNIEnv* <span class="hljs-keyword">env</span>)<br>&#123;<br>    jclass clazz;<br><br>    clazz = <span class="hljs-keyword">env</span>-&gt;FindClass(kBinderPathName);    <span class="hljs-comment">// 달빅 가상 머신에서 클래스를 찾아 Binder 클래스의 주요 정보 저장</span><br>    LOG_FATAL_IF(clazz == NULL, <span class="hljs-string">&quot;Unable to find class android.os.Binder&quot;</span>);<br><br>    gBinderOffsets.mClass = (jclass) <span class="hljs-keyword">env</span>-&gt;NewGlobalRef(clazz);    <span class="hljs-comment">// Binder 클래스 정보</span><br>    gBinderOffsets.mExecTransact    <span class="hljs-comment">// execTransact() 메서드 ID</span><br>        = <span class="hljs-keyword">env</span>-&gt;GetMethodID(clazz, <span class="hljs-string">&quot;execTransact&quot;</span>, <span class="hljs-string">&quot;(IIII)Z&quot;</span>);<br>    assert(gBinderOffsets.mExecTransact);<br><br>    gBinderOffsets.mObject    <span class="hljs-comment">// mOject 필드 ID</span><br>        = <span class="hljs-keyword">env</span>-&gt;GetFieldID(clazz, <span class="hljs-string">&quot;mObject&quot;</span>, <span class="hljs-string">&quot;I&quot;</span>);<br>    assert(gBinderOffsets.mObject);<br><br>    <span class="hljs-keyword">return</span> AndroidRuntime::registerNativeMethods(   <span class="hljs-comment">// Binder의 네이티브 메서드와 매핑되는 JNI 네이티브 함수를 달빅 가상 머신에 등록</span><br>        <span class="hljs-keyword">env</span>, kBinderPathName,<br>        gBinderMethods, NELEM(gBinderMethods));<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>Binder 객체 생성</strong>  </p><p>Binder 클래스는 바인더 IPC를 위해 BBinder의 기능을 사용하기 때문에 Binder 객체가 생성될 때 BBinder가 함께 생성돼야 한다. 다음 코드는 Binder 생성자의 소스 코드다. Binder는 생성자에서 init() 네이티브 메서드를 호출한다.  </p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs aspectj"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Binder</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">IBinder</span> </span>&#123;<br>    Private <span class="hljs-keyword">native</span> <span class="hljs-keyword">final</span> <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Binder</span><span class="hljs-params">()</span> </span>&#123;<br>      init();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>다음 코드에서는 JavaBBinderHolder 클래스의 객체를 생성한 후 SetIntField() JNI 함수를 이용해 Binder의 mObject 변수에 생성된 JavaBBinderHolder 인스턴스의 주소를 저장한다.  </p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">static void android<span class="hljs-constructor">_os_Binder_init(JNIEnv<span class="hljs-operator">*</span> <span class="hljs-params">env</span>, <span class="hljs-params">jobject</span> <span class="hljs-params">obj</span>)</span><br>&#123;<br>    JavaBBinderHolder* jbh = <span class="hljs-keyword">new</span> <span class="hljs-constructor">JavaBBinderHolder()</span>;<br>    <span class="hljs-keyword">if</span> (jbh<span class="hljs-operator"> == </span>NULL) &#123;<br>        jni<span class="hljs-constructor">ThrowException(<span class="hljs-params">env</span>, <span class="hljs-string">&quot;java/lang/OutOfMemoryError&quot;</span>, NULL)</span>;<br>        return;<br>    &#125;<br>    <span class="hljs-constructor">ALOGV(<span class="hljs-string">&quot;Java Binder %p: acquiring first ref on holder %p&quot;</span>, <span class="hljs-params">obj</span>, <span class="hljs-params">jbh</span>)</span>;<br>    jbh-&gt;inc<span class="hljs-constructor">Strong((<span class="hljs-params">void</span><span class="hljs-operator">*</span>)</span>android_os_Binder_init);<br>    env-&gt;<span class="hljs-constructor">SetIntField(<span class="hljs-params">obj</span>, <span class="hljs-params">gBinderOffsets</span>.<span class="hljs-params">mObject</span>, (<span class="hljs-params">int</span>)</span>jbh);<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>JavaBBinder 객체 생성</strong>  </p><p>Binder 클래스의 객체가 생성될 때 BBinder 클래스의 객체가 함께 생성돼야 하는데도 Binder 객체 생성 과정에서도 BBinder 객체가 생성되는 곳은 보이지 않는다. 대신 JavaBBinderHolder 클래스의 객체를 생성하는 코드는 확인할 수 있다.<br>JavaBBinderHolder 클래스의 생성자는 단순히 mObject 변수에 Binder 객체의 주소값을 저장할 뿐이다.  </p><p>실제로 JavaBBinder의 인스턴스는 JavaBBinderHolder의 get() 함수에서 생성된다. 다음 코드를 보면 get() 함수에서 직접 JavaBBinder 클래스의 인스턴스를 생성하는 것을 확인할 수 있다. JavaBBinder는 BBinder를 상속받아 구현한 클래스이므로 JavaBBinder 객체를 생성하면 BBinder의 객체도 생성되는 것으로 볼 수 있다.  </p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm"><span class="hljs-built_in">sp</span>&lt;<span class="hljs-keyword">JavaBBinder&gt; </span><span class="hljs-keyword">JavaBBinderHolder::get(JNIEnv* </span>env)<br>&#123;<br>    AutoMutex _l(mLock);<br>    <span class="hljs-built_in">sp</span>&lt;<span class="hljs-keyword">JavaBBinder&gt; </span><span class="hljs-keyword">b </span>= mBinder.promote();<br>    if (<span class="hljs-keyword">b </span>== NULL) &#123;<br>        <span class="hljs-keyword">b </span>= new <span class="hljs-keyword">JavaBBinder(env, </span>mObject);<br>        mBinder = <span class="hljs-keyword">b;</span><br><span class="hljs-keyword"></span>    &#125;<br><br>    return <span class="hljs-keyword">b;</span><br><span class="hljs-keyword"></span>&#125;<br></code></pre></td></tr></table></figure><p>다음 그림은 Binder 객체와 JavaBBinder 객체가 생성되는 과정을 요약해서 나타낸 것이다.  </p><p><img src="/images/post/sf8.png" alt="sf8" title="sf8">  </p><p><strong>Binder 클래스와 JavaBBinder 서비스 스텁 클래스의 상호 작용</strong>  </p><p>BBinder의 transact()가 호출되면 기본적으로 onTransact()가 호출된다. BBinder에서 기본으로 제공하는 바인더 RPC 함수 이외에 새로운 기능을 제공하려면 BBinder를 상속받은 서비스 스텁 클래스에서 onTransact() 메서드를 재정의해야 한다. BBinder 클래스를 상속한 JavaBBinder 서비스 스텁 클래스는 onTransact() 함수에서 Binder의 execTransact() 메서드를 호출한다.  </p><p>다음 코드는 JavaBBinder의 onTransact() 함수다. CallBooleanMethod() JNI 함수를 호출해서 Binder의 execTransact() 메서드를 호출한다.  </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">status_t</span> <span class="hljs-title">JavaBBinder::onTransact</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">       <span class="hljs-type">uint32_t</span> code, <span class="hljs-type">const</span> Parcel&amp; data, Parcel* reply, <span class="hljs-type">uint32_t</span> flags = <span class="hljs-number">0</span>)</span></span><br><span class="hljs-function">   </span>&#123;<br>       JNIEnv* env = <span class="hljs-built_in">javavm_to_jnienv</span>(mVM);<br>       :<br>       jboolean res = env-&gt;<span class="hljs-built_in">CallBooleanMethod</span>(mObject, gBinderOffsets.mExecTransact,<br>           code, <span class="hljs-built_in">reinterpret_cast</span>&lt;jlong&gt;(&amp;data), <span class="hljs-built_in">reinterpret_cast</span>&lt;jlong&gt;(reply), flags);<br>       :<br>       <span class="hljs-keyword">return</span> res != JNI_FALSE ? NO_ERROR : UNKNOWN_TRANSACTION;<br>  &#125;<br></code></pre></td></tr></table></figure><p>Binder 클래스의 execTransact() 메서드가 호출되면 onTransact() 메서드를 호출한다.  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">execTransact</span><span class="hljs-params">(<span class="hljs-type">int</span> code, <span class="hljs-type">int</span> dataObj, <span class="hljs-type">int</span> replyObj,</span><br><span class="hljs-params">        <span class="hljs-type">int</span> flags)</span> &#123;<br>    <span class="hljs-type">Parcel</span> <span class="hljs-variable">data</span> <span class="hljs-operator">=</span> Parcel.obtain(dataObj);<br>    <span class="hljs-type">Parcel</span> <span class="hljs-variable">reply</span> <span class="hljs-operator">=</span> Parcel.obtain(replyObj);<br><br>    <span class="hljs-type">boolean</span> res;<br>    <span class="hljs-keyword">try</span> &#123;<br>        res = onTransact(code, data, reply, flags);<br>    &#125; <span class="hljs-keyword">catch</span> (RemoteException e) &#123;<br>        reply.setDataPosition(<span class="hljs-number">0</span>);<br>        reply.writeException(e);<br>        res = <span class="hljs-literal">true</span>;<br>    &#125; <span class="hljs-keyword">catch</span> (RuntimeException e) &#123;<br>        reply.setDataPosition(<span class="hljs-number">0</span>);<br>        reply.writeException(e);<br>        res = <span class="hljs-literal">true</span>;<br>    &#125; <span class="hljs-keyword">catch</span> (OutOfMemoryError e) &#123;<br>        <span class="hljs-type">RuntimeException</span> <span class="hljs-variable">re</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(<span class="hljs-string">&quot;Out of memory&quot;</span>, e);<br>        reply.setDataPosition(<span class="hljs-number">0</span>);<br>        reply.writeException(re);<br>        res = <span class="hljs-literal">true</span>;<br>    &#125;<br>    reply.recycle();<br>    data.recycle();<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="BinderProxy"><a href="#BinderProxy" class="headerlink" title="BinderProxy"></a>BinderProxy</h4><p><strong>BinderProxy 클래스를 위한 JNI 설정</strong>  </p><p>BinderProxy 클래스를 사용하려면 달빅 가상 머신에 BinderProxy의 네이티브 메서드를 위한 JNI 네이티브 함수를 먼저 등록해줘야 한다.  </p><p><strong>BinderProxy 객체 생성</strong>  </p><p>BinderProxy 클래스도 바인더 IPC를 수행하는데 네이티브 서비스 프레임워크의 BpBinder의 기능을 사용하므로 BinderProxy 객체가 생성될 때 BpBinder 객체가 필요하다. 따라서 BinderProxy 객체도 Parcel의 readStrongBinder() 메서드를 호출할 때 생성된다.  </p><p><img src="/images/post/sf9.png" alt="sf9" title="sf9">  </p><p>javaObjectForIBinder() 함수를 살펴보면 NewObject() JNI 함수를 이용해 BinderProxy 객체를 생성한 다음 BinderProxy의 mObject 변수에 BpBinder 객체를 저장한다.  </p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">jobject java<span class="hljs-constructor">ObjectForIBinder(JNIEnv<span class="hljs-operator">*</span> <span class="hljs-params">env</span>, <span class="hljs-params">const</span> <span class="hljs-params">sp</span>&lt;IBinder&gt;&amp; <span class="hljs-params">val</span>)</span><br>&#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">val</span><span class="hljs-operator"> == </span>NULL) return NULL;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">val</span>-&gt;check<span class="hljs-constructor">Subclass(&amp;<span class="hljs-params">gBinderOffsets</span>)</span>) &#123;<br>        jobject <span class="hljs-keyword">object</span> = static_cast&lt;JavaBBinder*&gt;(<span class="hljs-keyword">val</span>.get<span class="hljs-literal">()</span>)-&gt;<span class="hljs-keyword">object</span><span class="hljs-literal">()</span>;<br>        <span class="hljs-constructor">LOGDEATH(<span class="hljs-string">&quot;objectForBinder %p: it&#x27;s our own %p!\n&quot;</span>, <span class="hljs-params">val</span>.<span class="hljs-params">get</span>()</span>, <span class="hljs-keyword">object</span>);<br>        return <span class="hljs-keyword">object</span>;<br>    &#125;<br>    :<br>    <span class="hljs-keyword">object</span> = env-&gt;<span class="hljs-constructor">NewObject(<span class="hljs-params">gBinderProxyOffsets</span>.<span class="hljs-params">mClass</span>, <span class="hljs-params">gBinderProxyOffsets</span>.<span class="hljs-params">mConstructor</span>)</span>;<br><br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">object</span> != NULL) &#123;<br>        env-&gt;<span class="hljs-constructor">SetIntField(<span class="hljs-params">object</span>, <span class="hljs-params">gBinderProxyOffsets</span>.<span class="hljs-params">mObject</span>, (<span class="hljs-params">int</span>)</span><span class="hljs-keyword">val</span>.get<span class="hljs-literal">()</span>);<br>    &#125;<br><br>    return <span class="hljs-keyword">object</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>BinderProxy 클래스와 BpBinder 클래스의 상호작용</strong>  </p><p>android_os_BinderProxy_transact() 함수를 살펴보면 BinderProxy의 mObject 변수가 참조하고 있는 BpBidner 객체의 주소를 획득하여 transact() 함수를 호출한다.  </p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs haskell"><span class="hljs-title">static</span> jboolean android_os_BinderProxy_transact(<span class="hljs-type">JNIEnv</span>* env, jobject obj,<br>        jint code, jobject dataObj, jobject replyObj, jint flags) // throws <span class="hljs-type">RemoteException</span><br>&#123;<br>    <span class="hljs-type">Parcel</span>* <span class="hljs-class"><span class="hljs-keyword">data</span> = parcelForJavaObject(<span class="hljs-title">env</span>, <span class="hljs-title">dataObj</span>);</span><br>    <span class="hljs-type">Parcel</span>* reply = parcelForJavaObject(env, replyObj);<br>    <span class="hljs-type">IBinder</span>* target = (<span class="hljs-type">IBinder</span>*)<br>        env-&gt;<span class="hljs-type">GetIntField</span>(obj, gBinderProxyOffsets.mObject);<br><br>    status_t err = target-&gt;transact(code, *<span class="hljs-class"><span class="hljs-keyword">data</span>, reply, flags);</span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="Parcel"><a href="#Parcel" class="headerlink" title="Parcel"></a>Parcel</h4><p>Parcel 클래스는 바인더 IPC가 진행되는 동안 송신측에서 수신측으로 전달되는 데이터를 저장하는 데 사용한다. 특히, Parcel은 내부 버퍼 안에 IBinder 객체 레퍼런스를 가지고 있어 프로세스를 가로질러 이동할 때도 레퍼런스 값을 유지해야 한다. 따라서 이런 기능을 자바 서비스 프레임워크에서도 제공하기 위해 JNI를 통해 Parcel 클래스(C++)의 기능을 재사용한다.  </p><p><strong>Parcel 클래스의 JNI 설정</strong>  </p><p>Parcel 클래스의 네이티브 메서드는 JNI 함수를 통해 Parcel(C++) 클래스에 포함된 이름이 동일한 멤버 함수를 대부분 호출한다.  </p><p><strong>Parcel 객체 생성</strong>  </p><p>Parcel 객체를 생성하는 과정은 Binder, BinderProxy 클래스와는 조금 다르다. Parcel의 생성자를 보면 private로 선언돼 있어 인스턴스를 획득하려면 Parcel의 obtain() 메서드를 사용해야 한다.  </p><p>obtain() 메서드에서는 Parcel의 생성자가 호출된다. 생성자 내부에서는 init() 네이티브 메서드가 호출되어 JNI로 매핑된 android_os_Parcel_init() 함수가 실행되면 다음 코드에서 Parcel(C++) 클래스의 인스턴스를 생성하는 것을 확인할 수 있다.  </p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">static void android<span class="hljs-constructor">_os_Parcel_init(JNIEnv<span class="hljs-operator">*</span> <span class="hljs-params">env</span>, <span class="hljs-params">jobject</span> <span class="hljs-params">clazz</span>, <span class="hljs-params">jint</span> <span class="hljs-params">parcelInt</span>)</span><br>&#123;<br>    Parcel* parcel = (Parcel*)parcelInt;<br>    <span class="hljs-built_in">int</span> own = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">if</span> (!parcel) &#123;<br>        own = <span class="hljs-number">1</span>;<br>        parcel = <span class="hljs-keyword">new</span> Parcel;<br>    &#125;<br><br>    env-&gt;<span class="hljs-constructor">SetIntField(<span class="hljs-params">clazz</span>, <span class="hljs-params">gParcelOffsets</span>.<span class="hljs-params">mOwnObject</span>, <span class="hljs-params">own</span>)</span>;<br>    env-&gt;<span class="hljs-constructor">SetIntField(<span class="hljs-params">clazz</span>, <span class="hljs-params">gParcelOffsets</span>.<span class="hljs-params">mObject</span>, (<span class="hljs-params">int</span>)</span>parcel);<br>&#125;<br></code></pre></td></tr></table></figure><p>다음 그림은 Parcel 객체가 생성되는 과정을 그림으로 정리한 것이다.  </p><p><img src="/images/post/sf10.png" alt="sf10" title="sf10">  </p><p><strong>Parcel 클래스(Java)와 Parcel 클래스(C++) 간의 상호작용</strong>  </p><p>일반적으로 Parcel 클래스는 서비스 프록시에서 바인더 RPC 데이터를 저장할 때 사용된다. 다음 그림은 BinderProxy의 transact() 메서드가 호출된 후 Parcel 객체의 이동경로를 보여준다. 서비스 프록시에서 바인더 RPC를 진행하면 달빅 가상 머신에서 생성된 Parcel 객체가 서비스에게 전달돼야 하는데 그러기 위해서는 Parcel(Java) 객체를 Parcel(C++) 객체로 변환해야 한다. 이를 위해 자바 서비스 프레임워크에서는 parcelForJavaObject()라는 함수를 제공한다.  </p><p><img src="/images/post/sf11.png" alt="sf11" title="sf11">  </p><p>반대로 BBinder transact() 함수를 통해 Parcel(c++) 객체를 전달받으면 Parcel(C++) 객체를 Parcel(Java) 객체로 변환해야 한다.  </p><h3 id="자바-시스템-서비스-구현"><a href="#자바-시스템-서비스-구현" class="headerlink" title="자바 시스템 서비스 구현"></a>자바 시스템 서비스 구현</h3><p>개발자가 안드로이드 플랫폼에서 동작하는 자바 시스템 서비스를 개발하려면 기존 자바 시스템 서비스의 프로그램 구조를 파악하는 것이 가장 효과적이다. 여기서는 자바 시스템 서비스 가운데 알람 매니저 서비스를 토대로 시스템 서비스의 구조를 파악해본다.  </p><p><img src="/images/post/sf12.png" alt="sf12" title="sf12">  </p><h4 id="알람-매니저-서비스의-구조-분석"><a href="#알람-매니저-서비스의-구조-분석" class="headerlink" title="알람 매니저 서비스의 구조 분석"></a>알람 매니저 서비스의 구조 분석</h4><p>AlarmManagerService 클래스의 계층 구조를 클래스 다이어그램으로 나타낸 것이다. 먼저 상단에는 자바 서비스 프레임워크의 구성요소인 IInterface 인터페이스와 Binder 클래스가 위치하며, IAlarmManager 서비스 인터페이스와 서비스 스텁에서 이 클래스를 상속하고 있다. 다음으로 AIDL(Android Interface Definition Language)을 통해 자동으로 생성도니 서비스 스텁 클래스와 서비스 프록시 클래스가 위치한다. 마지막으로 그림 하단에는 실질적인 알람 매니저 서비스를 구현하고 있는 AlarmManagerService 클래스와 AlarmManager 래퍼 클래스가 있다.  </p><p><strong>알람 매니저 서비스 구현 방식</strong>  </p><p>알람 매니저 서비스는 AIDL을 이용해 해당 클래스를 자동으로 생성한다. IAlarmManager 인터페이스 내부에는 총 5개의 메서드가 선언돼 있다. 다음의 코드를 AIDL 컴파일러로 컴파일하면 알람 매니저 서비스의 서비스 인터페이스, 서비스 프록시, 서비스 스텁 클래스가 자동으로 생성된다.  </p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">interface IAlarmManager &#123;<br>    void set(<span class="hljs-built_in">int</span> <span class="hljs-keyword">type</span>, long triggerAtTime, <span class="hljs-keyword">in</span> PendingIntent operation);<br>    void set<span class="hljs-constructor">Repeating(<span class="hljs-params">int</span> <span class="hljs-params">type</span>, <span class="hljs-params">long</span> <span class="hljs-params">triggerAtTime</span>, <span class="hljs-params">long</span> <span class="hljs-params">interval</span>, <span class="hljs-params">in</span> PendingIntent <span class="hljs-params">operation</span>)</span>;<br>    void set<span class="hljs-constructor">InexactRepeating(<span class="hljs-params">int</span> <span class="hljs-params">type</span>, <span class="hljs-params">long</span> <span class="hljs-params">triggerAtTime</span>, <span class="hljs-params">long</span> <span class="hljs-params">interval</span>, <span class="hljs-params">in</span> PendingIntent <span class="hljs-params">operation</span>)</span>;<br>    void set<span class="hljs-constructor">Time(<span class="hljs-params">long</span> <span class="hljs-params">millis</span>)</span>;<br>    void set<span class="hljs-constructor">TimeZone(String <span class="hljs-params">zone</span>)</span>;<br>    void remove(<span class="hljs-keyword">in</span> PendingIntent operation);<br>&#125;<br></code></pre></td></tr></table></figure><p>AIDL로부터 자동 생성된 서비스 스텁 클래스는 Binder 클래스의 onTransact() 메서드를 재정의하여 시스템의 바인더 RPC 기능을 추가하므로 알람 매니저 서비스의 서비스 스텁 클래스도 onTransact() 메서드를 재정의하여 IAlarmManager 인터페이스에 정의된 5개의 메서드 관련 코드를 추가했다.  </p><p><strong>알람 매니저 서비스 사용</strong>  </p><p>애플리케이션 개발자가 시스템 서비스를 사용하려면 SDK의 getSystemService() 메서드를 이용해야 한다. 알람 매니저 서비스는 Context 클래스의 getSystemService() 메서드를 호출하면 애플리케이션에서 사용할 수 있으며, ApplicationContext 클래스의 getAlarmManager() 메서드에서 이를 구현하고 있다.  </p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-keyword">private</span> AlarmManager get<span class="hljs-constructor">AlarmManager()</span> &#123;<br>    synchronized (sSync) &#123;<br>        <span class="hljs-keyword">if</span> (sAlarmManager<span class="hljs-operator"> == </span>null) &#123;<br>            IBinder b = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">ServiceManager</span>.</span></span>get<span class="hljs-constructor">Service(ALARM_SERVICE)</span>; <span class="hljs-comment">// BinderProxy 객체를 반환받는다.</span><br>            IAlarmManager service = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">IAlarmManager</span>.</span><span class="hljs-module"><span class="hljs-identifier">Stub</span>.</span></span><span class="hljs-keyword">as</span><span class="hljs-constructor">Interface(<span class="hljs-params">b</span>)</span>; <span class="hljs-comment">//서비스 프록시 클래스의 객체를 획득한다.</span><br>            sAlarmManager = <span class="hljs-keyword">new</span> <span class="hljs-constructor">AlarmManager(<span class="hljs-params">service</span>)</span>; <span class="hljs-comment">// 인스턴스를 생성하여 반환한다.</span><br>        &#125;<br>    &#125;<br>    return sAlarmManager;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="HelloWorldService-시스템-서비스의-구현"><a href="#HelloWorldService-시스템-서비스의-구현" class="headerlink" title="HelloWorldService 시스템 서비스의 구현"></a>HelloWorldService 시스템 서비스의 구현</h4><p><strong>HelloWorldService 설계</strong>  </p><p>AIDL을 이용해 HelloWorldService 서비스 인터페이스, 서비스 프록시, 서비스 스텁 클래스를 자동으로 생성한 후 HelloWorldService와 HelloWorldManager를 구현해보자.  </p><p><strong>HelloWorldService 구현</strong>  </p><p>AIDL을 이용해 IHelloWorld.aidl 소스 파일을 작성한다.  </p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs ada"><span class="hljs-keyword">package</span> <span class="hljs-title">android.app;</span><br><br><span class="hljs-keyword">interface</span> IHelloWorld&#123;<br>  printHello();<br>&#125;<br></code></pre></td></tr></table></figure><p>다음으로 안드로이드 플랫폼을 빌드할 때 IHelloWorld.aidl 파일이 AIDL 컴파일러에 의해 컴파일 될 수 있게 Android.mk 설정 파일을 수정한다.<br>LOCAL_SRC_FILES 항목에서 IHelloWorld.aidl을 추가하면 된다.  </p><p><strong>HelloWorldService 서비스의 구현</strong>  </p><p>서비스는 서비스 스텁 클래스를 상속받아 구현하면 된다.  </p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-keyword">package</span> android.app;<br><br><span class="hljs-keyword">import</span> android.os.<span class="hljs-type">RemoteException</span>;<br><span class="hljs-keyword">import</span> android.content.<span class="hljs-type">Context</span>;<br><span class="hljs-keyword">import</span> android.util.<span class="hljs-type">Log</span>;<br><br>public <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HelloWorldService</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">IHelloWorld</span>.<span class="hljs-title">Stub</span> </span>&#123;<br><br>  <span class="hljs-keyword">private</span> static <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-type">TAG</span> = <span class="hljs-string">&quot;HelloWorldService&quot;</span>;<br>  <span class="hljs-type">Context</span> mContext;<br><br>  public <span class="hljs-type">HelloWorldService</span>(<span class="hljs-type">Context</span> context)&#123;<br><br>    mContext = context;<br>  &#125;<br><br>  public void printHello() <span class="hljs-keyword">throws</span> <span class="hljs-type">RemoteException</span> &#123;<br>    <span class="hljs-type">Log</span>.i(<span class="hljs-type">TAG</span>, <span class="hljs-string">&quot;Hello, World!&quot;</span>);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>HelloWorldService 서비스의 등록</strong>  </p><p>자바 시스템 서비스는 ServerThread 클래스의 run() 메서드에서 생성하여 안드로이드 플랫폼에 등록한다. ServerThread의 run() 메서드에서 HelloWorldService의 인스턴스를 생성하고 자바 서비스 매니저의 addService() 메서드를 통해 시스템에 드록한다.  </p><h4 id="HelloWorldService-시스템-서비스의-이용"><a href="#HelloWorldService-시스템-서비스의-이용" class="headerlink" title="HelloWorldService 시스템 서비스의 이용"></a>HelloWorldService 시스템 서비스의 이용</h4><p>이전까지 서비스를 구현해서 시스템에 등록했다. HelloWorldService 시스템 서비스를 애플리케이션 개발자들이 이용할 수 있게끔 HelloWorldManager 클래스를 구현해보자.  </p><p><strong>HelloWorldManager 구현</strong>  </p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs aspectj"><span class="hljs-keyword">package</span> android.app;<br><br><span class="hljs-keyword">import</span> android.os.RemoteException;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HelloWorldManager</span></span><br><span class="hljs-class"></span>&#123;<br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> IHelloWorld mService;<br><br>  HelloWorldManager(IHelloWorld service) &#123;    <span class="hljs-comment">// IHelloWorld.Stub.Proxy 클래스의 인스턴스를 인자로 전달받는다.</span><br>    mService = service;<br>  &#125;<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">printHello</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">try</span> &#123;   <span class="hljs-comment">// IHelloWorld.Stub.Proxy 객체의 printHello() 메서드가 호출된다.</span><br>      mService.printHello();<br>    &#125; <span class="hljs-keyword">catch</span>(RemoteException) &#123;<br><br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>HelloWorldManager 획득</strong>  </p><p>애플리케이션 개발자는 getSystemService() 메서드를 통해 시스템 서비스를 사용할 수 있다.  </p><p>다음 그림은 HelloWorldService 서비스에서 HelloWorldManager 객체를 획득하는 과정을 정리한 그림이다.  </p><p><img src="/images/post/sf13.png" alt="sf13" title="sf13">  </p><p>① 서비스 사용자는 HelloWorldService 서비스를 이용하기 위해 getSystemService() 메서드를 호출하면 getSystemService() 메서드 내부에서 getHelloWorldManager() 메서드를 호출한다.<br>② getHelloWorldManager() 메서드는 서비스 매니저에게 HelloWorldService 서비스의 검색을 요청한다. 검색에 성공하면 HelloWorldService 서비스를 가리키는 BinderProxy 객체를 반환한다.<br>③ getHelloWorldManager() 메서드는 반환받은 BinderProxy 객체를 HelloWorld.Stub 서비스 스텁의 asInterface() 메서드에 넘겨줘 IHelloWorld.Stub.Proxy 서비스 프록시 객체를 생성한다.<br>④ getHelloWorldManager() 메서드는 생성한 IHelloWorld.Stub.Proxy 서비스 프록시 객체를 HelloWorldManager 생성자의 인자로 넘겨줘 객체를 생성한다. HelloWorldManager는 mService 변수에 넘겨 받은 IHelloWorld.Stub.Proxy 서비스 프록시 객체를 저장한다.<br>⑤ 최종적으로 HelloWorldService 서비스를 사용하기 위해 getSystemService() 메서드를 호출한 곳에서는 HelloWorldManager의 객체를 반환받ㄷ는다. 애플리케이션은 HelloWorldService 서비스를 사용하기 위해 HelloWorldManager의 메서드를 호출하면 IHelloWorld.Stub.Proxy 서비스 프록시의 메서드가 호출되어 HelloWorldService 서비스와 바인더 RPC를 사용하여 상호작용한다.  </p><h4 id="HelloWorldService-시스템-서비스-빌드"><a href="#HelloWorldService-시스템-서비스-빌드" class="headerlink" title="HelloWorldService 시스템 서비스 빌드"></a>HelloWorldService 시스템 서비스 빌드</h4><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">make</span><br></code></pre></td></tr></table></figure><p>명령어를 통해 안드로이드 플랫폼을 컴파일 한다.  </p>]]></content>
    
    
    <categories>
      
      <category>Android</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Android</tag>
      
      <tag>인사이드 안드로이드</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[인사이드 안드로이드] 챕터 7 - 안드로이드 바인더 IPC</title>
    <link href="/chapter7/"/>
    <url>/chapter7/</url>
    
    <content type="html"><![CDATA[<h1 id="인사이드-안드로이드"><a href="#인사이드-안드로이드" class="headerlink" title="[인사이드 안드로이드]"></a>[인사이드 안드로이드]</h1><h2 id="Chapter7-안드로이드-바인더-IPC"><a href="#Chapter7-안드로이드-바인더-IPC" class="headerlink" title="Chapter7 - 안드로이드 바인더 IPC"></a>Chapter7 - 안드로이드 바인더 IPC</h2><h3 id="리눅스-메모리-공간과-바인더-드라이버"><a href="#리눅스-메모리-공간과-바인더-드라이버" class="headerlink" title="리눅스 메모리 공간과 바인더 드라이버"></a>리눅스 메모리 공간과 바인더 드라이버</h3><p>바인더를 이해하려면 먼저 안드로이드의 기반 커널인 리눅스 커널의 메모리 공간을 이해할 필요가 있다. 총 4GB에 달하는 가상 주소 공간은 3GB의 사용자 공간과 1GB의 커널 공간으로 나뉜다. 사용자 코드와 관련 라이브러리는 사용자 공간의 코드 영역, 데이터 영역, 스택 영역에서 동작하고, 커널 공간에서 동작해야 할 코드는 커널 공간의 각 영역에서 동작한다. 그리고 프로세스는 다음과 같이 각자 독립된 주소 공간을 가지고 별개로 동작한다.  </p><p><img src="/images/post/binder1.png" alt="binder1" title="binder1">  </p><p>자신의 독립된 공간을 가진 프로세스가 다른 프로세스에게 <strong>데이터를 전달할 때는 프로세스간 공유가 가능한 커널 공간을 이용한다.</strong> 프로세스는 독립적인 사용자 공간을 가지지만 커널 공간은 공유할 수 있다. 커널 공간을 이용해 두 프로세스 사이의 메시지를 주고 받는 IPC를 수행한다.  </p><p>기존 리눅스에서도 IPC 도구를 제공하지만, 안드로이드에서는 단순히 메시지를 전달하는 IPC 개념이 아니라 상대방 프로세스에 존재하는 함수까지 호출할 수 있는 바인더라는 IPC 도구를 채택해 프로세스 간의 RPC를 지원한다.  </p><p>바인더는 프로세스들이 사용자 공간을 공유하지 않는다는 제약 조건상에서 프로세스간 통신을 제공하기 위해 다음처럼 커널 공간에서 동작하는 Binder(IPC) Driver라는 추상화된 드라이버를 이용한다.  </p><p><img src="/images/post/binder2.png" alt="binder2" title="binder2">  </p><p>안드로이드에서 바인더 드라이버를 추가해서 프로세스 간 통신을 수행하는 이유는 다음과 같다. 바인더는 사용자 공간에서 접근할 수 없는 공간인 커널 공간을 이용해 <strong>데이터의 신뢰성을 확보</strong>할 수 있으며 <strong>IPC 간의 보안 문제도 동시에 해결</strong>할 수 있다.  </p><h3 id="안드로이드-바인더-모델"><a href="#안드로이드-바인더-모델" class="headerlink" title="안드로이드 바인더 모델"></a>안드로이드 바인더 모델</h3><p>IPC 데이터는 함수 호출과 관련된 내용, 즉 사용하고자 하는 서비스에 해당하는 번호와 호출할 함수명, 바인더 프로토콜로 구성된다.<br><em>서비스 번호는 안드로이드에서 동작중인 여러 서비스를 구분하기 위한 것.</em><br><em>함수명은 서비스 서버에서 동작하는 여러 서비스 가운데 서비스 클라이언트가 호출할 함수를 찾기 위한 것.</em><br><em>바인더 프로토콜은 바인더 드라이버와 바인더를 이용하는 프로세스 간의 IPC 데이터를 처리하는 규약.</em>  </p><p><img src="/images/post/binder3.png" alt="binder3" title="binder3">  </p><p><em>핸들은 서비스를 구별하는 번호</em><br><em>RPC 코드와 RPC 데이터는 서비스에서 호출할 함수와 함수의 인자</em><br><em>바인터 프로토콜은 IPC 데이터의 처리 방법</em>  </p><h4 id="바인더-IPC-데이터의-전달"><a href="#바인더-IPC-데이터의-전달" class="headerlink" title="바인더 IPC 데이터의 전달"></a>바인더 IPC 데이터의 전달</h4><p>바인더 드라이버는 문자 디바이스 드라이버처럼 open()이나 ioctl()과 같은 시스템 콜을 통해 접근 가능하다. 다음 그림은 시스템 콜과 바인더 드라이버에 포함된 파일 연산 함수와의 연결 관계를 보여준다.  </p><p><img src="/images/post/binder4.png" alt="binder4" title="binder4">  </p><p>① 바인더를 통해 RPC를 시도하는 응용 프로그램은 open() 시스템 콜을 통해 바인더 드라이버의 파일 디스크립터를 얻는다.<br>② mmap() 시스템콜을 통해 커널 내에서 IPC 데이터를 수신하기 위한 공유 공간을 확보한다.<br>③ ioctl() 함수의 인자로 바인더 드라이버에 IPC 데이터를 전달한다. ioctl(파일 디스크립터, ioctl 명령어, 데이터 타입)  </p><h4 id="바인더-IPC-데이터의-흐름"><a href="#바인더-IPC-데이터의-흐름" class="headerlink" title="바인더 IPC 데이터의 흐름"></a>바인더 IPC 데이터의 흐름</h4><p>바인더 IPC 데이터가 서비스 클라이언트에서 서비스 서버로 전달되기 까지 어떠한 과정을 거치는지 살펴보자.<br>그림은 서비스 클라이언트에서 서비스 서버에 존재하는 서비스의 함수를 호출하는 과정을 보여준다.  </p><p><img src="/images/post/binder5.png" alt="binder5" title="binder5">  </p><ul><li>서비스 계층 : 특정 기능을 수행하는 서비스의 함수가 존재하는 계층이다. 서비스 클라이언트는 이 계층에서 사용하고자 하는 서비스의 함수를 가상으로 호출하고, 서비스 서버는 서비스 클라이언트가 요청한 서비스의 함수를 실제로 호출한다.  </li><li>RPC 계층 : 서비스 클라이언트는 이 계층에서 서비스의 함수를 호출하기 위한 RPC 코드와 RPC 데이터를 생성한다. 서비스 서버는 전달받은 RPC 코드를 토대로 함수를 찾고 RPC 데이터를 전달한다.  </li><li>IPC 계층 : RPC 계층에서 만든 RPC 코드와 RPC 데이터를 바인더 드라이버에 전달하기위한 바인더 IPC 데이터로 캡슐화하는 역할을 한다.  </li><li>바인더 드라이버 계층 : IPC 계층으로부터 전달받은 바인더 IPC 데이터를 통해 서비스를 가진 서비스서버를 찾은 후 IPC 데이터를 전달한다.</li></ul><p>서비스 클라이언트가 바인더 드라이버에게 ioctl() 시스템콜을 통해 바인더 IPC 데이터를 전달하면 바인더 드라이버는 이 데이터를 서비스 서버에게 전달한다. 이때 바인더 드라이버는 IPC 데이터에서 바인더 프로토콜을 파악하여 데이터 전달 여부를 결정한다.  </p><h4 id="바인더-프로토콜"><a href="#바인더-프로토콜" class="headerlink" title="바인더 프로토콜"></a>바인더 프로토콜</h4><p>바인더 프로토콜은 바인더 IPC 데이터에 포함되어 IPC 계층에서 바인더 드라이버로 전달되거나 바인더 드라이버에서 IPC 계층으로 전달된다. 바인더 프로토콜은 전달 방향에 따라 두 가지로 분류된다.  </p><p><img src="/images/post/binder6.png" alt="binder6" title="binder6">  </p><p>바인더 프로토콜은 흔히 네트워크 상에서 쓰는 프로토콜처럼 데이터를 송신하는 측과 수신하는 측에서 모두 알고 있는 규약이다. 따라서 바인더 IPC를 이용하는 프로세스와 바인더 드라이버는 헤더 파일에 바인더 프로토콜을 정의하고 있다.  </p><p>다음 그림은 바인더 프로토콜에 따른 바인더 드라이버와 IPC 데이터 수신 측의 동작을 간략히 나타낸 것이다.  </p><p><img src="/images/post/binder7.png" alt="binder7" title="binder7">  </p><h4 id="RPC-코드와-RPC-데이터"><a href="#RPC-코드와-RPC-데이터" class="headerlink" title="RPC 코드와 RPC 데이터"></a>RPC 코드와 RPC 데이터</h4><p>서비스 클라이언트는 서비스 서버에 존재하는 서비스의 함수를 사용하기 위해 각 함수에 해당하는 식별자를 바인더 IPC 데이터에 담아 전달하는데, 이를 RPC 코드라고 한다. 그리고 함수의 인자 역시 IPC 데이터에 담아 전달하는데, 이것은 RPC 데이터라고 한다.<br>다음은 Audio Flinger 서비스를 사용하는 MP# 애플리케이션의 예이다.  </p><p><img src="/images/post/binder8.png" alt="binder8" title="binder8">  </p><h4 id="바인더-어드레싱"><a href="#바인더-어드레싱" class="headerlink" title="바인더 어드레싱"></a>바인더 어드레싱</h4><p>안드로이드에는 다양한 서비스를 모두 목록화해서 관리하는 컨텍스트 매니저(Context Manager)라는 특별한 프로세스가 있다. 컨텍스트 매니저는 서비스마다 핸들(바인더 IPC의 목적지 주소로 사용)이라는 번호 값을 할당하고, 서비스의 추가&#x2F;검색 등의 관리 기능을 수행한다.  </p><p>바인더 드라이버는 IPC 데이터의 핸들을 가지고 서비스 서버를 찾는데, 이러한 과정을 바인더 어드레싱(Binder Addressing) 이라고 정의한다. 바인더 어드레싱을 위해 서비스 서버는 자신이 가진 서비스에 대한 접근 정보를 컨텍스트 매니저에 등록해야 한다. 이러한 서비스 등록 과정에서 서비스 서버는 ADD_SERVICE라는 RPC 코드와 등록할 서비스 이름(RPC 데이터), 그리고 핸들을 0으로 지정하고 IPC 데이터에 실어 바인더 드라이버에 전달한다.  </p><p>다음 그림은 서비스 서버가 자신의 서비스를 컨텍스트 매니저에게 등록 할 때의 바인더 어드레싱을 나타낸다.  </p><p><img src="/images/post/binder9.png" alt="binder9" title="binder9">  </p><p>다음으로 서비스 클라이언트가 서비스를 검색 할 때의 바인더 어드레싱을 나타낸다.  </p><p><img src="/images/post/binder10.png" alt="binder10" title="binder10">  </p><p>마지막으로 서비스 클라이언트는 이전 단계에서 전달받은 참조 데이터의 번호를 핸들에 저장하고, 사용할 서비스의 함수에 해당하는 RPC 코드와 RPC 데이터를 IPC 데이터에 담아 서비스 서버로 전달하여 서비스A가 가진 함수를 호출한다.<br>다음 그림은 바인더 어드레싱을 통해 서비스를 사용하는 과정을 보여준다.  </p><p><img src="/images/post/binder11.png" alt="binder11" title="binder11">  </p>]]></content>
    
    
    <categories>
      
      <category>Android</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Android</tag>
      
      <tag>인사이드 안드로이드</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[인사이드 안드로이드] 챕터 6 - 안드로이드 서비스 개요(2)</title>
    <link href="/chapter6_2/"/>
    <url>/chapter6_2/</url>
    
    <content type="html"><![CDATA[<h1 id="인사이드-안드로이드"><a href="#인사이드-안드로이드" class="headerlink" title="[인사이드 안드로이드]"></a>[인사이드 안드로이드]</h1><h2 id="Chapter6-안드로이드-서비스-개요-2"><a href="#Chapter6-안드로이드-서비스-개요-2" class="headerlink" title="Chapter6 - 안드로이드 서비스 개요(2)"></a>Chapter6 - 안드로이드 서비스 개요(2)</h2><h3 id="안드로이드-시스템-서비스"><a href="#안드로이드-시스템-서비스" class="headerlink" title="안드로이드 시스템 서비스"></a>안드로이드 시스템 서비스</h3><p>안드로이드의 시스템 서비스는 디바이스 제어, 위치 정보 제공, 알람 설정 및 통지 메시지 표시 등과 같이 시스템의 가장 기본적인 핵심 기능들을 제공한다. 이러한 시스템 서비스는 애플리케이션 프레임워크 레이어와 라이브러리 레이어에 각각 존재한다.  </p><p><img src="/images/post/service4.png" alt="service4" title="service4">  </p><h4 id="시스템-서비스의-분류"><a href="#시스템-서비스의-분류" class="headerlink" title="시스템 서비스의 분류"></a>시스템 서비스의 분류</h4><h5 id="네이티브-시스템-서비스"><a href="#네이티브-시스템-서비스" class="headerlink" title="네이티브 시스템 서비스"></a>네이티브 시스템 서비스</h5><p>네이티브 시스템 서비스는 C++로 작성돼 있으며 라이브러리 레이어에서 동작한다.<br>주요 서비스로는 ① Audio Flinger와 ② Surface Flinger 등이 있다.  </p><p><strong>① Audio Flinger 서비스</strong>  </p><p>Audio Flinger 서비스는 여러 안드로이드 애플리케이션의 오디오 데이터를 믹싱해서 헤드폰이나 스피커처럼 <strong>다양한 오디오 출력 장치로 내보내는 역할</strong>을 한다. <strong>안드로이드장치에서 모든 오디오 데이터는 Audio Flinger를 거쳐 출력된다.</strong>  </p><p><img src="/images/post/service5.png" alt="service5" title="service5">  </p><p><strong>② Surface Flinger 서비스</strong>  </p><p>Surface Flinger는 다양한 애플리케이션에서 사용중인 <strong>Surface를 조합해 프레임 버퍼 장치로 렌더링</strong>해주는 서비스다.  </p><p><img src="/images/post/service6.png" alt="service6" title="service6">  </p><h5 id="자바-시스템-서비스"><a href="#자바-시스템-서비스" class="headerlink" title="자바 시스템 서비스"></a>자바 시스템 서비스</h5><p>자바 시스템 서비스는 안드로이드 부팅 시 SystemServer라는 시스템 프로세스에 의해 일괄적으로 실행되며, ① 코어 플랫폼 서비스와 ② 하드웨어 서비스로 나뉜다.  </p><p><strong>① 코어 플랫폼 서비스</strong>  </p><p>코어 플랫폼 서비스는 일반적으로 안드로이드 애플리케이션과 직접 상호작용은 하지 않지만 <strong>안드로이드 프레임워크가 동작하는 데 필수적인 서비스</strong>를 말한다.  </p><table><thead><tr><th align="center">코어 플랫폼 서비스</th><th align="center">기능</th></tr></thead><tbody><tr><td align="center"><code>Activity Manager Service</code></td><td align="center">모든 액티비티에 대한 라이프 사이클 및 액티비티 스택 관리</td></tr><tr><td align="center"><code>Window Manager Service</code></td><td align="center">Surface Flinger 위에 위치하며, 기기 화면에 그릴 내용을 Surface Flinger로 전달</td></tr><tr><td align="center"><code>Package Manager Service</code></td><td align="center">apk파일의 정보를 로딩, 시스템에 어떤 패키지가 설치되고 로딩돼 있는지에 대한 정보 제공</td></tr></tbody></table><p><strong>② 하드웨어 서비스</strong>  </p><p>저수준 하드웨어 제어를 위한 API를 제공하는 서비스를 말한다.  </p><table><thead><tr><th align="center">하드웨어 서비스</th><th align="center">기능</th></tr></thead><tbody><tr><td align="center"><code>Alarm Manager Service</code></td><td align="center">타이머처럼 특정 시간 후에 애플리케이션을 실행하는 등의 동작을 수행</td></tr><tr><td align="center"><code>Connectivity Service</code></td><td align="center">네트워크의 현재 상태에 대한 정보를 제공</td></tr><tr><td align="center"><code>Location Service</code></td><td align="center">단말의 현재 위치 정보를 제공</td></tr><tr><td align="center"><code>Power Service</code></td><td align="center">장치의 전원 관리를 제어</td></tr><tr><td align="center"><code>Sensor Service</code></td><td align="center">안드로이드에 설치된 각종 센서(마그네틱 센서, 가속도 센서 등)의 센싱 값을 제공</td></tr><tr><td align="center"><code>Telephony Service</code></td><td align="center">전화기의 상태나 전화 서비스에 대한 정보를 제공</td></tr><tr><td align="center"><code>Wifi Service</code></td><td align="center">AP 검색이나 연결 리스트 관리 등 무선랜 연결을 제어</td></tr></tbody></table><p><strong>자바 시스템 서비스 이용</strong>  </p><p>프레임워크 내부에서나 안드로이드 애플리케이션에서 이러한 자바 시스템 서비스를 이용하려면 <strong>각 서비스와 통신 가능한 Local Manager 객체</strong>를 이용해야 한다.  </p><h3 id="시스템-서비스의-실행"><a href="#시스템-서비스의-실행" class="headerlink" title="시스템 서비스의 실행"></a>시스템 서비스의 실행</h3><p>안드로이드 애플리케이션에서 애플리케이션 서비스를 실행할 경우 일반적으로 startService() API함수를 사용한다. 그러나 시스템 서비스는 애플리케이션 서비스와 달리 서비스를 직접 실행할 필요가 없이 getSystemService()를 이용해서 바로 이용할 수 있다. <strong>시스템 서비스는 init 프로세스에 의해 안드로이드 부팅 과정에서 미리 실행되기 때문이다.</strong>  </p><p><img src="/images/post/service7.png" alt="service7" title="service7">  </p><h4 id="미디어-서버의-실행-코드-분석"><a href="#미디어-서버의-실행-코드-분석" class="headerlink" title="미디어 서버의 실행 코드 분석"></a>미디어 서버의 실행 코드 분석</h4><h5 id="init-프로세스로부터-실행"><a href="#init-프로세스로부터-실행" class="headerlink" title="init 프로세스로부터 실행"></a>init 프로세스로부터 실행</h5><p>미디어 서버(Media Server)는 Audio Flinger, Media Player Service, Camera Service, Audio Policy Service 등의 네이티브 시스템 서비스를 실행하는 시스템 프로세스로서 init 프로세스에 의해 실행된다.  </p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">service media /system/bin/mediaserver<br>    <span class="hljs-keyword">user</span> <span class="hljs-title">media</span><br>    <span class="hljs-keyword">group</span> <span class="hljs-title">system</span> audio camera graphics inet net_bt net_bt_admin<br></code></pre></td></tr></table></figure><h5 id="네이티브-서비스-인스턴스-생성-및-초기화"><a href="#네이티브-서비스-인스턴스-생성-및-초기화" class="headerlink" title="네이티브 서비스 인스턴스 생성 및 초기화"></a>네이티브 서비스 인스턴스 생성 및 초기화</h5><p>다음은 미디어 서버에 포함된 main() 함수의 주요 부분이다. 여기서는 각 네이티브 서비스에 대한 인스턴스를 생성하고 초기화하는 작업을 수행한다.  </p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs css">int <span class="hljs-selector-tag">main</span>(int argc, char** argv)<br>&#123;<br>  :<br>  AudioFlinger::<span class="hljs-built_in">instantiate</span>();<br>  MediaPlayerService::<span class="hljs-built_in">instantiate</span>();<br>  CameraService::<span class="hljs-built_in">instantiate</span>();<br>  AudioPolicyService::<span class="hljs-built_in">instantiate</span>();<br>  :<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="각-시스템-서비스별-초기화-코드-살펴보기"><a href="#각-시스템-서비스별-초기화-코드-살펴보기" class="headerlink" title="각 시스템 서비스별 초기화 코드 살펴보기"></a>각 시스템 서비스별 초기화 코드 살펴보기</h5><p>시스템 서비스는 프레임워크 내에서 다른 모듈과 통신할 때 바인더 IPC를 사용한다.<br><em>(다음장, 애플리케이션과 같은 서비스 이용자가 시스템 서비스를 이용할 수 있게 서비스 제공자의 정보를 컨텍스트 매니저에 등록)</em>  </p><p>다음은 네이티브 서비스의 초기화 코드를 모아놓은 것이다. new 연산자를 통해 서비스 인스턴스를 생성한 다음 addService() 함수를 이용해서 컨텍스트 매니저에게 각 서비스를 등록한다.<br>여기서 defaultServiceManager() 함수는 컨텍스트 매니저와 바인더 통신을 하는 일종의 프록시 객체인 서비스 매니저를 반환한다. (자세한 내용은 8장)  </p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-comment">// Audio Flinger 초기화 코드</span><br>void AudioFlinger::<span class="hljs-built_in">instantiate</span>() &#123;<br>    <span class="hljs-built_in">defaultServiceManager</span>()-&gt;<span class="hljs-built_in">addService</span>(<br>            String16(&quot;media.audio_flinger&quot;), new <span class="hljs-built_in">AudioFlinger</span>());<br>&#125;<br><br><span class="hljs-comment">// Media Player Service 초기화 코드</span><br>void MediaPlayerService::<span class="hljs-built_in">instantiate</span>() &#123;<br>    <span class="hljs-built_in">defaultServiceManager</span>()-&gt;<span class="hljs-built_in">addService</span>(<br>            String16(&quot;media.player&quot;), new <span class="hljs-built_in">MediaPlayerService</span>());<br>&#125;<br><br><span class="hljs-comment">// Camera Service 초기화 코드</span><br>void CameraService::<span class="hljs-built_in">instantiate</span>() &#123;<br>    <span class="hljs-built_in">defaultServiceManager</span>()-&gt;<span class="hljs-built_in">addService</span>(<br>            String16(&quot;media.camera&quot;), new <span class="hljs-built_in">CameraService</span>());<br>&#125;<br><br><span class="hljs-comment">// Audio Policy Service 초기화 코드</span><br>void AudioPolicyService::<span class="hljs-built_in">instantiate</span>() &#123;<br>    <span class="hljs-built_in">defaultServiceManager</span>()-&gt;<span class="hljs-built_in">addService</span>(<br>            String16(&quot;media.audio_policy&quot;), new <span class="hljs-built_in">AudioPolicyService</span>());<br>&#125;<br></code></pre></td></tr></table></figure><p>미디어 서버는 각 서비스의 인스턴스를 생성한 다음, 생성된 서비스를 컨텍스트 매니저에 등록하는 것이 전부다.  </p><p><img src="/images/post/service8.png" alt="service8" title="service8">  </p><h4 id="시스템-서버의-실행-코드-분석"><a href="#시스템-서버의-실행-코드-분석" class="headerlink" title="시스템 서버의 실행 코드 분석"></a>시스템 서버의 실행 코드 분석</h4><p>시스템 서버는 자바 프로세스이므로 Zygote로부터 생성된다. 시스템 서버가 어떻게 시스템 서비스를 생성하는지 코드를 바탕으로 알아보자.  </p><h5 id="Zygote-프로세스로부터-생성"><a href="#Zygote-프로세스로부터-생성" class="headerlink" title="Zygote 프로세스로부터 생성"></a>Zygote 프로세스로부터 생성</h5><p>Zygote는 맨 처음 생성되는 달빅 가성 머신 기반의 자바 프로세스로서 네이티브 시스템 서비스인 Surface Flinger를 비롯해 다양한 자바 시스템 서비스를 실행하는 역할을 한다.  </p><p>Zygote 실행 시에 -start-system-server라는 옵션이 정의된 것을 확인할 수 있다. 이 옵션은 Zygote에서 시스템 서버를 생성하라고 요청하는 역할을 한다.  </p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs angelscript">service zygote /system/bin/app_process -Xzygote /system/bin --zygote --start-system-server<br>    <span class="hljs-keyword">class</span> <span class="hljs-symbol">main</span><br>    <span class="hljs-symbol">socket</span> <span class="hljs-symbol">zygote</span> <span class="hljs-symbol">stream</span> <span class="hljs-symbol">660</span> <span class="hljs-symbol">root</span> <span class="hljs-symbol">system</span><br>    <span class="hljs-symbol">onrestart</span> <span class="hljs-symbol">write</span> /<span class="hljs-symbol">sys</span>/<span class="hljs-symbol">android_power</span>/<span class="hljs-symbol">request_state</span> <span class="hljs-symbol">wake</span><br>    <span class="hljs-symbol">onrestart</span> <span class="hljs-symbol">write</span> /<span class="hljs-symbol">sys</span>/<span class="hljs-symbol">power</span>/<span class="hljs-symbol">state</span> <span class="hljs-symbol">on</span><br>    <span class="hljs-symbol">onrestart</span> <span class="hljs-symbol">restart</span> <span class="hljs-symbol">media</span><br>    <span class="hljs-symbol">onrestart</span> <span class="hljs-symbol">restart</span> <span class="hljs-symbol">netd</span><br></code></pre></td></tr></table></figure><h5 id="android-servers-라이브러리-로드"><a href="#android-servers-라이브러리-로드" class="headerlink" title="android_servers 라이브러리 로드"></a>android_servers 라이브러리 로드</h5><p>다음은 SystemServer의 main() 메서드를 나타내는 코드다.<br>android_servers 라이브러리를 로드하고 init1()메서드를 호출한다. init1() 메서드는 JNI를 통해 다음 system_init() 네이티브 함수를 호출한다.</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SystemServer</span> &#123;<br>  <span class="hljs-function">native <span class="hljs-keyword">public</span> <span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">init1</span><span class="hljs-params">(<span class="hljs-type">String</span>[] args)</span></span>;<br><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">String</span>[] args)</span> </span>&#123;<br>    System.<span class="hljs-built_in">loadLibrary</span>(<span class="hljs-string">&quot;android_servers&quot;</span>);<br>    <span class="hljs-built_in">init1</span>(args);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>system_init() 함수의 주된 기능은 Surface Flinger 네이티브 시스템 서비스를 초기화하는 것이다.  </p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">extern</span> <span class="hljs-string">&quot;C&quot;</span> status_t <span class="hljs-title function_ invoke__">system_init</span>()<br>&#123;<br>    SurfaceFlinger::<span class="hljs-title function_ invoke__">instantiate</span>(); <span class="hljs-comment">// JNI를 이용해 Surface Flinger 서비스 실행</span><br><br>    AndroidRuntime* runtime = AndroidRuntime::<span class="hljs-title function_ invoke__">getRuntime</span>();<br>    JNIEnv* env = runtime<span class="hljs-punctuation">-&gt;</span><span class="hljs-title function_ invoke__">getJNIEnv</span>();<br><br>    jclass clazz = env<span class="hljs-punctuation">-&gt;</span><span class="hljs-title function_ invoke__">FindClass</span>(<span class="hljs-string">&quot;com/android/server/SystemServer&quot;</span>);<br>    jmethodID methodId = env<span class="hljs-punctuation">-&gt;</span><span class="hljs-title function_ invoke__">GetStaticMethodID</span>(clazz, <span class="hljs-string">&quot;init2&quot;</span>, <span class="hljs-string">&quot;()V&quot;</span>); <span class="hljs-comment">// SystemServer 클래스의 init2() 메서드를 호출한다.</span><br><br>    <span class="hljs-keyword">return</span> NO_ERROR;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="자바-시스템-서비스-초기화-및-등록"><a href="#자바-시스템-서비스-초기화-및-등록" class="headerlink" title="자바 시스템 서비스 초기화 및 등록"></a>자바 시스템 서비스 초기화 및 등록</h5><p>SystemServer에서 Surface Flinger를 초기화하고 나면 init2() 메서드가 호출된다. 이 메서드는 Entropy 서비스부터 AppWidget 서비스까지 <strong>안드로이드의 모든 자바 시스템 서비스를 생성하고 초기화하는 역할</strong>을 한다.<br>init2() 메서드에서는 ServerThread를 생성한 다음 실행한다.<br>이렇게 실행된 자바 시스템 서비스 역시 네이티브 시스템 서비스처럼 다른 모듈이 서비스를 활용할 수 있게끔 해당 서비스를 컨텍스트 매니저에 등록해야 한다. 자바 시스템 서비스는 ServiceManager 클래스의 <strong>addService() 정적 메서드를 이용해서 컨텍스트 매니저에 자신을 등록</strong>한다.  </p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">public static final void init2<span class="hljs-literal">()</span> &#123;<br>    Thread thr = <span class="hljs-keyword">new</span> <span class="hljs-constructor">ServerThread()</span>;<br>    thr.set<span class="hljs-constructor">Name(<span class="hljs-string">&quot;android.server.ServerThread&quot;</span>)</span>;<br>    thr.start<span class="hljs-literal">()</span>;<br>&#125;<br><br><span class="hljs-keyword">class</span> ServerThread extends Thread &#123;<br>  :<br>  <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Slog</span>.</span></span>i(TAG, <span class="hljs-string">&quot;Entropy Mixer&quot;</span>);<br>  <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">ServiceManager</span>.</span></span>add<span class="hljs-constructor">Service(<span class="hljs-string">&quot;entropy&quot;</span>, <span class="hljs-params">new</span> EntropyMixer()</span>);<br><br>  <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Slog</span>.</span></span>i(TAG, <span class="hljs-string">&quot;Power Manager&quot;</span>);<br>  power = <span class="hljs-keyword">new</span> <span class="hljs-constructor">PowerManagerService()</span>;<br>  <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">ServiceManager</span>.</span></span>add<span class="hljs-constructor">Service(Context.POWER_SERVICE, <span class="hljs-params">power</span>)</span>;<br><br>  <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Slog</span>.</span></span>i(TAG, <span class="hljs-string">&quot;Activity Manager&quot;</span>);<br>  context = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">ActivityManagerService</span>.</span></span>main(factoryTest);<br><br>  <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Slog</span>.</span></span>i(TAG, <span class="hljs-string">&quot;Telephony Registry&quot;</span>);<br>  <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">ServiceManager</span>.</span></span>add<span class="hljs-constructor">Service(<span class="hljs-string">&quot;telephony.registry&quot;</span>, <span class="hljs-params">new</span> TelephonyRegistry(<span class="hljs-params">context</span>)</span>);<br><br>  :<br>  :<br><br>  <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Slog</span>.</span></span>i(TAG, <span class="hljs-string">&quot;Backup Service&quot;</span>);<br>  <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">ServiceManager</span>.</span></span>add<span class="hljs-constructor">Service(Context.BACKUP_SERVICE, <span class="hljs-params">new</span> BackupManagerService(<span class="hljs-params">context</span>)</span>);<br><br>  <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Slog</span>.</span></span>i(TAG, <span class="hljs-string">&quot;AppWidget Service&quot;</span>);<br>  appWidget = <span class="hljs-keyword">new</span> <span class="hljs-constructor">AppWidgetService(<span class="hljs-params">context</span>)</span>;<br>  <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">ServiceManager</span>.</span></span>add<span class="hljs-constructor">Service(Context.APPWIDGET_SERVICE, <span class="hljs-params">appWidget</span>)</span>;<br><br>  :<br>  :<br>&#125;<br><br></code></pre></td></tr></table></figure><p><img src="/images/post/service9.png" alt="service9" title="service9">  </p><h3 id="안드로이드-서비스-프레임워크와-바인더-드라이버-개요-및-용어-정리"><a href="#안드로이드-서비스-프레임워크와-바인더-드라이버-개요-및-용어-정리" class="headerlink" title="안드로이드 서비스 프레임워크와 바인더 드라이버 개요 및 용어 정리"></a>안드로이드 서비스 프레임워크와 바인더 드라이버 개요 및 용어 정리</h3><h4 id="주요-용어-정리"><a href="#주요-용어-정리" class="headerlink" title="주요 용어 정리"></a>주요 용어 정리</h4><p><strong>서비스 서버</strong> : 시스템 서비스를 실행하는 프로세스로서 앞에서 설명한 시스템 서버나 미디어 서버가 여기에 해당한다.<br><strong>서비스 클라이언트</strong> : 시스템 서비스를 사용하는 프로세스를 일컫는다.<br><strong>컨텍스트 매니저</strong> : 시스템 서비스를 관리하는 안드로이드 시스템 프로세스로서 시스템에 설치돼 있는 각종 시스템 서비스의 위치 정보인 핸들을 관리한다. 이러한 핸들은 바인더 IPC의 목적지 주소를 지정하는 데 사용된다.<br><strong>서비스 프레임워크</strong> : 서비스 매니저를 포함해서 서비스 사용자와 시스템 서비스간의 RPC 동작에 필요한 공통적인 클래스가 정의돼 있다.<br><strong>서비스 인터페이스</strong> : 서비스 사용자와 시스템 서비스 간에 미리 정해진 인터페이스로서 시스템 서비스는 해당 인터페이스에 맞게 스텁 함수를 구현해서 해당 서비스를 제공해야 하고, 반대로 서비스 사용자 역시 해당 인터페이스에 맞게 서비스를 호출해야 한다.<br><strong>서비스 사용자</strong> : 서비스 클라이언트 프로세스 내에서 실제 서비스를 이용하는 모듈이다.<br><strong>서비스</strong> : 서비스 인터페이스에 정의된 기능을 서비스 스텁 함수로 구현해서 실제 서비스의 기능을 제공하는 모듈을 의미한다.<br><strong>서비스 프록시</strong> : RPC 수행 시 데이터 마샬링을 수행하는 객체이며 서비스 인터페이스별로 존재한다. 서비스 인터페이스에 정의된 함수별로 각각 데이터 마샬링을 수행하는 서비스 프록시 함수를 제공한다.<br><strong>서비스 스텁</strong> : RPC 수행 시 데이터 언마샬링을 수행하는 객체이며, 이 객체 역시 서비스 인터페이스별로 존재한다. 수신된 데이터를 언마샬링해서 연관된 서비스 스텁 함수를 호출한다.<br><strong>바인더 드라이버</strong> : 바인더는 안드로이드에서 IPC를 지원하는 데 사용되는 메커니즘으로 안드로이드 리눅스 커널의 디바이스 드라이버 형태로 포함돼 있다.<br><strong>바인더 IPC</strong> : 안드로이드에서 바인더 드라이버를 통한 프로세스간의 데이터 전달 방식을 말한다.<br><strong>바인더 IPC 데이터</strong> : 서비스 프레임워크와 바인더 드라이버 사이에 사용되는 데이터 포맷<br><strong>바인더 RPC</strong> : 서비스 사용자가 서비스에서 제공하는 특정 서비스 인터페이스 기반의 함수를 마치 자신의 로컬 함수 호출하듯이 원격으로 처리하는 동작을 말한다. 바인더 RPC는 내부적으로는 바인더 IPC 메커니즘 기반으로 동작한다.<br><strong>바인더 RPC 데이터</strong> : 서비스 사용자와 서비스 간의 바인더 RPC를 수행하는 데 사용되는 데이터</p><p>다음 그림은 서비스 동작 원리를 일반화한 것으로서 Foo라는 시스템 서비스에서 제공하는 foo() 메서드를 서비스 사용자가 RPC 형태로 호출하는 모습을 보여준다.  </p><p><img src="/images/post/service10.png" alt="service10" title="service10">  </p><p>서비스 사용자는 foo() 프록시 함수를 호출해서 Foo 서비스를 이용하기 위한 인자로 구성된 바인더 RPC 데이터를 전달한다. 바인더 PRC 데이터는 마샬링을 거쳐 서비스 프레임워크를 통해 바인더 IPC 데이터로 생성된 다음 바인더 드라이버를 통해 서비스 서버 측에 전송된다.  </p><p>서비스 서버 측에서 수신된 바인더 IPC 데이터는 서비스 프레임워크를 거치면서 언마샬링된 다음, 서비스 스텁의 onTransact() 함수에 전송된다. 서비스 스텁은 해당 바인더 IPC 데이터 안에 포함된 RPC 코드를 통해 Foo 서비스의 foo() 서비스 스텁 함수에 대한 바인더 RPC임을 판단한다. 수신된 바인더 IPC 데이터에 포함된 바인더 RPC 데이터를 인자로 해서 foo() 서비스 스텁 함수를 호출한다.  </p>]]></content>
    
    
    <categories>
      
      <category>Android</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Android</tag>
      
      <tag>인사이드 안드로이드</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[인사이드 안드로이드] 챕터 6 - 안드로이드 서비스 개요</title>
    <link href="/chapter6/"/>
    <url>/chapter6/</url>
    
    <content type="html"><![CDATA[<h1 id="인사이드-안드로이드"><a href="#인사이드-안드로이드" class="headerlink" title="[인사이드 안드로이드]"></a>[인사이드 안드로이드]</h1><h2 id="Chapter6-안드로이드-서비스-개요"><a href="#Chapter6-안드로이드-서비스-개요" class="headerlink" title="Chapter6 - 안드로이드 서비스 개요"></a>Chapter6 - 안드로이드 서비스 개요</h2><h3 id="예제-프로그램-안드로이드-서비스-동작-이해"><a href="#예제-프로그램-안드로이드-서비스-동작-이해" class="headerlink" title="예제 프로그램 : 안드로이드 서비스 동작 이해"></a>예제 프로그램 : 안드로이드 서비스 동작 이해</h3><p>안드로이드에서 서비스는 UI 없이 주기적으로 특정한 일을 수행하는 백그라운드 프로세스를 가리킨다. 따라서 안드로이드 프로그램을 작성할 때 개발자가 적절한 애플리케이션 서비스를 직접 구현해서 적용한다면 더 반응성이 좋은 애플리케이션을 개발할 수 있다.  </p><p>간단한 예제를 통해 안드로이드 서비스의 동작 방식을 알아보기 위해 ApiDemo 샘플 예제의 Alarm Service 코드를 본다.  </p><p>이 프로그램은 크게 메인 액티비티와 두개의 시스템 서비스, AlarmService_Service라는 애플리케이션 서비스로 구성돼 있다.<br>(1) 메인 액티비티 상에서 Start 버튼을 누르면 시스템 서비스인 Alarm Service에 30초마다 사용자가 작성한 애플리케이션 서비스인 AlarmService_Service를 실행해 달라고 요청한다.<br>(2) Alarm Service는 사용자의 요청에 따라 30초마다 AlarmService_Service라는 애플리케이션 서비스를 실행한다.  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-type">OnClickListener</span> <span class="hljs-variable">mStartAlarmListener</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">OnClickListener</span>() &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onClick</span><span class="hljs-params">(View v)</span> &#123;<br>        <span class="hljs-type">long</span> <span class="hljs-variable">firstTime</span> <span class="hljs-operator">=</span> SystemClock.elapsedRealtime();<br><br>        <span class="hljs-type">AlarmManager</span> <span class="hljs-variable">am</span> <span class="hljs-operator">=</span> (AlarmManager)getSystemService(ALARM_SERVICE);<br>        am.setRepeating(AlarmManager.ELAPSED_REALTIME_WAKEUP,<br>                        firstTime, <span class="hljs-number">30</span>*<span class="hljs-number">1000</span>, mAlarmSender); <span class="hljs-comment">// (1, 2)</span><br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>(3) AlarmService_Service는 실행되자마자 시스템 서비스인 Notification Service에 AlarmService_Service 서비스가 시작됐음을 알리는 문자열 출력을 요청한다.<br>(4) Notification Service는 AlarmService_Service에게서 전달받은 문자열을 화면 상단의 상태 표시줄에 출력한다.  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onCreate</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">NotificationManager</span> <span class="hljs-variable">mNM</span> <span class="hljs-operator">=</span> (NotificationManager)getSystemService(NOTIFICATION_SERVICE);<br><br>    showNotification(); <span class="hljs-comment">// (3, 4)</span><br><br>    <span class="hljs-type">Thread</span> <span class="hljs-variable">thr</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<span class="hljs-literal">null</span>, mTask, <span class="hljs-string">&quot;AlarmService_Service&quot;</span>);<br>    thr.start();<br>&#125;<br></code></pre></td></tr></table></figure><p>(5) AlarmService_Service는 시작된 후 15초 후에 종료되며, 종료된 사실을 메인 액티비티에 알리기 위해 토스트(Toast) 메시지를 출력한다.  </p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">Runnable mTask = <span class="hljs-keyword">new</span> <span class="hljs-constructor">Runnable()</span> &#123; <span class="hljs-comment">// (5)</span><br>    public void run<span class="hljs-literal">()</span> &#123;<br>        long endTime = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>current<span class="hljs-constructor">TimeMillis()</span> + <span class="hljs-number">15</span>*<span class="hljs-number">1000</span>;<br>        <span class="hljs-keyword">while</span> (<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>current<span class="hljs-constructor">TimeMillis()</span> &lt; endTime) &#123;<br>            synchronized (mBinder) &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    mBinder.wait(endTime - <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>current<span class="hljs-constructor">TimeMillis()</span>);<br>                &#125; catch (Exception e) &#123;<br>                &#125;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">AlarmService_Service</span>.</span></span>this.stop<span class="hljs-constructor">Self()</span>;<br>    &#125;<br>&#125;;<br><br><br>public void on<span class="hljs-constructor">Destroy()</span> &#123;<br>    mNM.cancel(<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">R</span>.</span></span><span class="hljs-built_in">string</span>.alarm_service_started);<br><br>    <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Toast</span>.</span></span>make<span class="hljs-constructor">Text(<span class="hljs-params">this</span>, R.<span class="hljs-params">string</span>.<span class="hljs-params">alarm_service_finished</span>, Toast.LENGTH_SHORT)</span>.show<span class="hljs-literal">()</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="안드로이드-서비스-분류"><a href="#안드로이드-서비스-분류" class="headerlink" title="안드로이드 서비스 분류"></a>안드로이드 서비스 분류</h3><p>안드로이드 서비스는 다음과 같이 크게 프레임워크에서 기본적으로 제공하는 <strong>시스템 서비스</strong>와 애플리케이션 개발자가 Service 클래스를 상속해서 구현한 <strong>애플리케이션 서비스</strong>로 구분할 수 있다.  </p><p><img src="/images/post/service1.png" alt="service1" title="service1">  </p><h3 id="안드로이드-애플리케이션-서비스"><a href="#안드로이드-애플리케이션-서비스" class="headerlink" title="안드로이드 애플리케이션 서비스"></a>안드로이드 애플리케이션 서비스</h3><p>애플리케이션 서비스는 안드로이드 SDK의 Service 클래스를 확장한 클래스의 인스턴스로 UI 없이 주기적으로 특정한 일을 수행하는 백그라운드 프로세스를 가리킨다.</p><p>애플리케이션 개발자는 서비스를 두 가지 방법으로 이용할 수 있다.  </p><ul><li>서비스 시작, 종료  </li><li>바인딩을 통한 서비스 원격 제어(서비스를 원격 제어할 수 있게 서비스에 연결하는 것)</li></ul><p>애플리케이션이 서비스를 생성하려면 startService(), bindService()같은 API를 상황에 맞게 이용하면 된다. 백그라운드에서 특정 동작을 하는 서비스를 실행할 때는 <strong>startService()</strong>, 서비스에 바인딩해서 서비스가 제공하는 인터페이스를 통해 서비스를 제어하고 싶다면 **bindService()**를 통해 서비스를 생성한다. 두 서비스의 생명 주기는 약간 다른 것을 확인할 수 있다.  </p><p><img src="/images/post/service2.png" alt="service2" title="service2">  </p><p>startService()나 bindService()로 시작된 서비스 모두 onCreate()와 onDestroy() 콜백 메서드가 호출된다. onCreate() 메서드는 서비스가 처음 생성될 때 호출되며 일반적으로 서비스를 초기화하는 코드가 포함된다. onDestroy()는 서비스가 종료되기 직전에 호출되는데, 이때 서비스가 사용한 리소스를 모두 해제해야 한다.  </p><h5 id="startService"><a href="#startService" class="headerlink" title="startService()"></a>startService()</h5><p>onStartCommand()는 그림에서 볼 수 있듯이 오직 startService()에 의해 시작된 서비스에서 onCreate() 메서드 다음으로 호출된다. startService() 메서드의 첫 번째 인자로 넘어온 인텐트가 onStartCommand()의 첫 번째 인자로 그대로 전달되는데, 이때 인텐트에는 주로 실행할 서비스에 대한 정보가 포함된다. 이후 onStartCommand()에서는 일반적으로 인텐트에서 넘어온 인자가 있다면 이를 처리하거나 실질적인 백그라운드 작업을 처리하는 스레드를 실행한다.  </p><h5 id="bindService"><a href="#bindService" class="headerlink" title="bindService()"></a>bindService()</h5><p>bindService()에 의해 시작된 서비스에서 onBind()는 클라이언트가 서비스에 바인딩하려고 할 떄 호출된다.(아직 서비스가 생성되지 않았다면 그 전에 onCreate()를 먼저 호출한다) 서비스의 onBind() 콜백에서는 바인딩할 클라이언트를 위해 해당 서비스와 연결 가능한 객체를 제공한다. 따라서 바인딩이 끝나면 클라이언트는 이 객체를 통해 서비스를 원격 제어할 수 있다.  </p><h4 id="애플리케이션-서비스의-분류"><a href="#애플리케이션-서비스의-분류" class="headerlink" title="애플리케이션 서비스의 분류"></a>애플리케이션 서비스의 분류</h4><p>애플리케이션 서비스를 로컬 서비스와 리모트 서비스로 구분한다. 이를 구분하는 기준은 서비스와 이를 생선한 서비스 클라이언트(보통 액티비티)가 동일한 프로세스에서 동작하고 있는지 여부다.  </p><p><img src="/images/post/service3.png" alt="service3" title="service3">  </p><p>위의 그림과 같이 생성된 서비스가 자신과 동일한 프로세스에서 실행되는 경우 <strong>로컬 서비스</strong>라 부른다. 로컬 서비스는 자신을 생성한 애플리케이션 내에서만 사용될 수 있으며 애플리케이션이 종료하면 함께 종료한다.<br><strong>리모트 서비스</strong>는 자신을 생성한 액티비티와는 별개의 독립적인 프로세스 위에서 동작하기 때문에 메인 애플리케이션이 종료하더라도 계속 동작한다. **잘못 구현된 리모트 서비스는 프로그램이 종료하더라도 시스템 자원(배터리 등)을 비효율적으로 소모할 수 있기 때문에 설계에 신중을 기해야 한다.  </p><p>로컬 서비스와 리모트 서비스와의 가장 큰 차이는 서비스 제어를 위한 바인딩 방법이다.<br>로컬 서비스의 경우는 서비스와 서비스를 이용하는 클라이언트 프로그램이 동일 프로세스에서 동작하기 때문에 로컬 서비스 바인딩은 클라이언트 프로그램이 로컬 서비스의 레퍼런스만 얻으면 된다.<br>리모트 서비스의 경우는 액티비티와 자신이 모두 별개의 프로세스에서 동작하므로 (다음 장에서 배울)IPC 메커니즘을 이용해야 한다.  </p><p>로컬 서비스와 리모트 서비스의 바인딩 과정이 어떻게 다른지를 예제를 분석하며 알아보겠다.  </p><h5 id="로컬-서비스"><a href="#로컬-서비스" class="headerlink" title="로컬 서비스"></a>로컬 서비스</h5><p>Local Service Binding 예제는 크게 서비스를 나타내는 LocalService.java와 서비스를 이용하는 액티비티인 LocalServiceActivities.java로 구성돼 있다.<br>Bind Service 버튼을 누르면 doBindService()가 호출된다.  </p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-keyword">private</span> OnClickListener mBindListener = <span class="hljs-keyword">new</span> <span class="hljs-constructor">OnClickListener()</span> &#123;<br>    public void on<span class="hljs-constructor">Click(View <span class="hljs-params">v</span>)</span> &#123;<br>        <span class="hljs-keyword">do</span><span class="hljs-constructor">BindService()</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>이 메서드에서 내부적으로 bindService() API를 사용해서 LocalService 바인딩을 시도한다.<br><em>bindService(LocalService 실행하기 위한 인텐트, 서비스와의 바인딩 연결을 처리할 객체, 바인딩할 서비스가 없는 경우 자동 서비스 생성 플래그)</em>  </p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">void <span class="hljs-keyword">do</span><span class="hljs-constructor">BindService()</span> &#123;<br>    <span class="hljs-keyword">if</span> (bind<span class="hljs-constructor">Service(<span class="hljs-params">new</span> Intent(Binding.<span class="hljs-params">this</span>, LocalService.<span class="hljs-params">class</span>)</span>,<br>        mConnection, Context.BIND_AUTO_CREATE)) &#123;<br>        mShouldUnbind = <span class="hljs-literal">true</span>;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Log</span>.</span></span>e(<span class="hljs-string">&quot;MY_APP_TAG&quot;</span>, <span class="hljs-string">&quot;Error: The requested service doesn&#x27;t &quot;</span> +<br>                <span class="hljs-string">&quot;exist, or this client isn&#x27;t allowed access to it.&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>바인딩할 서비스가 생성됐으므로 안드로이드는 바인딩 처리를 위해 서비스의 onBind() 콜백 메서드를 호출한다.<br>onBind 메서드는 액티비티가 LocalService 자신과 연결할 수 있게 LocalBinder 객체를 반환한다.  </p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs scala">public <span class="hljs-type">IBinder</span> onBind(<span class="hljs-type">Intent</span> intent) &#123;<br>    <span class="hljs-keyword">return</span> mBinder;<br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">IBinder</span> mBinder = <span class="hljs-keyword">new</span> <span class="hljs-type">LocalBinder</span>();<br><br>public <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LocalBinder</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Binder</span> </span>&#123;<br>    <span class="hljs-type">LocalService</span> getService() &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-type">LocalService</span>.<span class="hljs-keyword">this</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>바인딩을 처리할 객체를 제대로 생성했다면(LocalBinder), 안드로이드 프레임워크는 서비스 클라이언트 측 메서드를 호출한다.<br>이 때 LocalBinder 객체의 getService() 메서드를 호출해서 바인딩하려고 했던 LocalService 객체의 레퍼런스 값을 구한다.<br>이렇게 구한 LocalBinder 객체의 레퍼런스 값을 mBoundService 멤버 필드에 저장하면 서비스 바인딩이 마무리된다.  </p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">private</span> ServiceConnection mConnection = <span class="hljs-keyword">new</span> ServiceConnection() &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onServiceConnected</span>(<span class="hljs-params">ComponentName className, IBinder service</span>)</span> &#123;<br>        mBoundService = ((LocalService.LocalBinder)service).getService();<br>        Toast.makeText(Binding.<span class="hljs-keyword">this</span>, R.<span class="hljs-built_in">string</span>.local_service_connected,<br>            Toast.LENGTH_SHORT).show();<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onServiceDisconnected</span>(<span class="hljs-params">ComponentName className</span>)</span> &#123;<br>        mBoundService = <span class="hljs-literal">null</span>;<br>        Toast.makeText(Binding.<span class="hljs-keyword">this</span>, R.<span class="hljs-built_in">string</span>.local_service_disconnected,<br>            Toast.LENGTH_SHORT).show();<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>서비스가 바인딩 되고 나면 액티비티는 해당 서비스가 가진 모든 메서드와 멤버 필드 값을 mBoundService 멤버 필드를 통해 접근할 수 있게 된다.  </p><h5 id="리모트-서비스"><a href="#리모트-서비스" class="headerlink" title="리모트 서비스"></a>리모트 서비스</h5><p>Remote Service Binding 예제는 Local Service Binding 과는 다르게 액티비티나 서비스 파일 이외에 ISecondary.aidl이라는 AIDL 파일과 이 파일에 의해 자동 생성된 ISecondary.java 파일이 추가된 것을 알 수 있다.  </p><p><em>ISecondary.aidl은 액티비티와 서비스의 통신을 위한 인터페이스 정의</em><br><em>ISecondary.java는 안드로이드가 자동 생성하며 인터페이스를 기반으로 액티비티와 서비스가 서로 통신할 수 있게 마샬링&#x2F;언마샬링을 수행</em><br><em>마샬링 - 객체의 메모리 구조를 저장이나 전송을 위해서 적당한 자료형태로 변형</em>  </p><p>ISecondary.aidl을 통해 자동으로 생성된 ISecondary.java는 서비스 클라이언트와 리모트 서비스 간의 ISecondary 인터페이스에 기반한 바인더 IPC 연결을 설정한다. 즉, 이 코드를 통해서 RemoteServiceBinding 액티비티는 RemoteService 서비스가 제공하는 ISecondary 인터페이스에 포함된 getPid() 메서드를 마치 해당 클래스에 포함된 매서드를 호출하듯 호출할 수 있다.  </p><p>Bind Service 버튼을 눌렀을 때 로컬 서비스와 비슷하게 bindService()에서 첫 번째 인자에 리모트 서비스를 실행하기 위한 인텐트가 전달된다.  </p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-keyword">private</span> OnClickListener mBindListener = <span class="hljs-keyword">new</span> <span class="hljs-constructor">OnClickListener()</span> &#123;<br>    public void on<span class="hljs-constructor">Click(View <span class="hljs-params">v</span>)</span> &#123;<br>        Intent intent = <span class="hljs-keyword">new</span> <span class="hljs-constructor">Intent(Binding.<span class="hljs-params">this</span>, RemoteService.<span class="hljs-params">class</span>)</span>;<br>        intent.set<span class="hljs-constructor">Action(ISecondary.<span class="hljs-params">class</span>.<span class="hljs-params">getName</span>()</span>);<br>        bind<span class="hljs-constructor">Service(<span class="hljs-params">intent</span>, <span class="hljs-params">mSecondaryConnection</span>, Context.BIND_AUTO_CREATE)</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>서비스가 생성되고 나면 서비스 생명주기에 따라 onCreate() 메서드와 onBind() 메서드가 차례대로 호출된다. onCreate() 메서드는 앞의 LocalService와 같이 서비스의 생성을 알림 메시지를 통해 알린다. onBind() 메서드의 주된 역할은 바인더 IPC를 처리할 서비스 바인더 객체(여기서는 mSecondaryBinder)를 생성한 후 이를 시스템에 반환하는 것이다.  </p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">private</span> final ISecondary.Stub mSecondaryBinder = <span class="hljs-keyword">new</span> ISecondary.Stub() &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> <span class="hljs-title">getPid</span>()</span> &#123;<br>        <span class="hljs-keyword">return</span> Process.myPid();<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">basicTypes</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> anInt, <span class="hljs-built_in">long</span> aLong, boolean aBoolean,</span></span><br><span class="hljs-params"><span class="hljs-function">        <span class="hljs-built_in">float</span> aFloat, <span class="hljs-built_in">double</span> aDouble, String aString</span>)</span> &#123;<br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> IBinder <span class="hljs-title">onBind</span>(<span class="hljs-params">Intent intent</span>)</span> &#123;<br>    <span class="hljs-keyword">if</span> (IRemoteService.<span class="hljs-keyword">class</span>.getName().<span class="hljs-keyword">equals</span>(intent.getAction())) &#123;<br>        <span class="hljs-keyword">return</span> mBinder;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (ISecondary.<span class="hljs-keyword">class</span>.getName().<span class="hljs-keyword">equals</span>(intent.getAction())) &#123;<br>        <span class="hljs-keyword">return</span> mSecondaryBinder;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>바인딩 준비가 끝나면 안드로이드 프레임워크는 bindService()의 두 번째 인자로 넘긴 연결 객체의 onServiceConnected()콜백 메서드를 호출한다.<br>바인딩이 끝나면 mSecondaryService 멤버 변수에 저장된 서비스 프록시 객체를 통해 RemoteService 서비스의 getPid() 메서드를 마치 자신의 메서드인 것처럼 호출할 수 있게 된다.  </p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-keyword">private</span> ServiceConnection mSecondaryConnection = <span class="hljs-keyword">new</span> <span class="hljs-constructor">ServiceConnection()</span> &#123;<br>    public void on<span class="hljs-constructor">ServiceConnected(ComponentName <span class="hljs-params">className</span>, IBinder <span class="hljs-params">service</span>)</span> &#123;<br>        mSecondaryService = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">ISecondary</span>.</span><span class="hljs-module"><span class="hljs-identifier">Stub</span>.</span></span><span class="hljs-keyword">as</span><span class="hljs-constructor">Interface(<span class="hljs-params">service</span>)</span>; <span class="hljs-comment">// 서비스 프록시 객체가 생성되어 저장</span><br>        mKillButton.set<span class="hljs-constructor">Enabled(<span class="hljs-params">true</span>)</span>;<br>    &#125;<br>    public void on<span class="hljs-constructor">ServiceDisconnected(ComponentName <span class="hljs-params">className</span>)</span> &#123;<br>        mSecondaryService = null;<br>        mKillButton.set<span class="hljs-constructor">Enabled(<span class="hljs-params">false</span>)</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>바인딩한 서비스를 이용하기 위해서 ‘Kill Process’버튼을 누르면 서비스 프록시 객체의 getPid() 서비스 프록시 메서드가 호출된다. 액티비티는 이렇게 구한 서비스 프로세스를 Process.killProcess() 메서드를 통해 강제 종료한다.  </p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">private</span> OnClickListener mKillListener = <span class="hljs-keyword">new</span> OnClickListener() &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onClick</span>(<span class="hljs-params">View v</span>)</span> &#123;<br>        <span class="hljs-keyword">if</span> (mSecondaryService != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-built_in">int</span> pid = mSecondaryService.getPid();<br>                Process.killProcess(pid);<br>                mCallbackText.setText(<span class="hljs-string">&quot;Killed service process.&quot;</span>);<br>            &#125; <span class="hljs-keyword">catch</span> (RemoteException ex) &#123;<br>                Toast.makeText(Binding.<span class="hljs-keyword">this</span>,<br>                        R.<span class="hljs-built_in">string</span>.remote_call_failed,<br>                        Toast.LENGTH_SHORT).show();<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Android</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Android</tag>
      
      <tag>인사이드 안드로이드</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[인사이드 안드로이드] 챕터 5 - Zygote</title>
    <link href="/chapter5/"/>
    <url>/chapter5/</url>
    
    <content type="html"><![CDATA[<h1 id="인사이드-안드로이드"><a href="#인사이드-안드로이드" class="headerlink" title="[인사이드 안드로이드]"></a>[인사이드 안드로이드]</h1><h2 id="Chapter5-Zygote"><a href="#Chapter5-Zygote" class="headerlink" title="Chapter5 - Zygote"></a>Chapter5 - Zygote</h2><h3 id="Zygote란-무엇인가"><a href="#Zygote란-무엇인가" class="headerlink" title="Zygote란 무엇인가?"></a>Zygote란 무엇인가?</h3><p>Zygote의 사전적 의미는 ‘분할 전의 세포나 수정란’이다. 쉽게 말하면 개체가 생성되기 이전의 불완전한 상태.<br><strong>안드로이드 시스템에서 새로운 애플리케이션을 실행하면 실행에 필요한 요소들을 미리 준비해 둔 Zygote 프로세스와 새로운 애플리케이션이 결합되서 실행된다.</strong>  </p><p>Zygote 프로세스는 실행되면서 달빅(Dalvik) 가상 머신을 초기화하고 구동시킨다. 안드로이드 애플리케이션은 자바로 작성돼 있어 리눅스 상에서 네이티브 프로세스로 실행될 수 없으며 달빅 가상 머신에서 동작한다. 각 안드로이드 애플리케이션은 독립적인 가상 머신 위에서 동작하는데, 실행될 때 마다 자신이 동작할 가상 머신을 초기화하고 실행하는 과정에는 많은 시간이 소요되며 애플리케이션의 실행을 느리게 하는 요인이 된다. 때문에 안드로이드에서 Zygote 프로세스는 애플리케이션이 실행되기 전에 실행된 가상 머신의 코드 및 메모리 정보를 공유함으로써 <strong>애플리케이션이 실행되는 시간을 단축시킬 수 있다.</strong> 여기에 더해 안드로이드 프레임워크에서 동작하는 <strong>애플리케이션이 사용할 클래스와 자원을 미리 메모리에 로딩해 두고 이러한 자원에 대한 연결 정보를 구성한다.</strong><br>Zygote 프로세스를 사용하는 목적으로는 애플리케이션의 생성 속도를 빠르게 해서 한정된 자원을 효율적으로 사용해 사용 시간을 늘리기 위함이다.  </p><h4 id="Zygote를-통한-프로세스의-생성"><a href="#Zygote를-통한-프로세스의-생성" class="headerlink" title="Zygote를 통한 프로세스의 생성"></a>Zygote를 통한 프로세스의 생성</h4><p><img src="/images/post/zygote1.png" alt="zygote1" title="zygote1">  </p><p>Zygote 프로세스는 init 프로세스가 시스템 구동에 필요한 각종 데몬을 실행하고 난 뒤 실행된다. Zygote 프로세스가 실행된 이후에는 안드로이드 서비스 및 애플리케이션은 Zygote 프로세스를 통해 실행된다.  </p><p><img src="/images/post/zygote2.png" alt="zygote2" title="zygote2">  </p><p>일반적인 리눅스 시스템에서 새로운 애플리케이션을 실행하는 과정은 위와 같다.<br>부모 프로세스 A는 fork() 시스템 콜을 호출하여 새로운 자식 프로세스 A’를 생성한다. 새로 생성된 프로세스 A’는 부모 프로세스인 프로세스 A의 메모리 구성 정보 및 공유 라이브러리에 대한 링크 정보를 공유한 상태이다. 다음으로 자식 프로세스 A’는 exec(‘B’) 시스템 콜을 호출해 새로운 프로세스 B의 코드를 메모리로 로딩한다. 이때 부모 프로세스 A의 메모리 정보는 지워지고 로딩된 B를 실행하는 데 필요한 메모리를 새롭게 구성한 후 프로세스 B가 사용한 공유 라이브러리에 대한 링크 정보를 새로 구성한다.  </p><p><strong>안드로이드에서</strong>는 COW(Copy On Write)를 통해 기존에 이미 메모리 상에서 동작중인 프로세스의 재사용성을 극대화하고 공유 라이브러리를 통해 메모리 사용량(foot print)을 최소화한다.  </p><blockquote><p>COW(Copy On Write)란 프로세스를 생성할 때 새로 생성된 자식 프로세스는 부모 프로세스와 메모리 공간을 공유하는데, 메모리 복사를 하는 것은 오버헤드가 매우 크기 때문에 생성된 자식 프로세스가 부모의 메모리 공간을 참조만 할 경우에는 이를 복사하지 않고 부모의 메모리 공간을 공유하게 된다. 공유하는 메모리 정보를 자식 프로세스가 수정하는 시점에서 부모 프로세스의 메모리 정보를 자신의 메모리 공간으로 복사하는 것이 바로 COW 기법이다.   </p></blockquote><p><img src="/images/post/zygote3.png" alt="zygote3" title="zygote3">  </p><p>Zygote 프로세스는 fork() 시스템 콜을 호출해 자식 프로세스인 Zygote’ 프로세스를 생성한다. 생성된 Zygote’ 프로세스는 부모인 Zygote 프로세스의 코드 영역과 링크 정보를 공유한다. 새로운 안드로이드 애플리케이션 A는 fork()를 통해 생성도니 프로세스의 코드 영역을 새롭게 로딩하는 것이 아니라, 복제된 달빅 가상 머신 위에 동적으로 로딩된다. 이후에 zygote’ 프로세스는 애플리케이션 A 클래스의 메서드로 실행 흐름을 넘겨 안드로이드 애플리케이션이 동작하게 된다. <strong>새로 생성된 애플리케이션 A는 기존의 Zygote 프로세스가 구성해 놓은 라이브러리 및 리소스에 대한 링크정보를 그대로 사용하기에 빠르게 실행된다.</strong><br>다음은 Zygote가 실행되고 나서 새로운 안드로이드 애플리케이션 A가 실행되기까지의 과정을 나타낸다.  </p><p><img src="/images/post/zygote4.png" alt="zygote4" title="zygote4">  </p><p>Zygote는 달빅 가상 머신을 초기화하고, 필요한 클래스와 자원을 메모리에 로딩한다. fork()를 통해 새로 생성된 Zygote’ 프로세스는 마지막 단계에서 새로 실행되는 안드로이드 애플리케이션 A를 동적으로 로딩하고 실행한다. 실행되는 애플리케이션 A는 Zygote가 미리 초기화하고 실행한 달빅 가상 머신의 코드를 그대로 사용하며, 미리 메모리에 로딩해둔 클래스와 자원을 사용함으로써 빠르게 실행된다.  </p><h4 id="app-process로부터-ZygoteInit-class-실행"><a href="#app-process로부터-ZygoteInit-class-실행" class="headerlink" title="app_process로부터 ZygoteInit class 실행"></a>app_process로부터 ZygoteInit class 실행</h4><p>Zygote는 자바로 작성돼 있으므로 다른 네이티브 서비스나 데몬과 같이 init 프로세스에서 바로 실행할 수 없다. 자바로 작성돼 있는 Zygote 클래스가 동작하려면 달빅 가상 머신이 생성돼야 하고, 생성된 가상 머신 위에서 Zygoteinit 클래스를 로딩하고 실행해야 한다. 이러한 작업을 수행하는 프로세스가 바로 <strong>app_process</strong>다.  </p><p><img src="/images/post/zygote5.png" alt="zygote5" title="zygote5">  </p><p>&#x2F;System&#x2F;bin&#x2F;app_process의 소스 코드에 있는 main() 함수에서 AppRuntime 객체를 생성한 후 main() 함수에 전달된 인자 값을 분석해서 AppRuntime 객체에 전달한다. 그러고 나서 달빅 가상 머신을 초기화하고 생성한 다음 마지막으로 ZygoteInit 클래스의 main() 메서드를 호출한다.  </p><h4 id="ZygoteInit-클래스의-기능"><a href="#ZygoteInit-클래스의-기능" class="headerlink" title="ZygoteInit 클래스의 기능"></a>ZygoteInit 클래스의 기능</h4><p><img src="/images/post/zygote6.png" alt="zygote6" title="zygote6">  </p><p>그림은 ZygoteInit::main() 메서드의 기능을 요약했다.<br>main() 메서드에서는 새로운 안드로이드 애플리케이션을 실행하기 위한 요청을 수신하는 데 쓸 소켓을 바인딩한다. 안드로이드 애플리케이션 프레임워크에서 사용할 클래스와 리소스를 로딩하고 <strong>SystemServer</strong>를 실행한다. 시스템 서버는 안드로이드 플랫폼에 필요한 주요 네이티브 서비스들을 실행하게 된다. 이후에 등록된 UDS를 모니터링하고 있다가 새로운 안드로이드 애플리케이션의 생성 요청을 받으면 이를 처리하는 루프로 진입한다.  </p><p>ZygoteInit 클래스는 &#x2F;dev&#x2F;socket&#x2F;zygote에 생성된 유닉스 도메인 소켓을 사용해서 ActivityManager로부터 전달되는 새 안드로이드 애플리케이션의 생성 요청 메시지를 수신한다. 이 소켓은 init 부팅 과정에서 프로세스에 의해 생성되며, init.rc에 기술돼 있다.<br>또한 ZygoteInit 클래스는 preloadClasses()와 preloadResources() 메서드를 호출한다. 각 메서드는 안드로이드 애플리케이션 프레임워크에 포함되는 클래스와 아이콘, 이미지, 문자열 등의 자원을 미리 메모리에 로딩하고 로딩한 클래스와 자원에 대한 연결 정보를 생성한다. 이후 새로 생성되는 안드로이드 애플리케이션에서는 미리 로딩한 클래스나 자원을 이용할 때 새로 연결정보를 생성하지 않고 그대로 이용한다.  </p><p>그렇다면 사용할 클래스를 메모리에 미리 로딩하는 것이 얼마만큼의 효과가 있을까? logcat 명령어를 통해 확인하면 1942개의 클래스를 로딩하는 데 18202ms가 걸렸다. 만약 미리 로딩하는 과정이 없을 경우, 18202ms의 추가시간이 걸리게 된다.  </p><p>Zygote에서 달빅 가상 머신을 구동한 이후, 시스템 서버(SystemServer)라는 자바 서비스를 실행하기 위해 새로운 달빅 가상 머신 인스턴스를 생성한다. 시스템 서버는 필요한 네이티브 서비스를 실행하고, 안드로이드 프레임워크의 서비스들을 시작한다. 이때 시작되는 서비스로는 안드로이드 애플리케이션의 액티비티를 관리하는 액티비티 매니저(ActivityManager), 애플리케이션을 설치, 관리하는 패키지 매니저(PackageManager)등이 있다.  </p><p>다음 그림은 ZygoteInit 클래스가 새로운 프로세스를 생성하는 과정을 나타낸다.  </p><p><img src="/images/post/zygote7.png" alt="zygote7" title="zygote7">  </p>]]></content>
    
    
    <categories>
      
      <category>Android</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Android</tag>
      
      <tag>인사이드 안드로이드</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[인사이드 안드로이드] 챕터 4 - JNI와 NDK(3)</title>
    <link href="/chapter4_3/"/>
    <url>/chapter4_3/</url>
    
    <content type="html"><![CDATA[<h1 id="인사이드-안드로이드"><a href="#인사이드-안드로이드" class="headerlink" title="[인사이드 안드로이드]"></a>[인사이드 안드로이드]</h1><h2 id="Chapter4-JNI와-NDK-3"><a href="#Chapter4-JNI와-NDK-3" class="headerlink" title="Chapter4 - JNI와 NDK(3)"></a>Chapter4 - JNI와 NDK(3)</h2><h3 id="안드로이드-NDK로-개발하기"><a href="#안드로이드-NDK로-개발하기" class="headerlink" title="안드로이드 NDK로 개발하기"></a>안드로이드 NDK로 개발하기</h3><p>안드로이드 NDK(Native Development Kit)는 애플리케이션 개발자가 JNI를 활용한 작업을 쉽게 할 수 있도록 구글에서 제공하는 개발 도구다.  </p><h4 id="안드로이드-NDK환경-설정"><a href="#안드로이드-NDK환경-설정" class="headerlink" title="안드로이드 NDK환경 설정"></a>안드로이드 NDK환경 설정</h4><p>1.NDK 다운로드  </p><p><a href="http://developer.android.com/intl/ko/ndk/downloads/index.html">http://developer.android.com/intl/ko/ndk/downloads/index.html</a>  </p><p>2.압축 해제  </p><p>적절한 경로에 압축을 해제한다.  </p><figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs llvm">unzip android-ndk-r<span class="hljs-number">19</span><span class="hljs-keyword">c</span>-linux-<span class="hljs-keyword">x</span><span class="hljs-number">86</span>_<span class="hljs-number">64</span>.zip<br></code></pre></td></tr></table></figure><p>3.NDK 경로설정  </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo nano ~/.bashrc<br></code></pre></td></tr></table></figure><p>맨 아래부분에 다음을 추가합니다.  </p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-built_in">export</span> <span class="hljs-attribute">PATH</span>=<span class="hljs-variable">$&#123;PATH&#125;</span>:(압축푼 경로)/android-ndk-r19c<br></code></pre></td></tr></table></figure><p>저와같은 경우에는 다음과 같이 입력했습니다.  </p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs elixir">export <span class="hljs-title class_">PATH</span>=<span class="hljs-variable">$&#123;</span><span class="hljs-title class_">PATH</span>&#125;<span class="hljs-symbol">:/home/kyungsoo/android-ndk-r19c</span><br></code></pre></td></tr></table></figure><p>다음과 같이 입력해 적용완료.  </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">source</span> /.bashrc<br></code></pre></td></tr></table></figure><p>ndk-build 명령을 실행했을 때 아래와 같이 실행되면 NDK 설정이 제대로 된 것이다.  </p><p><img src="/images/post/ndk1.png" alt="ndk1" title="ndk1">  </p><h4 id="안드로이드-NDK개발-따라하기"><a href="#안드로이드-NDK개발-따라하기" class="headerlink" title="안드로이드 NDK개발 따라하기"></a>안드로이드 NDK개발 따라하기</h4><p>프로젝트를 먼저 생성하고 Activity의 내용을 다음과 같이 수정한다.  </p><p><img src="/images/post/ndk2.png" alt="ndk2" title="ndk2">  </p><p>javah 유틸을 실행하여 헤더 파일을 생성한다.  </p><p><img src="/images/post/ndk3.png" alt="ndk3" title="ndk3">  </p><p>프로젝트 밑에 jni폴더를 생성하고 JNI 네이티브 함수를 구현한다.    </p><p><img src="/images/post/ndk4.png" alt="ndk4" title="ndk4"><br><img src="/images/post/ndk5.png" alt="ndk5" title="ndk5"><br><img src="/images/post/ndk6.png" alt="ndk6" title="ndk6">  </p><p>동일하게 jni폴더에 Android.mk 파일을 작성한다.  </p><p><img src="/images/post/ndk7.png" alt="ndk7" title="ndk7">  </p><p>프로젝트 홈 디렉터리에서 ndk-build를 실행한다.  </p><p><img src="/images/post/ndk8.png" alt="ndk8" title="ndk8">  </p><p>이제 프로젝트를 빌드해서 실행하면 다음과 같이 1000과 42의 합인 1042가 출력된다.  </p><p><img src="/images/post/ndk9.png" alt="ndk9" title="ndk9">  </p>]]></content>
    
    
    <categories>
      
      <category>Android</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Android</tag>
      
      <tag>인사이드 안드로이드</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[인사이드 안드로이드] 챕터 4 - JNI와 NDK(2)</title>
    <link href="/chapter4_2/"/>
    <url>/chapter4_2/</url>
    
    <content type="html"><![CDATA[<h1 id="인사이드-안드로이드"><a href="#인사이드-안드로이드" class="headerlink" title="[인사이드 안드로이드]"></a>[인사이드 안드로이드]</h1><h2 id="Chapter4-JNI와-NDK-2"><a href="#Chapter4-JNI와-NDK-2" class="headerlink" title="Chapter4 - JNI와 NDK(2)"></a>Chapter4 - JNI와 NDK(2)</h2><h3 id="JNI-함수-이용하기"><a href="#JNI-함수-이용하기" class="headerlink" title="JNI 함수 이용하기"></a>JNI 함수 이용하기</h3><h4 id="JNI-함수를-활용하는-예제-프로그램의-구조"><a href="#JNI-함수를-활용하는-예제-프로그램의-구조" class="headerlink" title="JNI 함수를 활용하는 예제 프로그램의 구조"></a>JNI 함수를 활용하는 예제 프로그램의 구조</h4><p>예제 프로그램의 전체적인 구조는 다음과 같다.<br>① 네이티브 메서드가 선언된 JniFuncMain 클래스<br>② JniTest 객체<br>③ 네이티브 메서드가 실제 구현이 포함된 jnitest.so  </p><h4 id="자바측-코드-살펴보기-JniFuncMain-java"><a href="#자바측-코드-살펴보기-JniFuncMain-java" class="headerlink" title="자바측 코드 살펴보기(JniFuncMain.java)"></a>자바측 코드 살펴보기(JniFuncMain.java)</h4><p>JniFuncMain 클래스는 다음과 같다.  </p><p><img src="/images/post/jni5.png" alt="jni5" title="jni5">  </p><p>JniTest 클래스는 다음과 같다.</p><p><img src="/images/post/jni6.png" alt="jni6" title="jni6">  </p><h4 id="JNI-네이티브-함수의-코드-살펴보기"><a href="#JNI-네이티브-함수의-코드-살펴보기" class="headerlink" title="JNI 네이티브 함수의 코드 살펴보기"></a>JNI 네이티브 함수의 코드 살펴보기</h4><p>JniFuncMain.h 헤더 파일은 javah명령어를 통해 생성한다.</p><p><img src="/images/post/jni7.png" alt="jni7" title="jni7">  </p><p>실제 함수 코드인 jnifunc.cpp는 다음과 같다.  </p><p><img src="/images/post/jni8.png" alt="jni8" title="jni8">  </p><p>cpp파일 까지 작성을 완료한 후 이전 포스트 처럼 .so파일을 생성한다.<br>여기서는 c가 아닌 cpp이기때문에 gcc가 아닌 g++로 컴파일을 한다.  </p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs awk">g++ -I<span class="hljs-regexp">/(jdk경로)/i</span>nclude<span class="hljs-regexp">/ -I/</span>(jdk경로)<span class="hljs-regexp">/include/</span>linux -shared -fPIC jnifunc.cpp -o libjnifunc.so<br><br>sudo mv libjnifunc.so <span class="hljs-regexp">/usr/</span>lib/<br><br>java JniFuncMain<br></code></pre></td></tr></table></figure><p>JniFuncMain의 결과는 다음과 같다.  </p><p><img src="/images/post/jni9.png" alt="jni9" title="jni9">  </p><h4 id="안드로이드에서의-활용-예"><a href="#안드로이드에서의-활용-예" class="headerlink" title="안드로이드에서의 활용 예"></a>안드로이드에서의 활용 예</h4><ul><li>frameworks&#x2F;base&#x2F;core&#x2F;jni</li><li>frameworks&#x2F;base&#x2F;services&#x2F;jni</li><li>frameworks&#x2F;base&#x2F;media&#x2F;jni</li></ul><h3 id="C프로그램에서-자바-클래스-실행하기"><a href="#C프로그램에서-자바-클래스-실행하기" class="headerlink" title="C프로그램에서 자바 클래스 실행하기"></a>C프로그램에서 자바 클래스 실행하기</h3><p>지금까지는 자바 코드가 메인 프로그램이고 자바 쪽 코드에서 네이티브 메서드를 통해 C 함수를 호출해서 JNI를 이용하는 방식이었다.<br>지금부터는 C&#x2F;C++로 구현된 메인 애플리케이션에서 자바 클래스를 실행하는 JNI이용 방식이다.  </p><h4 id="C-코드-invocationApi-c-살펴보기"><a href="#C-코드-invocationApi-c-살펴보기" class="headerlink" title="C 코드(invocationApi.c) 살펴보기"></a>C 코드(invocationApi.c) 살펴보기</h4><p>자바 가상 머신을 생성하고 실행할 클래스 및 메서드를 받아와 호출하는 코드이다.  </p><p><img src="/images/post/jni10.png" alt="jni10" title="jni10">  </p><h4 id="자바-코드-InvocationApiTest-java-살펴보기"><a href="#자바-코드-InvocationApiTest-java-살펴보기" class="headerlink" title="자바 코드(InvocationApiTest.java) 살펴보기"></a>자바 코드(InvocationApiTest.java) 살펴보기</h4><p>main() 메서드 하나만 포함한 간단한 클래스이다.  </p><p><img src="/images/post/jni11.png" alt="jni11" title="jni11">  </p><h4 id="컴파일-및-실행"><a href="#컴파일-및-실행" class="headerlink" title="컴파일 및 실행"></a>컴파일 및 실행</h4><p>자바 코드 컴파일은 다음과같이 javac를 이용하여 진행한다.  </p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm"><span class="hljs-keyword">javac </span>InvocationApiTest.<span class="hljs-keyword">java</span><br></code></pre></td></tr></table></figure><p>책에서와 달리 우분투에서 진행했기 때문에 C 코드는 .exe 파일이 아닌 .out 파일을 생성한다.<br>컴파일시 libjvm.so를 포함해야 하므로 &#x2F;etc&#x2F;profile의 LD_LIBRARY_PATH를 수정해준다.  </p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">sudo nano <span class="hljs-regexp">/etc/</span>profile<br></code></pre></td></tr></table></figure><p>export LD_LIBRARY_PATH 부분이 존재한다면 libjvm.so 파일이 존재하는 위치를 추가해준다.<br>나는 &#x2F;usr&#x2F;lib&#x2F;jvm&#x2F;java5&#x2F;jdk1.5.0_22&#x2F;jre&#x2F;lib&#x2F;amd64&#x2F;server 위치에 있었기 때문에 다음과 같이 입력했다.  </p><p>export LD_LIBRARY_PATH&#x3D;&#x2F;usr&#x2F;lib:&#x2F;usr&#x2F;local&#x2F;lib:&#x2F;usr&#x2F;lib&#x2F;jvm&#x2F;java5&#x2F;jdk1.5.0_22&#x2F;jre&#x2F;lib&#x2F;amd64&#x2F;server  </p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gradle"><span class="hljs-keyword">source</span> <span class="hljs-regexp">/etc/</span>profile<br></code></pre></td></tr></table></figure><p>이제 C파일을 다음과 같은 명령어를 통해 컴파일한다.  </p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">gcc -I<span class="hljs-regexp">/(JAVA_HOME)/i</span>nclude<span class="hljs-regexp">/ -I/</span>(JAVA_HOME)<span class="hljs-regexp">/include/</span>linux -L/(libjvm.so 위치) -fPIC invocationApi.c -o invocationApi.out -ljvm<br></code></pre></td></tr></table></figure><p>나와 같은 경우에는 다음과 같이 입력했다.</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">gcc -I<span class="hljs-regexp">/usr/</span>lib<span class="hljs-regexp">/jvm/</span>java5<span class="hljs-regexp">/jdk1.5.0_22/i</span>nclude<span class="hljs-regexp">/ -I/u</span>sr<span class="hljs-regexp">/lib/</span>jvm<span class="hljs-regexp">/java5/</span>jdk1.<span class="hljs-number">5.0</span>_22<span class="hljs-regexp">/include/</span>linux -L<span class="hljs-regexp">/usr/</span>lib<span class="hljs-regexp">/jvm/</span>java5<span class="hljs-regexp">/jdk1.5.0_22/</span>jre<span class="hljs-regexp">/lib/</span>amd64/server -fPIC invocationApi.c -o invocationApi.out -ljvm<br></code></pre></td></tr></table></figure><p>이제 실행 파일인 invocationApit.out을 실행한다.  </p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ada">./invocationApi.<span class="hljs-keyword">out</span><br></code></pre></td></tr></table></figure><p><img src="/images/post/jni12.png" alt="jni12" title="jni12">  </p><h4 id="안드로이드에서-활용-예-Zygote-프로세스"><a href="#안드로이드에서-활용-예-Zygote-프로세스" class="headerlink" title="안드로이드에서 활용 예: Zygote 프로세스"></a>안드로이드에서 활용 예: Zygote 프로세스</h4><p>5장에서 알아볼 자바 기반의 <strong>Zygote 프로세스</strong>도 <strong>app_process</strong>라는 C++ 기반의 네이티브 애플리케이션에서 JNI 호출 API를 통해 실행된다.  </p><p>app_process는 안드로이드 프레임워크가 부팅될 때 안드로이드 런타임을 초기화하고 Zygote 프로세스를 실행하는 역할을 하는 프로세스다. 또한 Zygote는 안드로이드 프레임워크의 성능을 향상 시키기 위한 특별한 프로세스로서 모든 안드로이드 애플리케이션의 프로세스는 Zygote에서 fork된다. 이러한 <strong>Zygote 프로세스는 안드로이드 zygoteInit 클래스라는 자바 프로그램으로 구성돼있다.</strong> 따라서 app_process는 안드로이드가 부팅할 때 JNI 호출 API를 이용해서 자신의 프로그램 영역에 달빅 가상 머신을 로드하고, ZygoteInit 클래스의 main() 메서드를 호출해서 Zygote를 실행한다.  </p><h3 id="JNI-네이티브-함수-직접-등록하기"><a href="#JNI-네이티브-함수-직접-등록하기" class="headerlink" title="JNI 네이티브 함수 직접 등록하기"></a>JNI 네이티브 함수 직접 등록하기</h3><p>이전 포스트의 ‘JNI 기본 원리 이해하기’에서 설명했듯이 자바 가상 머신은 네이티브 메서드를 포함하는 자바 애플리케이션을 실행할 때 아래의 두 단계를 거친다.  </p><ol><li>System.loadLibrary() 메서드를 이용해서 네이티브 메서드의 실제 구현이 포함된 C&#x2F;C++ 라이브러리를 메모리 상에 로드한다.  </li><li>자바 가상 머신은 위에서 로드된 라이브러리의 함수 심볼을 검색해서 자바에서 선언된 네이티브 메서드의 시그너처와 일치하는 JNI 네이티브 함수 심볼을 찾은 다음 네이티브 메서드와 실제 구현인 JNI 네이티브 함수를 매핑한다.</li></ol><p>JNI는 C&#x2F;C++ 개발자가 JNI 네이티브 함수를 직접 자바 클래스의 네이티브 메서드에 매핑할 수 있게 해주는 RegisterNatives()라는 JNI 함수를 제공한다. RegisterNatives() 함수를 이용하면 자바 가상 머신이 자동으로 심볼을 검색해서 적장할 JNI 네이티브 함수를 연결하는 작업을 대신해 별도의 매핑 과정을 생략할 수 있어 로딩 속도를 향상시킬 수 있다.  </p><h4 id="네이티브-라이브러리-로드-시에-JNI네이티브-함수-등록하기"><a href="#네이티브-라이브러리-로드-시에-JNI네이티브-함수-등록하기" class="headerlink" title="네이티브 라이브러리 로드 시에 JNI네이티브 함수 등록하기"></a>네이티브 라이브러리 로드 시에 JNI네이티브 함수 등록하기</h4><p>이전 포스트에서의 hellojni.c 코드를 자바 가상 머신 대신에 직접 네이티브 메서드와 C 함수를 매핑한 hellojnimap.cpp 코드로 수정해본다.  </p><p>우선 System.loadLibrary() 메서드의 동작 방식을 알아보자.  </p><ol><li>자바 코드에서 System.loadLibrary() 메서드를 호출하면 자바 가상 머신은 주어진 이름을 가진 공유 라이브러리를 로드한다.  </li><li>자바 가상 머신은 로드한 라이브러리 내의 함수 심볼을 검색해서 JNI_OnLoad()라는 함수가 구현돼 있는지 확인하고 라이브러리에 해당 함수가 포함돼 있으면 자동으로 JNI_OnLoad() 함수를 호출한다.  </li><li>만약 JNI_OnLoad() 함수가 구현돼 있지 않다면 자바 가상 머신은 자동으로 네이티브 메서드와 라이브러리 내의 JNI 네이티브 함수의 심볼을 비교해서 매핑 작업을 수행한다.</li></ol><p>다음은 hellojnimap.cpp 소스 코드이다.  </p><p><img src="/images/post/jni13.png" alt="jni13" title="jni13">  </p><p>컴파일 화면은 다음과 같다.  </p><p><img src="/images/post/jni14.png" alt="jni14" title="jni14">  </p>]]></content>
    
    
    <categories>
      
      <category>Android</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Android</tag>
      
      <tag>인사이드 안드로이드</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[인사이드 안드로이드] 챕터 4 - JNI와 NDK(1)</title>
    <link href="/chapter4/"/>
    <url>/chapter4/</url>
    
    <content type="html"><![CDATA[<h1 id="인사이드-안드로이드"><a href="#인사이드-안드로이드" class="headerlink" title="[인사이드 안드로이드]"></a>[인사이드 안드로이드]</h1><h2 id="Chapter4-JNI와-NDK-1"><a href="#Chapter4-JNI와-NDK-1" class="headerlink" title="Chapter4 - JNI와 NDK(1)"></a>Chapter4 - JNI와 NDK(1)</h2><h3 id="안드로이드와-JNI"><a href="#안드로이드와-JNI" class="headerlink" title="안드로이드와 JNI"></a>안드로이드와 JNI</h3><p>안드로이드 프레임워크는 자바와 C&#x2F;C++ 기반 모듈이 계층별로 구성돼 있다. C&#x2F;C++ 레이어와 자바 레이어가 서로 상호 작용하면서 동작하고 있다.<br>이처럼 프레임워크에서 유기적으로 동작하게 만들려면 자바레이어(상위)와 C&#x2F;C++ 레이어(하위)를 상호 연결해 주는 매개체가 필요하다.<br>자바와 C&#x2F;C++ 모듈 간의 인터페이스를 가능하게 해주는 것이 바로 **JNI(Java Native Interface)**다.  </p><p>JNI는 일반적으로 다음과 같은 경우에 주로 활용한다.  </p><ul><li>빠른 처리 속도를 요구하는 루틴 작성(자바는 C&#x2F;C++보다 느리기 때문에 C&#x2F;C++로 작성하고 JNI를 통해 자바에서 호출하는 방법)  </li><li>하드웨어 제어(하드웨어 제어 코드를 C로 작성하면 JNI를 통해 자바에서도 하드웨어 제어 가능)  </li><li>기존 C&#x2F;C++ 프로그램의 재사용</li></ul><p><strong>JNI에 대해 알아야 하는 이유</strong><br>안드로이드에서는 JNI를 이용하여 자바와 C&#x2F;C++의 장점을 동시에 활용하고 있다.<br>안드로이드 SDK를 토대로 만든 안드로이드 애플리케이션은 달빅 가상 머신(Dalvik Virtual Machine) 위에서 동작하는 자바 기반의 프로그램이다. 때문에 C&#x2F;C++로 생성한 애플리케이션에 비해 느린 실행속도 등의 한계를 가진다. 프로그램의 주요 모듈은 자바 개발자가, 성능에 민감한 모듈은 C&#x2F;C++ 개발자가 작성한다.<br>안드로이드를 탑재할 장치에 안드로이드 프레임워크에서 지원하지 않는 하드웨어가 설치돼 있다면 디바이스 드라이버를 C언어로 구현하고 JNI로 매핑시켜야 한다.  </p><h3 id="JNI의-기본-원리-이해"><a href="#JNI의-기본-원리-이해" class="headerlink" title="JNI의 기본 원리 이해"></a>JNI의 기본 원리 이해</h3><h4 id="자바에서-C-라이브러리-함수-호출하기"><a href="#자바에서-C-라이브러리-함수-호출하기" class="headerlink" title="자바에서 C 라이브러리 함수 호출하기"></a>자바에서 C 라이브러리 함수 호출하기</h4><h5 id="자바-코드-작성"><a href="#자바-코드-작성" class="headerlink" title="자바 코드 작성"></a>자바 코드 작성</h5><p><img src="/images/post/jni1.png" alt="jni1" title="jni1">  </p><p>JNI 네이티브 함수와 연결할 메서드를 <strong>native 키워드</strong>를 이용해서 선언한다.<br>네이티브 메서드가 실제로 구현돼 있는 C 라이브러리를 <strong>System.loadLibraray() 메서드</strong>를 호출해서 로딩한다.  </p><h5 id="자바-코드-컴파일"><a href="#자바-코드-컴파일" class="headerlink" title="자바 코드 컴파일"></a>자바 코드 컴파일</h5><p>작성한 소스 코드를 javac(자바 컴파일러)로 컴파일한다. 컴파일 후에 .class파일이 생성되지만 자바 가상 머신이 로딩할 C라이브러리를 찾지 못하여 실행 시 아래와 같이 오류가 출력된다.  </p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs stylus">Exception <span class="hljs-keyword">in</span> thread <span class="hljs-string">&quot;main&quot;</span> java<span class="hljs-selector-class">.lang</span><span class="hljs-selector-class">.UnsatisfiedLinkError</span>: no hellojni <span class="hljs-keyword">in</span> java<span class="hljs-selector-class">.library</span><span class="hljs-selector-class">.path</span><br>    at java<span class="hljs-selector-class">.lang</span><span class="hljs-selector-class">.ClassLoader</span><span class="hljs-selector-class">.loadLibrary</span>(ClassLoader<span class="hljs-selector-class">.java</span>:<span class="hljs-number">1684</span>)<br>    at java<span class="hljs-selector-class">.lang</span><span class="hljs-selector-class">.Runtime</span><span class="hljs-selector-class">.loadLibrary0</span>(Runtime<span class="hljs-selector-class">.java</span>:<span class="hljs-number">822</span>)<br>    at java<span class="hljs-selector-class">.lang</span><span class="hljs-selector-class">.System</span><span class="hljs-selector-class">.loadLibrary</span>(System<span class="hljs-selector-class">.java</span>:<span class="hljs-number">993</span>)<br>    at HelloJNI.&lt;clinit&gt;(HelloJNI<span class="hljs-selector-class">.java</span>:<span class="hljs-number">6</span>)<br></code></pre></td></tr></table></figure><h5 id="C-헤더-파일-생성"><a href="#C-헤더-파일-생성" class="headerlink" title="C 헤더 파일 생성"></a>C 헤더 파일 생성</h5><p>javah툴을 이용하여 헤더파일을 생성한다.<br>생성된 .h파일의 내용은 다음과 같다.<br><img src="/images/post/jni2.png" alt="jni2" title="jni2">  </p><h5 id="C-x2F-C-코드-구현"><a href="#C-x2F-C-코드-구현" class="headerlink" title="C&#x2F;C++ 코드 구현"></a>C&#x2F;C++ 코드 구현</h5><p>헤더파일에 정의된 함수 원형을 .c파일에 복사하여 구현을 완료한다. 이 때 <strong>매개변수의 이름을 지정</strong>해 주어야한다.<br><img src="/images/post/jni3.png" alt="jni3" title="jni3">  </p><h5 id="C-공유-라이브러리-생성"><a href="#C-공유-라이브러리-생성" class="headerlink" title="C 공유 라이브러리 생성"></a>C 공유 라이브러리 생성</h5><p>헤더 파일과 소스 파일을 가지고 공유 라이브러리를 만든다. 윈도우에서는 .dll파일을 생성한다.<br>나는 우분투에서 진행했기 때문에 아래와 같은 명령어로 .so파일을 생성한다.  </p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">gcc -I<span class="hljs-regexp">/(JAVA_HOME)/i</span>nclude<span class="hljs-regexp">/ -I/</span>(JAVA_HOME)<span class="hljs-regexp">/include/</span>linux -shared -fPIC hellojni.c -o libhellojni.so<br></code></pre></td></tr></table></figure><p><strong>(JAVA_HOME)부분에는 JDK가 설치된 경로를 입력한다.</strong><br>나와 같은 경우에는 다음과 같이 입력했다.  </p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">gcc -I<span class="hljs-regexp">/usr/</span>lib<span class="hljs-regexp">/jvm/</span>java5<span class="hljs-regexp">/jdk1.5.0_22/i</span>nclude<span class="hljs-regexp">/ -I/u</span>sr<span class="hljs-regexp">/lib/</span>jvm<span class="hljs-regexp">/java5/</span>jdk1.<span class="hljs-number">5.0</span>_22<span class="hljs-regexp">/include/</span>linux -shared -fPIC hellojni.c -o libhellojni.so<br></code></pre></td></tr></table></figure><p><strong>-shared &#x3D; .so파일을 생성하기 위해 붙여준다.</strong><br><strong>-fPIC &#x3D; 우분투가 64bit 일 때 붙여준다.</strong><br><strong>.so 파일을 만들때 파일이름 앞에 lib를 붙여줘야 한다!</strong>  </p><h5 id="lib-path-추가"><a href="#lib-path-추가" class="headerlink" title="lib path 추가"></a>lib path 추가</h5><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">sudo nano <span class="hljs-regexp">/etc/</span>profile<br></code></pre></td></tr></table></figure><p>nano 에디터에서 맨 아랫줄에 삽입<br>export LD_LIBRARY_PATH&#x3D;&#x2F;usr&#x2F;lib:&#x2F;usr&#x2F;local&#x2F;lib  </p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs gradle"><span class="hljs-keyword">source</span> <span class="hljs-regexp">/etc/</span>profile<br>sudo mv libhellojni.so <span class="hljs-regexp">/usr/</span>lib/<br></code></pre></td></tr></table></figure><h5 id="자바-프로그램-실행"><a href="#자바-프로그램-실행" class="headerlink" title="자바 프로그램 실행"></a>자바 프로그램 실행</h5><p>자바 클래스를 실행하면 앞서 작업한 내용이 제대로 실행되는 것을 볼 수 있다.  </p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">java HelloJNI</span><br></code></pre></td></tr></table></figure><p><img src="/images/post/jni4.png" alt="jni4" title="jni4">  </p>]]></content>
    
    
    <categories>
      
      <category>Android</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Android</tag>
      
      <tag>인사이드 안드로이드</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[인사이드 안드로이드] 챕터 3 - init 프로세스(2)</title>
    <link href="/chapter3_2/"/>
    <url>/chapter3_2/</url>
    
    <content type="html"><![CDATA[<h1 id="인사이드-안드로이드"><a href="#인사이드-안드로이드" class="headerlink" title="[인사이드 안드로이드]"></a>[인사이드 안드로이드]</h1><h2 id="Chapter3-init-프로세스-2"><a href="#Chapter3-init-프로세스-2" class="headerlink" title="Chapter3 - init 프로세스(2)"></a>Chapter3 - init 프로세스(2)</h2><h3 id="디바이스-노드-파일-생성"><a href="#디바이스-노드-파일-생성" class="headerlink" title="디바이스 노드 파일 생성"></a>디바이스 노드 파일 생성</h3><p>안드로이드에서 애플리케이션이 하드웨어에 접근할 때 <strong>디바이스 드라이버</strong>를 통해서 접근한다.<br>애플리케이션은 디바이스 드라이버에 접근하기 위해 <strong>디바이스 노드</strong>를 사용한다.<br>리눅스에서는 ‘mknod’유틸리티를 지원하지만 <strong>안드로이드에서는 보안문제로 제공하지 않는다.</strong>  </p><h4 id="정적-디바이스-노드-생성"><a href="#정적-디바이스-노드-생성" class="headerlink" title="정적 디바이스 노드 생성"></a>정적 디바이스 노드 생성</h4><p>리눅스에서는 디바이스 노드파일을 “&#x2F;dev” 디렉터리에 정의하고, 이 노드파일을 통해 디바이스 드라이버에 접근한다.<br>하지만 안드로이드의 루트 파일 시스템은 “&#x2F;dev” 디렉터리가 존재하지 않고, <strong>init 프로세스가 두 가지 방법으로 디바이스 노드 파일을 생성</strong>한다.</p><p>① 미리 정의된 디바이스 정보를 바탕으로 init 프로세스가 실행될 때 일괄적으로 디바이스 노드 파일 생성 - <strong>콜드 플러그(Cold Plug)</strong><br>② 시스템 동작 중 USB와 같은 장치가 삽입될 때 이벤트 처리로 디바이스 노드 파일을 동적으로 생성 - <strong>핫 플러그(Hot Plug)</strong>  </p><h5 id="콜드-플러그-방식"><a href="#콜드-플러그-방식" class="headerlink" title="콜드 플러그 방식"></a>콜드 플러그 방식</h5><p>콜드 플러그는 이미 삽입된 장치에 대한 처리를 담당하는 메커니즘.<br>리눅스에서는 부팅 후에 udev 데몬이 실행되면서 “&#x2F;sys” 디렉터리에서 미리 등록된 디바이스 정보를 읽고, 디바이드에 대해 uevent를 발생시켜 디바이스 노드 파일을 생성하는 방식이다.<br><em>udev &#x3D; “&#x2F;dev” 디렉터리에 자동으로 디바이스 노드 파일을 생성하는 역할</em><br><em>uevent &#x3D; 커널에서 사용자 공간의 프로세스로 메시지를 전달하기 위한 신호 체계</em>  </p><p>이를 안드로이드에서는 udev 데몬의 역할을 <strong>init 프로세스가 수행</strong>한다.  </p><p>책에서는 콜드 플러그 방식으로 디바이스 노드를 생성하는 예로 7장의 ‘안드로이드 바인더 IPC’를 통해 설명한다.<br>먼저 바인더 드라이버는 가상의 장치이며 프로세스간의 RPC(Remote Procedure Call)를 제공하는 데 쓰인다.<br>바인더를 이용하려는 응용프로그램은 “&#x2F;dev&#x2F;binder”라는 디바이스 노드를 사용해서 바인더 디바이스에 접근해야 한다.  </p><p><strong>커널 부팅 시</strong><br>커널 부팅 시 바인더 드라이버는 misc_register() 함수를 통해서 디바이스 노드 파일을 생성하는 데 필요한 정보를 “&#x2F;sys” 파일 시스템에 저장한다.<br>이제 init 프로세스를 통해 디바이스 노드 파일을 생성해야 하는데, <strong>아직 커널 부팅 단계이므로 uevent를 발생시킬 수 없다.</strong>  </p><p><strong>커널 부팅 완료</strong><br>init 프로세스가 실행되면 위의 바인더 드라이버처럼 디바이스 노드 파일을 생성하지 못한 드라이버에 대해 콜드플러그 처리를 한다.<br>콜드 플러그 처리될 드라이버들은 아래처럼 <strong>devices.c 파일에 미리 정의</strong>되어있다.  </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">static</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">perms_</span> devperms[] = &#123;  <br>    &#123; <span class="hljs-string">&quot;/dev/null&quot;</span>,          <span class="hljs-number">0666</span>,   AID_ROOT,       AID_ROOT,       <span class="hljs-number">0</span> &#125;,  <br>    &#123; <span class="hljs-string">&quot;/dev/zero&quot;</span>,          <span class="hljs-number">0666</span>,   AID_ROOT,       AID_ROOT,       <span class="hljs-number">0</span> &#125;,  <br>    &#123; <span class="hljs-string">&quot;/dev/full&quot;</span>,          <span class="hljs-number">0666</span>,   AID_ROOT,       AID_ROOT,       <span class="hljs-number">0</span> &#125;,  <br>    &#123; <span class="hljs-string">&quot;/dev/ptmx&quot;</span>,          <span class="hljs-number">0666</span>,   AID_ROOT,       AID_ROOT,       <span class="hljs-number">0</span> &#125;,  <br>    &#123; <span class="hljs-string">&quot;/dev/tty&quot;</span>,           <span class="hljs-number">0666</span>,   AID_ROOT,       AID_ROOT,       <span class="hljs-number">0</span> &#125;,  <br>    &#123; <span class="hljs-string">&quot;/dev/random&quot;</span>,        <span class="hljs-number">0666</span>,   AID_ROOT,       AID_ROOT,       <span class="hljs-number">0</span> &#125;,  <br>    &#123; <span class="hljs-string">&quot;/dev/urandom&quot;</span>,       <span class="hljs-number">0666</span>,   AID_ROOT,       AID_ROOT,       <span class="hljs-number">0</span> &#125;,  <br>    &#123; <span class="hljs-string">&quot;/dev/ashmem&quot;</span>,        <span class="hljs-number">0666</span>,   AID_ROOT,       AID_ROOT,       <span class="hljs-number">0</span> &#125;,  <br>    &#123; <span class="hljs-string">&quot;/dev/binder&quot;</span>,        <span class="hljs-number">0666</span>,   AID_ROOT,       AID_ROOT,       <span class="hljs-number">0</span> &#125;,  <br>    :  <br>    :  <br></code></pre></td></tr></table></figure><p>devperms 구조체를 참고하여 <strong>“&#x2F;dev” 디렉터리에 디바이스 노드 파일들을 생성</strong>한다.<br>구조체는 파일 이름, 접근권한, 사용자 ID, 그룹 ID를 나타낸다.  </p><p><strong>콜드 플러그 처리 절차</strong><br>device_init() 함수는 uevent를 수신하기 위한 소켓을 생성하고, coldboot()를 통해 내부적으로 do_coldboot() 함수를 호출하여 “&#x2F;sys” 디렉터리에 등록된 드라이버에 대해 콜드플러그 처리를 한다.  </p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-built_in">int</span> device<span class="hljs-constructor">_init(<span class="hljs-params">void</span>)</span>  <br>&#123;  <br>    fd = <span class="hljs-keyword">open</span><span class="hljs-constructor">_uevent_socket()</span>; <span class="hljs-comment">// 소켓 생성  </span><br>    t0 = get<span class="hljs-constructor">_usecs()</span>; <span class="hljs-comment">// 시간측정  </span><br>    coldboot(fd, <span class="hljs-string">&quot;/sys/class&quot;</span>);  <br>    coldboot(fd, <span class="hljs-string">&quot;/sys/block&quot;</span>);  <br>    coldboot(fd, <span class="hljs-string">&quot;/sys/devices&quot;</span>);  <br>    t1 = get<span class="hljs-constructor">_usecs()</span>; <span class="hljs-comment">// 시간측정  </span><br>    log<span class="hljs-constructor">_event_print(<span class="hljs-string">&quot;coldboot %ld uS\n&quot;</span>, ((<span class="hljs-params">long</span>)</span> (t1 - t0))); <span class="hljs-comment">// 시간 로그 출력  </span><br>&#125;  <br></code></pre></td></tr></table></figure><p>do_coldboot() 함수에서는 디렉터리 경로를 받아 해당 경로를 이용해 저장된 uevent 파일을 찾은 후, add메시지를 써넣어 uevent를 발생시킨다.<br><em>파일에 add를 넣는다고 uevent가 바로 발생되는가??</em>  </p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">static void <span class="hljs-keyword">do</span><span class="hljs-constructor">_coldboot(<span class="hljs-params">int</span> <span class="hljs-params">event_fd</span>, DIR <span class="hljs-operator">*</span><span class="hljs-params">d</span>)</span>  <br>&#123;  <br>    fd = openat(dfd, <span class="hljs-string">&quot;uevent&quot;</span>, O_WRONLY); <span class="hljs-comment">// uevent 파일을 찾아서  </span><br>    <span class="hljs-keyword">if</span>(fd &gt;= <span class="hljs-number">0</span>) &#123;  <br>        write(fd, <span class="hljs-string">&quot;add\n&quot;</span>, <span class="hljs-number">4</span>); <span class="hljs-comment">// &quot;add&quot; 메시지 추가로 uevent 발생  </span><br>        close(fd);  <br>        handle<span class="hljs-constructor">_device_fd(<span class="hljs-params">event_fd</span>)</span>; <span class="hljs-comment">// uevent 수신하여 처리  </span><br>    &#125;  <br>&#125;  <br></code></pre></td></tr></table></figure><p>그리고 handle_device_fd() 함수에서 uevent를 수신하여 메시지를 수신해서 uevent구조체에 할당한다.<br>uevent 구조체를 완성하면 handle_device_event() 함수를 호출하여 실제 노드 파일을 생성한다.<br><strong>&#x2F;dev 디렉터리 아래에 하위 디렉터리를 생성</strong>한다.  </p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">handle_device_event</span>(<span class="hljs-params"><span class="hljs-keyword">struct</span> uevent *uevent</span>) <span class="hljs-comment">// uevent 구조체를 받아서  </span></span><br>&#123;  <br>  <span class="hljs-keyword">if</span>(!strncmp(uevent-&gt;subsystem, <span class="hljs-string">&quot;block&quot;</span>, <span class="hljs-number">5</span>)) &#123;  <br>          block = <span class="hljs-number">1</span>;  <br>          <span class="hljs-keyword">base</span> = <span class="hljs-string">&quot;/dev/block/&quot;</span>;  <br>          mkdir(<span class="hljs-keyword">base</span>, <span class="hljs-number">0755</span>); <span class="hljs-comment">// 하위 디렉터리를 생성.  </span><br>      &#125;  <br>&#125;  <br></code></pre></td></tr></table></figure><p>하위 디렉터리를 모두 생성하면 <strong>make_device() 함수를 통해 디바이스 노드 파일을 생성</strong>한다.  </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">make_device</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *path, <span class="hljs-type">int</span> block, <span class="hljs-type">int</span> major, <span class="hljs-type">int</span> minor)</span>  </span><br><span class="hljs-function"></span>&#123;  <br>    <span class="hljs-type">mode_t</span> mode;  <br>    <span class="hljs-type">dev_t</span> dev;  <br>    <span class="hljs-built_in">mknod</span>(path, mode, dev); <span class="hljs-comment">// 디바이스 노드 파일 생성  </span><br>    <span class="hljs-built_in">chown</span>(path, uid, <span class="hljs-number">-1</span>);  <br>&#125;  <br></code></pre></td></tr></table></figure><h4 id="동적-디바이스-감지"><a href="#동적-디바이스-감지" class="headerlink" title="동적 디바이스 감지"></a>동적 디바이스 감지</h4><p>init 프로세스는 시스템 동작 중 추가되는 장치의 디바이스 노드 파일 생성을 위해 핫플러그 처리를 지원한다.  </p><h5 id="핫-플러그-방식"><a href="#핫-플러그-방식" class="headerlink" title="핫 플러그 방식"></a>핫 플러그 방식</h5><p>다음과 같이 init 프로세스의 이벤트 처리 루프에서 처리된다.  </p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-built_in">int</span> main(<span class="hljs-built_in">int</span> argc, <span class="hljs-built_in">char</span> **argv)  <br>&#123;  <br>  <span class="hljs-keyword">for</span>(;;) &#123;  <br>        nr = poll(ufds, fd_count, timeout); <span class="hljs-comment">// poll 함수를 통해서 uevent를 감지  </span><br>        :  <br>        :  <br>        <span class="hljs-keyword">if</span> (ufds<span class="hljs-literal">[<span class="hljs-number">0</span>]</span>.revents<span class="hljs-operator"> == </span>POLLIN)  <br>            handle<span class="hljs-constructor">_device_fd(<span class="hljs-params">device_fd</span>)</span>; <span class="hljs-comment">// 콜드 플러그와 같이 handle_device_fd() 함수를 호출  </span><br>  &#125;  <br>&#125;  <br></code></pre></td></tr></table></figure><h3 id="프로세스-종료와-재시작"><a href="#프로세스-종료와-재시작" class="headerlink" title="프로세스 종료와 재시작"></a>프로세스 종료와 재시작</h3><p>다양한 프로세스들이 init 프로세스에 의해 실행되고, 종료되면 시스템 동작에 영향을 미치는 것들이 존재한다.<br>따라서 init 프로세스가 실행하는 프로세스는 일부를 제외하고 <strong>대부분은 재시작된다.</strong><br>프로세스 옵션에 <strong>onshot이 정의돼 있다면 재시작하지 않는다.</strong>  </p><h4 id="프로세스-재시작-코드-분석"><a href="#프로세스-재시작-코드-분석" class="headerlink" title="프로세스 재시작 코드 분석"></a>프로세스 재시작 코드 분석</h4><p>자식 프로세스가 종료되면 다음과 같이 SIGCHLD 시그널에 대한 핸들러를 수행한다.  </p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs scss">static void <span class="hljs-built_in">sigchld_handler</span>(int s) <span class="hljs-comment">// SIGCHLD 시그널 번호를 받는다.  </span><br>&#123;  <br>    <span class="hljs-built_in">write</span>(signal_fd, &amp;s, <span class="hljs-number">1</span>); <span class="hljs-comment">// 소켓 디스크립터에 기록한다.  </span><br>&#125;  <br></code></pre></td></tr></table></figure><p>signal_fd는 이전에 소켓쌍으로 생성됐기 떄문에 수신측 소켓 디스크립터인 <strong>signal_recv_fd</strong>로 시그널 번호를 전송한다.<br>시그널 번호를 받은 signal_recv_fd는 main에서 이미 POLL로 등록돼 있기 때문에 <strong>wait_for_one_process() 함수를 실행</strong>하게 된다.<br><em>poll()함수는 이벤트 처리 루프에서 이벤트를 감시했었음.</em>  </p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-function"><span class="hljs-built_in">int</span> <span class="hljs-title">main</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> argc, <span class="hljs-built_in">char</span> **argv</span>)</span>  <br>&#123;  <br>  <span class="hljs-keyword">for</span>(;;) &#123;  <br>    nr = poll(ufds, fd_count, timeout); <span class="hljs-comment">// poll() 함수는 이벤트를 감시하다가 빠져나옴.  </span><br>    <span class="hljs-keyword">if</span> (nr &lt;= <span class="hljs-number">0</span>)  <br>        <span class="hljs-keyword">continue</span>;  <br><br>    <span class="hljs-keyword">if</span> (ufds[<span class="hljs-number">2</span>].revents == POLLIN) &#123;  <br>        <span class="hljs-comment">/* we got a SIGCHLD - reap and restart as needed */</span>  <br>        read(signal_recv_fd, tmp, <span class="hljs-keyword">sizeof</span>(tmp));  <br>        <span class="hljs-keyword">while</span> (!wait_for_one_process(<span class="hljs-number">0</span>)); <span class="hljs-comment">// wait_for_one_process() 함수를 수행.  </span><br>        <span class="hljs-keyword">continue</span>;  <br>    &#125;  <br>  &#125;  <br>&#125;  <br></code></pre></td></tr></table></figure><p>다음은 <strong>wait_for_one_process() 함수</strong>를 보여준다.  </p><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs xl">static int wait_for_one_process(int <span class="hljs-keyword">block</span>)  <br>&#123;  <br>    :  <br>    :  <br>    <span class="hljs-keyword">while</span> ( (pid = waitpid(-<span class="hljs-number">1</span>, &amp;status, <span class="hljs-keyword">block</span> ? <span class="hljs-number">0</span> : WNOHANG)) == -<span class="hljs-number">1</span> &amp;&amp; errno == EINTR ); <span class="hljs-comment">// 프로세스가 종료되면 할당된 자원을 회수.  </span><br><br>    svc = service_find_by_pid(pid); <span class="hljs-comment">// 종료된 프로세스에 해당하는 서비스 항목을 가져옴.  </span><br><br>    <span class="hljs-function"><span class="hljs-title">if</span> (!(svc-&gt;</span>flags &amp; SVC_ONESHOT)) &#123; <span class="hljs-comment">// 가져온 서비스 항목의 옵션에 SVC_ONESHOT이 설정 되어있는지 체크.  </span><br>        kill(-pid, SIGKILL); <span class="hljs-comment">// SVC_ONESHOT이 설정 되어있으면 종료  </span><br>        NOTICE(<span class="hljs-string">&quot;process &#x27;%s&#x27; killing any children in process group\n&quot;</span>, <span class="hljs-function"><span class="hljs-title">svc</span>-&gt;</span><span class="hljs-keyword">name</span>);  <br>    &#125;  <br><br>    <span class="hljs-comment">/* remove any sockets we may have created */</span>  <br>    <span class="hljs-function"><span class="hljs-title">for</span> (si = svc-&gt;</span><span class="hljs-function"><span class="hljs-title">sockets</span>; si; si = si-&gt;</span>next) &#123; <span class="hljs-comment">// 프로세스가 가진 소켓 디스크립터를 모두 삭제.  </span><br>        char tmp[<span class="hljs-number">128</span>];  <br>        <span class="hljs-function"><span class="hljs-title">snprintf</span>(tmp, sizeof(tmp), ANDROID_SOCKET_DIR&quot;/%s&quot;, si-&gt;</span><span class="hljs-keyword">name</span>);  <br>        unlink(tmp);  <br>    &#125;  <br><br>    <span class="hljs-function"><span class="hljs-title">svc</span>-&gt;</span>pid = <span class="hljs-number">0</span>;  <br>    <span class="hljs-function"><span class="hljs-title">svc</span>-&gt;</span>flags &amp;= (~SVC_RUNNING); <span class="hljs-comment">// 프로세스가 구동중임을 나타내는 pid 값, SVC_RUNNING을 제거.  </span><br><br>        <span class="hljs-comment">/* oneshot processes go into the disabled state on exit */</span>  <br>    <span class="hljs-function"><span class="hljs-title">if</span> (svc-&gt;</span>flags &amp; SVC_ONESHOT) &#123; <span class="hljs-comment">// SVC_ONESHOT 옵션이 설정된 프로세스의 플래그를  </span><br>        <span class="hljs-function"><span class="hljs-title">svc</span>-&gt;</span>flags |= SVC_DISABLED; <span class="hljs-comment">// disabled 설정하고  </span><br>    &#125;  <br><br>        <span class="hljs-comment">/* disabled processes do not get restarted automatically */</span>  <br>    <span class="hljs-function"><span class="hljs-title">if</span> (svc-&gt;</span>flags &amp; SVC_DISABLED) &#123; <span class="hljs-comment">// disabled 설정된 프로세스는  </span><br>        <span class="hljs-function"><span class="hljs-title">notify_service_state</span>(svc-&gt;</span><span class="hljs-keyword">name</span>, <span class="hljs-string">&quot;stopped&quot;</span>);  <br>        return <span class="hljs-number">0</span>; <span class="hljs-comment">// 함수를 빠져나가서 재시작되지 않는다.  </span><br>    &#125;  <br><br>    <span class="hljs-comment">/* Execute all onrestart commands for this service. */</span>  <br>    <span class="hljs-function"><span class="hljs-title">list_for_each</span>(node, &amp;svc-&gt;</span>onrestart.commands) &#123; <span class="hljs-comment">// 재시작할 프로세스가 onrestart 옵션을 가지는지 체크.  </span><br>        cmd = node_to_item(node, struct command, clist);  <br>        <span class="hljs-function"><span class="hljs-title">cmd</span>-&gt;</span><span class="hljs-function"><span class="hljs-title">func</span>(cmd-&gt;</span><span class="hljs-function"><span class="hljs-title">nargs</span>, cmd-&gt;</span>args);  <br>    &#125;  <br><br>    <span class="hljs-function"><span class="hljs-title">svc</span>-&gt;</span>flags |= SVC_RESTARTING; <span class="hljs-comment">// 프로세스의 플래그에 SVC_RESTARTING를 추가한다.  </span><br>&#125;  <br></code></pre></td></tr></table></figure><p>wait_for_one_process() 함수의 실행이 완료되면 <strong>restart_processes() 함수를 실행</strong>한다.  </p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">restart_processes</span>()</span>  <br>&#123;  <br>    process_needs_restart = <span class="hljs-number">0</span>;  <br>    service_for_each_flags(SVC_RESTARTING, restart_service_if_needed); <span class="hljs-comment">// SVC_RESTARTING 플래그를 가진 프로세스를 실행한다.  </span><br>&#125;  <br></code></pre></td></tr></table></figure><p>따라서 자식프로세스가 종료되어 SIGCHLD 시그널을 발생시키더라도 이 함수를 통해 재시작하게 된다.  </p><h3 id="프로퍼티-서비스"><a href="#프로퍼티-서비스" class="headerlink" title="프로퍼티 서비스"></a>프로퍼티 서비스</h3><p>init 프로세스의 이벤트 처리 루프에서는 프로퍼티의 변경 요청 이벤트도 있다.  </p><ul><li>프로퍼티는 안드로이드 시스템이 동작하는 데 필요한 <strong>각종 설정 값을 동작 중인 모든 프로세스에서 공유하기 위해 프로퍼티라는 저장 공간을 사용</strong>한다.  </li><li>프로퍼티는 키(key)와 값(value)로 구성되며, ‘키 &#x3D; 값’ 형태로 사용된다.  </li><li>안드로이드에서는 이 값을 변경할 때는 권한을 확인하는 과정이 있다.  </li><li>모든 동작중인 프로세스는 프로퍼티의 값을 조회할 수 있다.  </li><li>프로퍼티 값을 <strong>변경하는 것은 init 프로세스만이 가능</strong>, 다른 프로세스는 변경 요청.  </li><li>프로퍼티의 값이 변경되면 init.rc에 정의된 특정 조건을 만족하는 경우 조건에 해당하는 동작 실행, **이를 트리거(trigger)**라 한다.</li></ul><h4 id="프로퍼티-초기화"><a href="#프로퍼티-초기화" class="headerlink" title="프로퍼티 초기화"></a>프로퍼티 초기화</h4><p>init 프로세스의 main() 함수 초기에 <strong>property_init() 함수</strong>를 통해서 프로퍼티 영역을 초기화한다.<br>property_init() 함수는 프로퍼티의 값을 저장하기 위한 공유 메모리를 생성하는데, 이를 위해 ashmem(Android Shared Memory)을 사용한다.<br><em>프로퍼티 값을 저장하거나 조회할때는 get(), set() 함수를 이용한다.</em>  </p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs scss">void <span class="hljs-built_in">property_init</span>(void)  <br>&#123;  <br>    <span class="hljs-built_in">init_property_area</span>(); <span class="hljs-comment">// 공유 메모리 영역 구성.  </span><br>    <span class="hljs-built_in">load_properties_from_file</span>(PROP_PATH_RAMDISK_DEFAULT); <span class="hljs-comment">// 파일로 부터 초기값을 읽어 프로퍼티 값을 설정.  </span><br>&#125;  <br></code></pre></td></tr></table></figure><p>init 프로세스는 start_property_service() 함수를 호출하여 프로퍼티 서비스를 시작한다.  </p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">property_set_fd</span> = start_property_service()<span class="hljs-comment">; // 프로퍼티 서비스 시작.  </span><br></code></pre></td></tr></table></figure><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-built_in">int</span> start<span class="hljs-constructor">_property_service(<span class="hljs-params">void</span>)</span>  <br>&#123;  <br>    <span class="hljs-built_in">int</span> fd;  <br>    load<span class="hljs-constructor">_properties_from_file(PROP_PATH_SYSTEM_BUILD)</span>; <span class="hljs-comment">// 프로퍼티의 기본값을 읽어 프로퍼티 값을 설정.  </span><br>    load<span class="hljs-constructor">_properties_from_file(PROP_PATH_SYSTEM_DEFAULT)</span>;  <br>    load<span class="hljs-constructor">_properties_from_file(PROP_PATH_LOCAL_OVERRIDE)</span>;  <br><br>    <span class="hljs-comment">/* Read persistent properties after all default values have been loaded. */</span>  <br>    load<span class="hljs-constructor">_persistent_properties()</span>; <span class="hljs-comment">// /data/property 디렉터리에 저장돼 있는 프로퍼티 값을 읽는다. (동작 중에 다른 프로세스에 의해 생성된 프로퍼티 값이나 변경된 값들)  </span><br>    fd = create<span class="hljs-constructor">_socket(PROP_SERVICE_NAME, SOCK_STREAM, 0666, 0, 0)</span>; <span class="hljs-comment">// property_service라는 이름의 도메인 소켓 생성.  </span><br>&#125;  <br></code></pre></td></tr></table></figure><h4 id="프로퍼티-변경-요청-처리"><a href="#프로퍼티-변경-요청-처리" class="headerlink" title="프로퍼티 변경 요청 처리"></a>프로퍼티 변경 요청 처리</h4><p>앞에서 생성한 소켓으로 프로퍼티 값의 변경 요청 메시지가 수신되면 <strong>handle_property_set_fd() 함수가 호출</strong>된다.  </p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">void handle<span class="hljs-constructor">_property_set_fd(<span class="hljs-params">int</span> <span class="hljs-params">fd</span>)</span>  <br>&#123;  <br>    <span class="hljs-comment">/* Check socket options here */</span>  <br>    <span class="hljs-keyword">if</span> (getsockopt(s, SOL_SOCKET, SO_PEERCRED, &amp;cr, &amp;cr_size) &lt; <span class="hljs-number">0</span>) &#123; <span class="hljs-comment">// 소켓으로 부터 값을 얻어온다.  </span><br>        close(s);  <br>        <span class="hljs-constructor">ERROR(<span class="hljs-string">&quot;Unable to recieve socket options\n&quot;</span>)</span>;  <br>        return;  <br>    &#125;  <br>    :  <br>    :  <br>    switch(msg.cmd) &#123;  <br>    case PROP_MSG_SETPROP:  <br>        <span class="hljs-keyword">if</span>(memcmp(msg.name,<span class="hljs-string">&quot;ctl.&quot;</span>,<span class="hljs-number">4</span>)<span class="hljs-operator"> == </span><span class="hljs-number">0</span>) &#123; <span class="hljs-comment">// &quot;ctl&quot;은 시스템 프로퍼티 값을 변경하는 것이 아니라, 프로세스의 시작, 종료를 요청하는 메시지.  </span><br>            <span class="hljs-keyword">if</span> (check<span class="hljs-constructor">_control_perms(<span class="hljs-params">msg</span>.<span class="hljs-params">value</span>, <span class="hljs-params">cr</span>.<span class="hljs-params">uid</span>, <span class="hljs-params">cr</span>.<span class="hljs-params">gid</span>)</span>) &#123; <span class="hljs-comment">// check_control_perms() 함수를 이용하여 접근 권한 검사. (system server, root, 해당 프로세스만 종료하거나 시작할 수 있음)  </span><br>                handle<span class="hljs-constructor">_control_message((<span class="hljs-params">char</span><span class="hljs-operator">*</span>)</span> msg.name + <span class="hljs-number">4</span>, (<span class="hljs-built_in">char</span>*) msg.value);  <br>            &#125; <span class="hljs-keyword">else</span> &#123;  <br>                <span class="hljs-constructor">ERROR(<span class="hljs-string">&quot;sys_prop: Unable to %s service ctl [%s] uid: %d pid:%d\n&quot;</span>, <span class="hljs-params">msg</span>.<span class="hljs-params">name</span> + 4, <span class="hljs-params">msg</span>.<span class="hljs-params">value</span>, <span class="hljs-params">cr</span>.<span class="hljs-params">uid</span>, <span class="hljs-params">cr</span>.<span class="hljs-params">pid</span>)</span>;  <br>            &#125;  <br>        &#125; <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">// 시스템의 프로퍼티를 변경하는 데 사용.  </span><br>            <span class="hljs-keyword">if</span> (check<span class="hljs-constructor">_perms(<span class="hljs-params">msg</span>.<span class="hljs-params">name</span>, <span class="hljs-params">cr</span>.<span class="hljs-params">uid</span>, <span class="hljs-params">cr</span>.<span class="hljs-params">gid</span>)</span>) &#123; <span class="hljs-comment">// 접근 권한은 check_perms() 함수를 호출하여 검사한다.  </span><br>                property<span class="hljs-constructor">_set((<span class="hljs-params">char</span><span class="hljs-operator">*</span>)</span> msg.name, (<span class="hljs-built_in">char</span>*) msg.value); <span class="hljs-comment">// 프로퍼티 값을 변경한다.  </span><br>            &#125;  <br>        &#125;  <br>    &#125;  <br>&#125;  <br></code></pre></td></tr></table></figure><p>프로퍼티 값을 변경하고, 문제가 없다면 <strong>property_changed() 함수가 호출</strong>된다.  </p>]]></content>
    
    
    <categories>
      
      <category>Android</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Android</tag>
      
      <tag>인사이드 안드로이드</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[인사이드 안드로이드] 챕터 3 - init 프로세스(1)</title>
    <link href="/chapter3/"/>
    <url>/chapter3/</url>
    
    <content type="html"><![CDATA[<h1 id="인사이드-안드로이드"><a href="#인사이드-안드로이드" class="headerlink" title="[인사이드 안드로이드]"></a>[인사이드 안드로이드]</h1><h2 id="Chapter3-init-프로세스-1"><a href="#Chapter3-init-프로세스-1" class="headerlink" title="Chapter3 - init 프로세스(1)"></a>Chapter3 - init 프로세스(1)</h2><h3 id="init-프로세스의-실행-과정"><a href="#init-프로세스의-실행-과정" class="headerlink" title="init 프로세스의 실행 과정"></a>init 프로세스의 실행 과정</h3><p>먼저 커널소스를 받기위해 깃을 사용했다.  </p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs awk">sudo apt-get install git  <br>git clone https:<span class="hljs-regexp">//</span>android.googlesource.com<span class="hljs-regexp">/kernel/</span>common.git kernel  <br>cd kernel  <br>git branch -r  <br></code></pre></td></tr></table></figure><p>위의 명령어로 브랜치 정보를 확인해서, 나는 3.18버전을 체크아웃 받았다.  </p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">git</span> checkout origin/android-<span class="hljs-number">3</span>.<span class="hljs-number">18</span>  <br></code></pre></td></tr></table></figure><h4 id="init-post-함수"><a href="#init-post-함수" class="headerlink" title="init_post()함수"></a>init_post()함수</h4><p>책에서는 init_post()함수에 대해서 설명했는데, 내가 3.18버전을 받아서 그런지 비슷한 코드의 함수명이 달랐다.<br>3.18에서는 __ref형을 반환하는 kernel_init() 함수.  </p><p><img src="/images/post/ch3.PNG" alt="Alt text" title="ch3">                                                </p><p>책과 다른 점이 있었는데, run_init_process의 리턴값을 받아서 false일 경우에 바로 종료시키는 구문이 추가되었다.<br>또한 &#x2F;sbin, &#x2F;etc, &#x2F;bin 디렉터리에서 init파일을 못찾았을 경우 커널 패닉이 일어날 경우에 대한 메시지가 있었다.<br>이 과정을 정상적으로 수행하면 init 프로세스를 실행한다.  </p><h3 id="init-프로세스의-소스-코드-분석"><a href="#init-프로세스의-소스-코드-분석" class="headerlink" title="init 프로세스의 소스 코드 분석"></a>init 프로세스의 소스 코드 분석</h3><p>main()에서 모든 프로세스의 부모인 init 프로세스는 자신이 생성한 프로세스가 종료됐을 때 발생하는 SIGCHLD 시그널을 처리할 핸들러를 등록한다.<br><em>리눅스의 프로세스들은 정보 교환으로 메시지를 주고 받는데 이를 시그널이라 하고, 처리하기 위한 루틴을 시그널 핸들러라고 한다.</em>  </p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs lisp">(<span class="hljs-name">sigaction</span> 구조체인 act에 값을 넣음.)  <br>sigaction(<span class="hljs-name">SIGCHLD</span>, <span class="hljs-symbol">&amp;act</span>, <span class="hljs-number">0</span>)<span class="hljs-comment">;  </span><br></code></pre></td></tr></table></figure><p>init 프로세스는 시그널 핸들러를 등록하고 부팅에 필요한 디렉터리를 생성하고 마운트한다.<br>이렇게 생성된 &#x2F;dev, &#x2F;proc, &#x2F;sys와 같은 디렉터리는 init 프로세스가 동작 중에 생성하고 시스템이 종료되면 다시 사라진다.  </p><p>디렉터리가 생성된 이후에 <strong>open_devnull_stdio()</strong> 함수를 통해 실행 로그를 출력하기 위한 장치를 생성한다. 입출력에 관련된 파일이 모두 <strong><strong>null</strong></strong> 장치로 변경되어 open_devnull_stdio() 함수를 수행한 init 프로세스는 표준 입출력을 통해 메시지를 출력할 수 없다. 해당 프로세스들은 <strong>log_init()</strong> 함수를 통해 로그 메시지를 출력하기 위한 새로운 출력 장치를 제공한다. log_init() 함수는 <strong><strong>kmsg</strong></strong> 디바이스 노드 파일을 생성한다. 이는 커널의 메시지 출력 함수인 printk() 함수를 사용하게 하고 이 장치를 통해 로그 메시지를 출력한다.  </p><p>안드로이드는 init.rc와 init.{hardware}.rc 파일을 이용해 실행 파일과 환경 변수를 정의한다.<br><strong>init.rc</strong> 파일은 안드로이드의 공통적인 환경설정 및 프로세스<br><strong>init.{hardware}.rc</strong> 파일은 플랫폼에 따라 특화된 프로세스나 환경 설정 등을 정의한다.<br>출력 장치를 생성한 이후 init.rc 파일을 파싱하게된다.<br>파싱한 후 서비스 리스트와 액션 리스트를 연결리스트 형태로 구성한다.  </p><p><strong>QEMU</strong>는 PC를 위한 오픈소스 에뮬레이터이다. init.rc을 파싱한 후 에뮬레이터 환경을 위해 QEMU 초기화를 한다.  </p><p>다음은 init.rc 파일을 분석했던 것 처럼 init.{hardware}.rc 파일을 파싱한다.<br>서비스 리스트와 액션리스트를 생성하여 init.rc 파일에서 생성했던 서비스 리스트와 액션리스트에 각각 추가된다.  </p><p>init 프로세스는 <strong>‘early-init, init, early-boot, boot’</strong> 섹션에 포함된 명령어들을 순서대로 실행한다.<br>action_for_each_trigger()함수를 이용해 early-init 섹션의 명령어들을 실행 큐인 action_add_queue_tail 큐에 저장하고 drain_action_queue()를 이용해 명령어를 실행한다.  </p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">action<span class="hljs-constructor">_for_each_trigger(<span class="hljs-string">&quot;early-init&quot;</span>, <span class="hljs-params">action_add_queue_tail</span>)</span>;  <br>drain<span class="hljs-constructor">_action_queue()</span>;  <br></code></pre></td></tr></table></figure><p>다음으로 init 프로세스는 <strong>device_init()</strong> 함수를 통해 정적 디바이스 노드를 생성하고 <strong>property_init()</strong> 함수를 통해 프로퍼티 서비스를 초기화 한다.<br><em>프로퍼티 영역은 모든 프로세스에서 시스템의 설정 값을 공유하기 위해 제공된다</em>  </p><p>다음 단계에서 안드로이드 부팅 로고를 출력한다.  </p><p><strong>property_set()</strong> 함수를 이용하여 앞서 생성한 프로퍼티 영역에 시스템 운용에 필요한 초기 값을 설정한다.<br>다음은 init 프로세스의 주요 기능 중 하나인 프로퍼티 서비스를 시작한다.  </p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">property_set_fd</span> = start_property_service()<span class="hljs-comment">;  </span><br></code></pre></td></tr></table></figure><p>init 프로세스는 자식 프로세스의 종료 처리를 위한 핸들러를 따로 정의했다.<br><strong>socketpair()</strong> 함수를 통해 서로 연결된 소켓 쌍 <strong>signal_fd, signal_recv_fd</strong>을 생성하고<br>signal_fd와 signal_recv_fd의 값을 1로 설정한다.<br>이벤트 처리 핸들러에서 signal_recv_fd의 값을 감시하다가 1로 설정되면서 자식 프로세스 종료 처리 핸들러를 호출한다.  </p><p>다음으로 <strong>early-boot, boot, property</strong> 섹션에 해당하는 명령어를 실행한다.</p><p>다음으로 이벤트 처리 루프에 들어가기 전 감시할 이벤트 설정을 한다.<br>poll()함수에서 이벤트를 기다리고 이벤트가 발생하면 poll() 함수를 빠져나와 이벤트를 처리한다.<br><strong>① 디바이스 노드 생성 ② 프로퍼티 서비스 요청 ③ SIGCHLD 시그널 처리</strong><br>이 세가지를 위한 파일 디스크립터를 등록하고, 아래와 같은 <strong>이벤트 처리 루프</strong>에서 poll() 함수의 인자로 넘겨져 이벤트를 감시한다.  </p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-keyword">for</span>(;;) &#123;  <br>    drain<span class="hljs-constructor">_action_queue()</span>;  <span class="hljs-comment">// 이벤트 처리 루프를 한번 수행 한 이후 액션 리스트, 서비스 리스트에서 실행되지 않은 명령들을 확인하고 실행.  </span><br>    restart<span class="hljs-constructor">_processes()</span>;  <span class="hljs-comment">// 자식 프로세스가 종료됐을 때 자식 프로세스 재시작 or 종료.  </span><br><br>    nr = poll(ufds, fd_count, timeout);  <span class="hljs-comment">// 등록한 파일 디스크립터에 발생한 이벤트를 기다린다. 이벤트가 발생하면 ufds에 이벤트 정보가 담김.  </span><br><br>     <span class="hljs-keyword">if</span> (ufds<span class="hljs-literal">[<span class="hljs-number">2</span>]</span>.revents<span class="hljs-operator"> == </span>POLLIN) &#123;  <span class="hljs-comment">//  자식 프로세스가 종료되어 SIGCHLD 시그널이 발생하면 POLLIN 이벤트 등록.  </span><br>         <span class="hljs-comment">/* we got a SIGCHLD - reap and restart as needed */</span>  <br>         read(signal_recv_fd, tmp, sizeof(tmp));  <br>         <span class="hljs-keyword">while</span> (!wait<span class="hljs-constructor">_for_one_process(0)</span>);  <br>         continue;  <br>     &#125;  <br><br>     <span class="hljs-keyword">if</span> (ufds<span class="hljs-literal">[<span class="hljs-number">0</span>]</span>.revents<span class="hljs-operator"> == </span>POLLIN)  <br>         handle<span class="hljs-constructor">_device_fd(<span class="hljs-params">device_fd</span>)</span>; <span class="hljs-comment">// 핫플러그 장치가 삽입됐을 때 디바이스 노드 파일 생성.  </span><br>     <span class="hljs-keyword">if</span> (ufds<span class="hljs-literal">[<span class="hljs-number">1</span>]</span>.revents<span class="hljs-operator"> == </span>POLLIN)  <br>         handle<span class="hljs-constructor">_property_set_fd(<span class="hljs-params">property_set_fd</span>)</span>;  <br>     <span class="hljs-keyword">if</span> (ufds<span class="hljs-literal">[<span class="hljs-number">3</span>]</span>.revents<span class="hljs-operator"> == </span>POLLIN)  <br>         handle<span class="hljs-constructor">_keychord(<span class="hljs-params">keychord_fd</span>)</span>;  <br> &#125;  <br></code></pre></td></tr></table></figure><h3 id="init-rc-파일-분석-및-실행"><a href="#init-rc-파일-분석-및-실행" class="headerlink" title="init.rc 파일 분석 및 실행"></a>init.rc 파일 분석 및 실행</h3><p>init.{hardware}.rc와 init.rc가 동일하게 처리하기 때문에 init.rc에 대해서만 분석한다.<br><strong>init 프로세스는 안드로이드를 빌드해야 생성되지만, init.rc 파일은 안드로이드 플랫폼의 소스코드에서 살펴볼 수 있다.</strong><br><strong>&#x2F;rootdir&#x2F;init.rc</strong>  </p><p>init.rc 파일의 내용은 크게 ‘on’ 키워드의 액션 리스트, ‘service’ 키워드의 서비스 리스트로 나뉜다.<br><strong>액션 리스트 &#x3D; 시스템 환경 변수, 부팅 시 필요한 디렉터리 생성, 퍼미션 지정</strong><br><strong>서비스 리스트 &#x3D; 부팅시 실행하는 프로세스 기술</strong>  </p><h4 id="액션-리스트"><a href="#액션-리스트" class="headerlink" title="액션 리스트"></a>액션 리스트</h4><p>액션 리스트는 <strong>‘on init’</strong> 섹션에서 환경변수를 등록하고, 디렉터리 생성 및 마운트한다.<br>안드로이드의 루트 파일 시스템 구조는 크게 <strong>shell 유틸리티</strong>, 라이브러리, 기본 애플리케이션을 제공하는 <strong>system 디렉터리</strong>, 개발자가 탑재한 사용자 애들리케이션이나 사용자 데이터를 저장하는 <strong>data 디렉터리로</strong> 나뉜다.<br>마운트 부분에서는 &#x2F;system과 &#x2F;data 디렉터리를 마운트한다.  </p><p><strong>‘on boot’</strong> 섹션에서는 애플리케이션 종료 조건 설정, 애플리케이션 구동에 필요한 디렉터리 및 파일 퍼미션 설정 등을 한다.<br>애플리케이션 종료 조건 설정부분에서 애플리케이션 별 <strong>OOM(Out Of Memory)</strong> 조정 값(Adjustment Value)을 지정한다.<br>OOM은 커널 상에서 메모리를 모니터링하면서 메모리가 부족할 때 애플리케이션을 종료시키는 역할을 한다.<br><em>ADJ값이 높을수록 종료 우선순위가 높다.</em>  </p><p><strong>‘on property’</strong> 섹션에서는 프로퍼티 값이 변경될 경우 실행되는 명령이 기술돼 있다.</p><h4 id="서비스-리스트"><a href="#서비스-리스트" class="headerlink" title="서비스 리스트"></a>서비스 리스트</h4><p>**’service’**섹션은 앞서 말한듯이 init 프로세스가 실행시키는 프로세스를 기술한다.<br><em>해당 프로세스에는 부팅음을 출력하는 일회성 프로그램 또는 백그라운드의 애플리케이션이나 시스템 운용에 관여하는 데몬 프로세스가 있다.</em>  </p><p>‘service’ 섹션의 프로세스는 모드 서비스 리스트에 등록되며, init 프로세스가 실행되면서 서비스 리스트에 등록된 프로세스를 순차적으로 실행한다.  </p><h4 id="init-rc-파싱-코드-분석"><a href="#init-rc-파싱-코드-분석" class="headerlink" title="init.rc 파싱 코드 분석"></a>init.rc 파싱 코드 분석</h4><p>parse_config_file() 함수는 인자로 전달되는 파일을 읽고(read_file()), 각 문자열을 파싱한다.(parse_config())<br><em>&#x2F;init&#x2F;parser.c 파일의 parse_config_file() 함수</em>  </p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-built_in">int</span> parse<span class="hljs-constructor">_config_file(<span class="hljs-params">const</span> <span class="hljs-params">char</span> <span class="hljs-operator">*</span><span class="hljs-params">fn</span>)</span>  <br>&#123;  <br>    <span class="hljs-built_in">char</span> *data;  <br>    data = read<span class="hljs-constructor">_file(<span class="hljs-params">fn</span>, 0)</span>;  <span class="hljs-comment">// 파일을 읽고  </span><br>    <span class="hljs-keyword">if</span> (!data) return -<span class="hljs-number">1</span>;  <br>    parse<span class="hljs-constructor">_config(<span class="hljs-params">fn</span>, <span class="hljs-params">data</span>)</span>;  <span class="hljs-comment">// 문자열 파싱  </span><br>    <span class="hljs-constructor">DUMP()</span>;  <br>    return <span class="hljs-number">0</span>;  <br>&#125;  <br></code></pre></td></tr></table></figure><p><strong>parse_config()</strong> 함수는 아래 코드와 같이 인자로 전달된 파일의 끝까지 각 라인을 파싱한다.<br><strong>next_token()</strong> 함수로 문자열을 라인 단위로 나눈 후 <strong>lookup_keyword()</strong> 함수를 호출한다.<br>lookup_keyword() 함수는 init.rc 파일의 각 라인에서 첫 단어에 해당하는 <strong>keyword_list 구조체 배열</strong>에서 번호를 반환한다.<br>이후에 배열 내 flag가 SECTION인지 판단하는데, SECTION flag는 “on”, “service” 키워드만 존재하기 때문에 서비스 리스트만 <strong>parse_new_section()</strong> 함수를 수행한다.<br>parse_new_section() 함수를 수행하고 나면 액션 리스트와 서비스 리스트가 완성된다.  </p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">static void parse<span class="hljs-constructor">_config(<span class="hljs-params">const</span> <span class="hljs-params">char</span> <span class="hljs-operator">*</span><span class="hljs-params">fn</span>, <span class="hljs-params">char</span> <span class="hljs-operator">*</span><span class="hljs-params">s</span>)</span>  <br>&#123;  <br>    <span class="hljs-keyword">for</span> (;;) &#123;  <br>        switch (next<span class="hljs-constructor">_token(&amp;<span class="hljs-params">state</span>)</span>) &#123; <span class="hljs-comment">// 문자열을 라인 단위로 나눈다.  </span><br>        case T_NEWLINE:  <br>            <span class="hljs-keyword">if</span> (nargs) &#123;  <br>                <span class="hljs-built_in">int</span> kw = lookup<span class="hljs-constructor">_keyword(<span class="hljs-params">args</span>[0])</span>; <span class="hljs-comment">// 구조체 배열에서 번호를 반환한다.  </span><br>                <span class="hljs-keyword">if</span> (kw<span class="hljs-constructor">_is(<span class="hljs-params">kw</span>, SECTION)</span>) &#123; <span class="hljs-comment">// flag가 SECTION인지 확인한다.  </span><br>                    state.parse<span class="hljs-constructor">_line(&amp;<span class="hljs-params">state</span>, 0, 0)</span>; <span class="hljs-comment">// 서비스 리스트만  </span><br>                    parse<span class="hljs-constructor">_new_section(&amp;<span class="hljs-params">state</span>, <span class="hljs-params">kw</span>, <span class="hljs-params">nargs</span>, <span class="hljs-params">args</span>)</span>; <span class="hljs-comment">// parse_new_section() 함수를 수행한다.  </span><br>                &#125;  <br>            &#125;  <br>        &#125;  <br>    &#125;  <br>&#125;  <br></code></pre></td></tr></table></figure><p>각 리스트는 <strong>KEYWORD 매크로</strong>를 사용해 생성된다.<br>KEYWORD 매크로는 parse.c와 keyword.h에 정의돼 있다.<br><strong>parse.c에 정의된 KEYWORD 매크로 &#x3D; KEYWORD 리스트를 keyword_list 구조체 배열로 변환</strong><br><strong>keyword.h에 정의된 KEYWORD 매크로 &#x3D; KEYWORD 리스트들을 1번부터 순서대로 번호 할당</strong>  </p><p><em>parse.c에 정의된 KEYWORD 매크로</em><br>COMMAND 그룹은 init 프로세스가 실행하는 명령어들을 의미, 해당 명령어의 실행 함수와 매핑.<br>SECTION 그룹은 액션 리스트, 서비스 리스트를 구분.<br>OPTION 그룹은 명령어, 프로세스를 실행할 때 실행 조건을 부여.<br>KEYWORD 리스트들은 KEYWORD 매크로를 통해 keyword_info 구조체 배열의 리스트로 변경.  </p><p><em>keyword.h에 정의된 KEYWORD 매크로</em><br>“K_키워드” 심볼로 정의된 열거형 데이터로 변환되어 1부터 차례대로 번호가 부여된다.  </p><h3 id="액션-리스트-및-서비스-리스트의-실행"><a href="#액션-리스트-및-서비스-리스트의-실행" class="headerlink" title="액션 리스트 및 서비스 리스트의 실행"></a>액션 리스트 및 서비스 리스트의 실행</h3><h4 id="액션-리스트-1"><a href="#액션-리스트-1" class="headerlink" title="액션 리스트"></a>액션 리스트</h4><p>액션 리스트 내의 명령어가 실행되는 과정을 먼저 살펴본다.<br>action_remove_queue_head() 함수를 통해서 전역으로 선언된 액션 리스트 헤더를 얻어온다.<br>액션 리스트를 command 구조체로 변환하고, 각 명령어에 매핑된 함수를 가져온다.  </p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">void drain<span class="hljs-constructor">_action_queue(<span class="hljs-params">void</span>)</span>  <br>&#123;  <br>    <span class="hljs-keyword">struct</span> listnode *node;  <br>    <span class="hljs-keyword">struct</span> command *cmd;  <br>    <span class="hljs-keyword">struct</span> action *act;  <br>    <span class="hljs-built_in">int</span> ret;  <br><br>    <span class="hljs-keyword">while</span> ((act = action<span class="hljs-constructor">_remove_queue_head()</span>)) &#123; <span class="hljs-comment">// action_queue 연결리스트 헤더를 얻어온다.  </span><br>        <span class="hljs-constructor">INFO(<span class="hljs-string">&quot;processing action %p (%s)\n&quot;</span>, <span class="hljs-params">act</span>, <span class="hljs-params">act</span>-&gt;<span class="hljs-params">name</span>)</span>;  <br>        <span class="hljs-built_in">list</span><span class="hljs-constructor">_for_each(<span class="hljs-params">node</span>, &amp;<span class="hljs-params">act</span>-&gt;<span class="hljs-params">commands</span>)</span> &#123;  <br>            cmd = node<span class="hljs-constructor">_to_item(<span class="hljs-params">node</span>, <span class="hljs-params">struct</span> <span class="hljs-params">command</span>, <span class="hljs-params">clist</span>)</span>; <span class="hljs-comment">// 리스트를 command 구초체로 변환한다.  </span><br>            ret = cmd-&gt;func(cmd-&gt;nargs, cmd-&gt;args); <span class="hljs-comment">// 각 명령어에 매핑된 함수  </span><br>            <span class="hljs-constructor">INFO(<span class="hljs-string">&quot;command &#x27;%s&#x27; r=%d\n&quot;</span>, <span class="hljs-params">cmd</span>-&gt;<span class="hljs-params">args</span>[0], <span class="hljs-params">ret</span>)</span>;  <br>        &#125;  <br>    &#125;  <br>&#125;  <br></code></pre></td></tr></table></figure><h4 id="서비스-리스트-1"><a href="#서비스-리스트-1" class="headerlink" title="서비스 리스트"></a>서비스 리스트</h4><p>‘on boot’ 섹선의 마지막 명령어인 class_start 명령어를 통해 service 섹션의 모든 프로세스를 실행하게 된다.</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">service<span class="hljs-constructor">_for_each_class(<span class="hljs-params">args</span>[1], <span class="hljs-params">service_start_if_not_disabled</span>)</span>;  <br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Android</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Android</tag>
      
      <tag>인사이드 안드로이드</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[인사이드 안드로이드] 챕터 2 - 안드로이드 개발 환경 구축</title>
    <link href="/chapter2/"/>
    <url>/chapter2/</url>
    
    <content type="html"><![CDATA[<h1 id="인사이드-안드로이드"><a href="#인사이드-안드로이드" class="headerlink" title="[인사이드 안드로이드]"></a>[인사이드 안드로이드]</h1><h2 id="Chapter2-안드로이드-개발-환경-구축"><a href="#Chapter2-안드로이드-개발-환경-구축" class="headerlink" title="Chapter2 - 안드로이드 개발 환경 구축"></a>Chapter2 - 안드로이드 개발 환경 구축</h2><h3 id="호스트-환경-구성"><a href="#호스트-환경-구성" class="headerlink" title="호스트 환경 구성"></a>호스트 환경 구성</h3><p>우분투 리눅스 상에서 안드로이드 플랫폼을 빌드하고 프레임워크를 디버깅하려면 우분투 개발활경을 구축해야한다.</p><p><em>우분투 버전이 책과 달라 환경구성은 아래 블로그를 참고했습니다.</em><br><em><a href="http://bitly.kr/7YftX">http://bitly.kr/7YftX</a></em></p><h4 id="설치과정"><a href="#설치과정" class="headerlink" title="설치과정"></a>설치과정</h4><ul><li>Ubuntu 14.04.6 LTS를 VirtualBox를 이용하여 설치한다.<br><em>추후에 필요하면 가상머신이 아닌 멀티부팅을 이용해 재설치할 예정.</em></li></ul><p><img src="/images/post/install1.PNG" alt="Alt text" title="설치1"></p><p><img src="/images/post/install2.PNG" alt="Alt text" title="설치2"></p><ul><li>필요 패키지를 설치하고, Repo 설치 및 안드로이드 소스코드를 다운로드 한다. 책에 있는것과 마찬가지로 froyo버전을 받았다.</li></ul><p><img src="/images/post/install3.PNG" alt="Alt text" title="설치3"></p><ul><li>안드로이드 플랫폼 빌드 확인을 위해 안드로이드 플랫폼 소스의 최상위 폴더에서 make명령어를 실행했다. 하지만 다음과 같은 에러가 발생하였다.</li></ul><p><img src="/images/post/error1.PNG" alt="Alt text" title="에러1"></p><p>해당 에러는 build system에서 “jar” command를 찾을 수 없어서 발생한다.<br>터미널에서 <em>which jar</em>을 입력하면 아무것도 뜨지않는데, 다음과 같이 해결하였다.  </p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">sudo update-alternatives --install <span class="hljs-regexp">/usr/</span>bin<span class="hljs-regexp">/jar jar /u</span>sr<span class="hljs-regexp">/lib/</span>jvm<span class="hljs-regexp">/jdk1.5.0_22/</span>bin/jar <span class="hljs-number">1</span> (자신의 jdk 경로)<br></code></pre></td></tr></table></figure><p><img src="/images/post/error2.PNG" alt="Alt text" title="에러2"></p><p><strong>이후로도 빌드 오류가 일어났는데, 발생한 오류 -&gt; 해결방법 순이다.</strong></p><p><img src="/images/post/error3.PNG" alt="Alt text" title="에러3"></p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs awk">frameworks<span class="hljs-regexp">/base/</span>tools<span class="hljs-regexp">/aapt/</span>Android.mk 파일의 <span class="hljs-number">31</span>번째 줄에 -fpermissive 추가  <br>LOCAL_CFLAGS += -Wno-format-y2k -fpermissive<br></code></pre></td></tr></table></figure><p><img src="/images/post/error4.PNG" alt="Alt text" title="에러4"></p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs awk">frameworks<span class="hljs-regexp">/base/</span>libs<span class="hljs-regexp">/utils/</span>Android.mk 파일의 <span class="hljs-number">64</span>번째 줄에 -fpermissive 추가  <br>LOCAL_CFLAGS += -DLIBUTILS_NATIVE=<span class="hljs-number">1</span> $(TOOL_CFLAGS) -fpermissive<br></code></pre></td></tr></table></figure><p><strong>-fpermissive 옵션은 부적합한 코드를 컴파일할 수 있도록 해주는 옵션이다.</strong></p><p><img src="/images/post/error5.PNG" alt="Alt text" title="에러5"></p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs powershell"><span class="hljs-built_in">cd</span> external/srec  <br><span class="hljs-built_in">wget</span> <span class="hljs-string">&quot;https://github.com/CyanogenMod/android_external_srec/commit/4d7ae7b79eda47e489669fbbe1f91ec501d42fb2.diff&quot;</span>  <br>patch <span class="hljs-literal">-p1</span> &lt; <span class="hljs-number">4</span>d7ae7b79eda47e489669fbbe1f91ec501d42fb2.diff  <br><span class="hljs-built_in">rm</span> <span class="hljs-operator">-f</span> <span class="hljs-number">4</span>d7ae7b79eda47e489669fbbe1f91ec501d42fb2.diff  <br></code></pre></td></tr></table></figure><p><img src="/images/post/error6.PNG" alt="Alt text" title="에러6"></p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs awk">sudo apt-get install gcc-<span class="hljs-number">4.4</span>  <br>sudo apt-get install g++-<span class="hljs-number">4.4</span>  <br><br>sudo rm -f <span class="hljs-regexp">/usr/</span>bin/gcc  <br>sudo rm -f <span class="hljs-regexp">/usr/</span>bin/g++  <br>sudo ln -s <span class="hljs-regexp">/usr/</span>bin<span class="hljs-regexp">/gcc-4.4 /u</span>sr<span class="hljs-regexp">/bin/g</span>cc  <br>sudo ln -s <span class="hljs-regexp">/usr/</span>bin<span class="hljs-regexp">/g++-4.4 /u</span>sr<span class="hljs-regexp">/bin/g</span>++  <br><br>sudo apt-get install g++-<span class="hljs-number">4.4</span>-multilib  <br></code></pre></td></tr></table></figure><p><img src="/images/post/error7.PNG" alt="Alt text" title="에러7"></p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">sudo apt-<span class="hljs-built_in">get</span> install libswitch-perl<br></code></pre></td></tr></table></figure><p><strong>위의 오류들을 수정하고 빌드에 성공했다.</strong></p><p><img src="/images/post/build.PNG" alt="Alt text" title="빌드완료"></p><ul><li>SDK 개발 환경 구축<br>책에서는 이클립스를 설치했지만, 나는 안드로이드 스튜디오를 설치했는데… ‘.classpath’파일이 없다…<br>안드로이드 스튜디오는 프레임워크 디버깅이 안된다??</li></ul>]]></content>
    
    
    <categories>
      
      <category>Android</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Android</tag>
      
      <tag>인사이드 안드로이드</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[인사이드 안드로이드] 챕터 1 - 프레임워크 개요</title>
    <link href="/chapter1/"/>
    <url>/chapter1/</url>
    
    <content type="html"><![CDATA[<h1 id="인사이드-안드로이드"><a href="#인사이드-안드로이드" class="headerlink" title="[인사이드 안드로이드]"></a>[인사이드 안드로이드]</h1><h2 id="Chapter1-프레임워크-개요"><a href="#Chapter1-프레임워크-개요" class="headerlink" title="Chapter1 - 프레임워크 개요"></a>Chapter1 - 프레임워크 개요</h2><h3 id="서론"><a href="#서론" class="headerlink" title="서론"></a>서론</h3><p>나는 컴퓨터공학과 종합설계 주제 중 ‘안드로이드 프레임워크 개선’을 선택했다. 물론 지금까지 프레임워크를 접한 적은 없다. 지금까지 ‘모바일소프트웨어설계’수업과 간단한 안드로이드 어플리케이션을 제작 해본 게 전부이다. 하지만 안드로이드를 접하면서 흥미를 느꼈고, 모바일 고급 개발자로 나아가고 싶었다. 그러기 위해서 프레임워크의 동작 원리를 이해하고, 분석하여 안드로이드의 프레임워크를 좀 더 개선하면 좋을 것 같다. 앞으로 GitHub 블로그와 ‘인사이드 안드로이드’책을 통해 공부하기로 한다.</p><p><em>이 책이 2010년 출간이라, 버전이 Cupcake, Froyo가 발표될 즈음 이라는데 크게 상관없는지는 잘 모르겠다.</em></p><h4 id="안드로이드-프레임워크-개요"><a href="#안드로이드-프레임워크-개요" class="headerlink" title="안드로이드 프레임워크 개요"></a>안드로이드 프레임워크 개요</h4><p>안드로이드 개발자 가이드 사이트에 따르면 안드로이드를 운영체제와 미들웨어, 그리고 핵심 애플리케이션을 포함한 모바일 디바이스 개발에 적합한 <strong>소프트웨어 스택</strong> 이라 정의한다. 즉, 안드로이드는 모바일 디바이스용 애플리케이션을 쉽게 제작하기 위한 <strong>소프트웨어 프레임워크</strong> 를 제공해 준다.</p><p>다음 그림은 안드로이드 플랫폼의 구조이다.</p><p><img src="/images/post/framework.png" alt="안드로이드 내부 구조" title="안드로이드 내부 구조"></p><ul><li>내부 구조는 크게 애플리케이션 프레임워크, 라이브러리, 안드로이드 런타임, 리눅스 커널로 구성되어있다.</li><li>애플리케이션은 애플리케이션 프레임워크 레이어 위에서 동작한다.</li><li>안드로이드 플랫폼 개발자가 되기 위해서는 프레임워크에 대한 심도 있는 이해가 필수다.</li></ul><h4 id="안드로이드의-소스-코드-구조"><a href="#안드로이드의-소스-코드-구조" class="headerlink" title="안드로이드의 소스 코드 구조"></a>안드로이드의 소스 코드 구조</h4><p>주요 소스 코드의 구성은 다음과 같다.</p><ul><li>Kernel : 안드로이드의 리눅스 커널</li><li>bionic : 안들이드 표준 C라이브러리</li><li>bootloader : 참고용 안드로이드 부트로더</li><li>build : 안드로이드 빌드 시스템</li><li>cts : 안드로이드 호환성 테스트 관련 소스</li><li>dalvik : 달빅 가상 머신</li><li>external : 안드로이드에서 사용하는 오픈소스들</li><li>frameworks : <strong>안드로이드 프레임워크</strong></li><li>hardware : 안드로이드 HAL(Hardware Abstraction Layer) 소스</li><li>packages : 안드로이드 기본 애플리케이션, 컨텐트 프로바이더 등</li><li>system : 안드로이드 init 프로세스, 블루투스 도구 모음 등</li></ul><h4 id="안드로이드의-부팅-과정"><a href="#안드로이드의-부팅-과정" class="headerlink" title="안드로이드의 부팅 과정"></a>안드로이드의 부팅 과정</h4><ol><li><strong>bootloader</strong> 를 통해 리눅스 <strong>Kernel</strong> 이 먼저 시작된다. Kernel 초기화를 수행한 후 마지막 과정에서 init 프로세스를 호출한다.</li><li><strong>init 프로세스</strong> 는 각종 데몬, 컨텍스트 매니저, 미디어 서버, Zygote등을 실행한다.</li><li><strong>컨텍스트 매니저</strong> 는 안드로이드의 시스템 서비스를 관리하는 프로세스로, 프레임워크를 구성하는 중요한 컴포넌트이다. 안드로이드 내에서 동작하는 각종 시스템 서비스에 대한 정보는 컨텍스트 매니저에게서 얻을 수 있다.</li><li><strong>미디어 서버</strong> 는 안드로이드에서 오디오와 카메라같은 C&#x2F;C++ 네이티브 시스템 서비스를 실행하는 역할을 한다.</li><li><strong>Zygote</strong> 는 application을 빠르게 구동하기 위해서 미리 fork 되어 있는 process다. 애플리케이션의 시작 시간을 단축시키며 메모리 공유를 최적화 할 수 있다.</li><li><strong>시스템서버</strong> 는 Zygote에서 최초로 fork되어 실행되는 프로세스다. 시스템 서버는 애플리케이션 생명 주기를 제어하는 액티비티 매니저 서비스나 단말기의 위치 정보를 제공하는 로케이션 매니저 서비스와 같은 자바 시스템 서비스를 실행하는 역할을 한다.</li><li>모든 자바 시스템 서비스가 로딩되고나면 액티비티 매니저 서비스가 HOME 애플리케이션을 실행하며 부팅 과정이 진행된다.</li></ol><ul><li>자바 시스템 서비스를 C언어 기반의 서비스 매니저에 등록하려면 자바와 C언어 간의 인터페이스 역할을 하는 JNI(Java Native Interface)를 추가로 이용해야 한다!</li></ul>]]></content>
    
    
    <categories>
      
      <category>Android</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Android</tag>
      
      <tag>인사이드 안드로이드</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
